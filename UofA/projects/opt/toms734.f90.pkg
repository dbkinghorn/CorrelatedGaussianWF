<HTML>
<BODY BGCOLOR="#ffffff">
<TITLE>GAMS : Fullsource of 734 in TOMS from NETLIB </TITLE>
<PLAINTEXT>
* ======================================================================
* NIST Guide to Available Math Software.
* Fullsource for module 734 from package TOMS.
* Retrieved from NETLIB on Thu Aug 13 15:57:17 1998.
* ======================================================================
C      ALGORITHM 734, COLLECTED ALGORITHMS FROM ACM.
C      THIS WORK PUBLISHED IN TRANSACTIONS ON MATHEMATICAL SOFTWARE,
C      VOL. 20, NO. 3, SEPTEMBER, 1994, PP. 354-372.
! <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> install.doc
This file contains detailed instructions on how to obtain the
modules and test programs from the distributed files.
Also provided is a list of the module dependencies.

Note that the most recent version of this algorithm may be
obtained by anonymous ftp from the site ftp.royalroads.ca in
the usual fashion.  The two distribution files are found in
the directory pub/software/bbuckley/alg734.

In accordance with TOMS requirements, the distribution consists
of two files. The first, which I will call 'source', contains all
the Fortran 90 source code.  The second, 'other', contains
related material, including this document as the first part.

Each of these files is in fact a concatenation of a number of
original files, with a special separator line to begin each
new file. The separator line consists of

 ! <<=>> <<=>> <<=>> ...                                 file.name

The last field is the name of the file to follow.

It is not necessary to separate the file 'source' into all its
constituent parts, although it is probably worth separating 'other'
into its parts.  These are

    install.doc  This file.
    breakup.g    An awk script to assist in separating the files.
    namelist.inp An input file to run the test in section 14 of the paper.
    toms.out     A file of the results for the Section 14 test.
    example.out  A file of the results for Rosenbrock's function.
    cputime.c    A C routine for timing for many Unix systems.
    min.doc      The complete internal documentation.

Note that breakup.g is not required. However, for users with access to
awk (or gawk, or nawk, or ...) we suggest manually extracting breakup.g
and then using it to separate the files.  It does one other job besides
separating the files, which will be explained below.

Now consider the source file.  It contains all of the modules which
constitute the published algorithm.  These conclude with an empty
file named 'test.nam', so there is one line in the file ending with
'test.nam' which marks the end of the algorithm. This is followed
by two main programs for testing the algorithm. Each program is
preceded by a module which contains an appropriate test function.
These files are

    the test function   test_functions.f90 and
    the test program    toms.f90

discussed in Section 14 of the paper, followed by

    the test function   RosenbrockFunc.f90 in Section 5, followed by
    the test program    example.f90

from Section 4.  The first test is fairly computationally expensive.
On a 5 megaflop Sun SPARCstation 10, it runs for about 130 secs.
Around 700 seconds are needed on a SPARCstation 1.  If this is
too much, read the directions at the beginning of the file toms.f90;
it is very easy to reduce this to a much shorter test.

One may proceed in one of two ways at this point.  These instructions
are meant to be generic, and are without reference to any system or
compiler.  Some renaming of the files may be necessary on some systems.

1. Without separating out all the source files:

    First, the four test files should be removed from 'source' and
    saved separately.

    Then the remainder of 'source' should be compiled with a fully
    compliant Fortran 90 compiler, and the compiled object code
    saved appropriately.  Also, compile the file cputime.c, if
    necessary (Section 3.2 of the paper). This is only done if the
    module general has been  modified to access the c timing routine

 ** This then constitutes the compiled code for Algorithm 734. It
    may be saved or placed in a library as desired.

    If it is wished to run the tests, then proceed as follows.

    For the simple test with Rosenbrock's function from Section 5:

        Be sure the compiled modules are available and accessible.
        Then compile RosenbrockFunc.f90, and finally compile
        example.f90.  Link the compiled code and run the test.
        The output should be virtually identical to that in the
        file example.out.

    For the longer test from Section 14.

        Be sure the compiled modules are available and accessible.
        Then compile test_functions.f90, and finally compile
        toms.f90.   Link the compiled code.  When the program is run,
        a prompt will appear asking for the tests to be executed; enter
        a -3 or an end-of-file.  Data for the tests are read from file
        namelist.inp through unit 7.  The test output is written to a
        file called 'results' through unit 8.  This output should be
        virtually identical to that in the file toms.out.

        Of course, it is possible to run other tests using toms.f90 by
        changing the values of the arguments of the minimization routine -
        see the internal documentation in toms.f90.

2. Separating 'source' into all its constituent parts.

    If this is done, then one will have a separate file for each
    of the Fortran 90 modules which constitute Algorithm 734, as
    well as the four test files mentioned above.

    The main concern is then that the modules must be compiled in
    a specific order, for a module which is USEd must be compiled
    before the program unit which uses it.

    A correct compilation order is defined by the order in which the
    modules appear in the file 'source'.  As well, for Unix users, if
    the awk script breakup.g is used to separate 'source' into its
    constituent parts, then a file 'compile.ord' will also be created.
    In it, a list of the modules will appear, in the order in which
    they must be compiled.  Indeed, for Unix users of the NAG f90
    compiler, one may just execute the command 'source compile.ord'
    and all the modules will be compiled.

    The file cputime.c must also be compiled, if necessary, as in 1 above.

    Once these routines are compiled, one may continue from the
    point marked ** under point 1.



The following is a list of the module dependencies.  For each module there
is a list of all the modules it uses.  The modules are grouped into sections:
the modules in each section are independent of each other and only use
modules that appear in sections below them.

An alternate description of the module dependencies follows.  It is a matter
of preference as to which one finds easiest to read.

Module         Modules Used
===============================================================================
minimize:      precision, min_codes, systemstate, minimizef
===============================================================================
minimizef:     precision, min_states, min_codes, min_defaults, supp_states,
               supp_codes, supp_defs, support, reals, num_constants,
               inner_product, general, systemstate, true_false, checkpoint,
               control, dynamic, errorcodes, factored, h0v, initialize,
               linesearch, myallocate, product, qnewton, restart, sum, update
===============================================================================
update:        precision, min_states, min_codes, inner_product, general, reals,
               true_false, qnewton, sum
===============================================================================
factored:      precision, min_states, inner_product, reals, general, h0v
product:       precision, min_states, min_codes, supp_codes, inner_product,
               general, true_false, h0v
sum:           precision, min_states, min_codes, inner_product, reals, general,
               true_false, h0v
===============================================================================
support:       print, evaluatef, testdone, fscale
dynamic:       precision, min_states, min_codes, inner_product, general, reals,
               qnewton
h0v:           precision, min_states, min_codes, reals, general, true_false
initialize:    precision, min_states, min_codes, reals, general, myallocate
linesearch:    precision, min_states, min_codes, general, reals, true_false,
               cubic
===============================================================================
evaluatef:     precision, supp_states, supp_codes, supp_defs, general,
               num_constants, reals, true_false, fscale
print:         precision, supp_states, general, true_false
testdone:      precision, supp_states, supp_codes, general, inner_product,
               reals, true_false
checkpoint:    precision, systemstate, general, min_states, min_defaults,
               true_false
cubic:         precision, min_states, reals, num_constants, general, true_false
myallocate:    precision, min_states, min_codes, general
qnewton:       precision, min_states, inner_product, general
restart:       precision, min_states, min_codes, min_defaults, general,
               systemstate, true_false
===============================================================================
general:       precision, reals, strings
inner_product: precision, num_constants, reals
fscale:        precision, supp_codes, reals, true_false
supp_defs:     precision, true_false, reals, supp_states, supp_codes
control:       precision, min_states, min_codes
errorcodes:    precision, min_states, min_codes
min_defaults:  precision, min_states, min_codes, reals, true_false
systemstate:   precision, min_states, supp_states
===============================================================================
num_constants: precision
reals:         precision
strings:       precision
supp_codes:    precision
supp_states:   precision
min_codes:     precision
min_states:    precision
===============================================================================
precision:     normal, integers
===============================================================================
true_false:
normal:
low:
extended:
integers:
===============================================================================


Module dependencies revisited.

Each module uses only modules which follow in the same column.
Each such module appears in a column to the right.  A module never
depends on modules appearing in a column to its left. To make the
lists fit on one screen, the names are abbreviated as given.


Module         Abbreviation           Module         Abbreviation
-----------------------------------------------------------------
minimize:      min                    inner_product: inner
minimizef:     minf                   fscale:        fscale
update:        update                 supp_defs:     sdefs
factored:      factor                 control:       contrl
product:       prod                   errorcodes:    error
sum:           sum                    min_defaults:  mdefs
support:       supprt                 systemstate:   system
dynamic:       dynam                  num_constants: numcon
h0v:           h0v                    reals:         reals
initialize:    init                   strings:       string
linesearch:    line                   supp_codes:    scodes
evaluatef:     evalf                  supp_states:   sstate
print:         print                  min_codes:     mcodes
testdone:      test                   min_states:    mstate
checkpoint:    check                  precision:     prec
cubic:         cubic                  true_false:    true
myallocate:    myall                  normal:        normal
qnewton:       qnewt                  low:           low
restart:       restrt                 extended:      extend
general:       genral                 integers:      integer

===============================================================================
min:   |minf:  |update:|factor:|supprt:|evalf: |genral:|numcon:|prec:  |normal:
prec   |prec   |prec   |prec   |evalf  |prec   |prec   |prec   |normal |
mcodes |genral |genral |genral |fscale |genral |reals  |       |integer|
minf   |inner  |inner  |inner  |print  |numcon |string |       |       |
system |numcon |reals  |reals  |test   |reals  |       |       |       |
       |reals  |true   |mstate |       |true   |       |       |       |
       |true   |mcodes |h0v    |       |scodes |       |       |       |
       |scodes |mstate |       |       |sdefs  |       |       |       |
       |sdefs  |qnewt  |       |       |sstate |       |       |       |
       |sstate |sum    |       |       |fscale |       |       |       |
       |supprt |       |       |       |       |       |       |       |
       |mcodes |       |prod:  |dynam: |print: |inner: |reals: |       |low:
       |mdefs  |       |prec   |prec   |prec   |prec   |prec   |       |
       |mstate |       |genral |genral |genral |numcon |       |       |
       |check  |       |inner  |inner  |true   |reals  |       |       |
       |contrl |       |true   |reals  |sstate |       |       |       |
       |dynam  |       |scodes |mcodes |       |       |       |       |
       |error  |       |mcodes |mstate |       |       |       |       |
       |factor |       |mstate |qnewt  |       |       |       |       |
       |h0v    |       |h0v    |       |       |       |       |       |
       |init   |       |       |       |       |       |       |       |
       |line   |       |       |       |       |       |       |       |
       |myall  |       |       |       |       |       |       |       |
       |prod   |       |sum:   |h0v:   |test:  |fscale:|string:|       |extend:
       |qnewt  |       |prec   |prec   |prec   |prec   |prec   |       |
       |restrt |       |genral |genral |genral |reals  |       |       |
       |sum    |       |inner  |reals  |inner  |true   |       |       |
       |system |       |reals  |true   |reals  |scodes |       |       |
       |update |       |true   |mcodes |true   |       |       |       |
       |       |       |mcodes |mstate |scodes |       |       |       |
       |       |       |mstate |       |sstate |       |       |       |
       |       |       |h0v    |       |       |       |       |       |
       |       |       |       |       |       |       |       |       |
       |       |       |       |init:  |check: |sdefs: |scodes:|       |integer:
       |       |       |       |prec   |prec   |prec   |prec   |       |
       |       |       |       |genral |genral |reals  |       |       |
       |       |       |       |reals  |true   |true   |       |       |
       |       |       |       |mcodes |mdefs  |scodes |       |       |
       |       |       |       |mstate |mstate |sstate |       |       |
       |       |       |       |       |system |       |       |       |
       |       |       |       |       |       |       |       |       |
       |       |       |       |line:  |cubic: |contrl:|sstate:|       |true:
       |       |       |       |prec   |prec   |prec   |prec   |       |
       |       |       |       |genral |genral |mcodes |       |       |
       |       |       |       |reals  |numcon |mstate |       |       |
       |       |       |       |true   |reals  |       |       |       |
       |       |       |       |mcodes |true   |       |       |       |
       |       |       |       |mstate |mstate |       |       |       |
       |       |       |       |cubic  |       |       |       |       |
       |       |       |       |       |       |       |       |       |
       |       |       |       |       |myall: |error: |mcodes:|       |
       |       |       |       |       |prec   |prec   |prec   |       |
       |       |       |       |       |genral |mcodes |       |       |
       |       |       |       |       |mcodes |mstate |       |       |
       |       |       |       |       |mstate |       |       |       |
       |       |       |       |       |       |       |       |       |
       |       |       |       |       |       |       |       |       |
       |       |       |       |       |qnewt: |mdefs: |mstate:|       |
       |       |       |       |       |prec   |prec   |prec   |       |
       |       |       |       |       |genral |reals  |       |       |
       |       |       |       |       |inner  |true   |       |       |
       |       |       |       |       |mstate |mcodes |       |       |
       |       |       |       |       |       |mstate |       |       |
       |       |       |       |       |       |       |       |       |
       |       |       |       |       |restrt:|system:|       |       |
       |       |       |       |       |prec   |prec   |       |       |
       |       |       |       |       |genral |sstate |       |       |
       |       |       |       |       |true   |mstate |       |       |
       |       |       |       |       |mcodes |       |       |       |
       |       |       |       |       |mdefs  |       |       |       |
       |       |       |       |       |mstate |       |       |       |
       |       |       |       |       |system |       |       |       |
! <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> breakup.g
BEGIN   { out="/dev/null"; doit = "yes" }

$5 ~  /<<=>>/                 { if (out !="/dev/null") print "closing " out".";
                                close(out);
                                out = $11;
                                print "output now "out"."}

$5 ~  /<<=>>/ && $11 ~ /\.nam$/ { doit = "no"
                                }

$5 ~  /<<=>>/ && $11 ~ /.f90/ { if ( doit == "yes" )
                        print "echo " $11"; f90 -c " $11 >"compile.ord"}

$5 !~ /<<=>>/                 { print $0 > out}

END     { print "closing " out"."; close(out) }
! <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> namelist.inp
&Args
    state       = 0,
    dotrace     = false
/
&Args
    state       = 2,
    dotrace     = false
/
&Args
    state       = 0,
    dotrace     = false,
    derv        = 4
/
&Args
    state       = 0,
    dotrace     = false,
    derv        = 2
/
&Args
    state       = 0,
    dotrace     = false,
    meth        = 3,
    mterms      = 2
/
&Args
    state       = 2,
    dotrace     = false,
    meth        = 7
/
&Args
    state       = 0,
    dotrace     = false,
    meth        = 3,
    mterms      = 2,
    update      = 1
/
&Args
    state       = 0,
    dotrace     = false,
    run8        = true
/
&Args
    state       = 0,
    dotrace     = false,
    meth        = 6
/
&Args
    state       = 0,
    dotrace     = false,
    expens      = 300,
    meth        = 6
/
! <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> toms.out
 starting test at  1:28 p.m., Monday, August 30, 1993
1 beginning run # 1: analytic mode, forward calls; meth= Available.

 function # 1

  [Prnt] pt   0; f=  41.68169586167801    (#  1) ||g||=.85E+02(#  1);    0.000 s
  [Prnt] pt   9; f= 0.9979563513253990E-02(# 10) ||g||=.46E-02(# 10);    0.000 s

 ************* Run Complete, status =   0.


 function # 2

  [Prnt] pt   0; f= 0.7790700756559702    (#  1) ||g||=.26E+01(#  1);    0.000 s
  [Prnt] pt  43; f= 0.5655650634086444E-02(# 46) ||g||=.10E-03(# 46);    0.000 s

 ************* Run Complete, status =   0.


 function # 3

  [Prnt] pt   0; f=  1031.153810609398    (#  1) ||g||=.15E+03(#  1);    0.000 s
  [Prnt] pt  18; f= 0.1155940389680368E-03(# 23) ||g||=.46E-03(# 23);    0.000 s

 ************* Run Complete, status =   0.


 function # 4

  [Prnt] pt   0; f=  2.266182511289055    (#  1) ||g||=.12E+02(#  1);    0.000 s
  [Prnt] pt  37; f= 0.2598111368328460E-06(# 39) ||g||=.66E-04(# 39);    0.040 s

 ************* Run Complete, status =   0.


 function # 5

  [Prnt] pt   0; f=  629.0000000000000    (#  1) ||g||=.46E+03(#  1);    0.000 s
  [Prnt] pt  26; f= 0.1268884276519305E-11(# 30) ||g||=.10E-03(# 30);    0.000 s

 ************* Run Complete, status =   0.


 function # 6

  [Prnt] pt   0; f=  148032.5653500000    (#  1) ||g||=.30E+05(#  1);    0.000 s
  [Prnt] pt  19; f= 0.7446886540286594E-04(# 20) ||g||=.29E-04(# 20);    0.000 s

 ************* Run Complete, status =   0.


 function # 7

  [Prnt] pt   0; f=  162.6526819887061    (#  1) ||g||=.50E+03(#  1);    0.000 s
  [Prnt] pt  18; f= 0.1947559660561768E-03(# 24) ||g||=.13E-04(# 24);    0.020 s

 ************* Run Complete, status =   0.


 function # 8

  [Prnt] pt   0; f=  2150.000000000000    (#  1) ||g||=.15E+04(#  1);    0.000 s
  [Prnt] pt  35; f= 0.1830050294747058E-05(# 36) ||g||=.79E-03(# 36);    0.000 s

 ************* Run Complete, status =   0.


 function # 9

  [Prnt] pt   0; f=  24.20000000000000    (#  1) ||g||=.23E+03(#  1);    0.000 s
  [Prnt] pt  35; f= 0.3316606905652118E-10(# 43) ||g||=.26E-03(# 43);    0.000 s

 ************* Run Complete, status =   0.


 function #10

  [Prnt] pt   0; f= -2.860065561048750    (#  1) ||g||=.84E+00(#  1);    0.000 s
  [Prnt] pt  13; f= -2.999999999962793    (# 18) ||g||=.35E-04(# 18);    0.000 s

 ************* Run Complete, status =   0.

1 beginning run # 2: analytic mode, reverse calls; meth= Available.

 function # 1

  [Prnt] pt   0; f=  41.68169586167801    (#  1) ||g||=.85E+02(#  1);    0.000 s
  [Prnt] pt   9; f= 0.9979563513253990E-02(# 10) ||g||=.46E-02(# 10);    0.000 s

 ************* Run Complete, status =   0.


 function # 2

  [Prnt] pt   0; f= 0.7790700756559702    (#  1) ||g||=.26E+01(#  1);    0.000 s
  [Prnt] pt  43; f= 0.5655650634086444E-02(# 46) ||g||=.10E-03(# 46);    0.060 s

 ************* Run Complete, status =   0.


 function # 3

  [Prnt] pt   0; f=  1031.153810609398    (#  1) ||g||=.15E+03(#  1);    0.000 s
  [Prnt] pt  18; f= 0.1155940389680368E-03(# 23) ||g||=.46E-03(# 23);    0.020 s

 ************* Run Complete, status =   0.


 function # 4

  [Prnt] pt   0; f=  2.266182511289055    (#  1) ||g||=.12E+02(#  1);    0.000 s
  [Prnt] pt  37; f= 0.2598111368328460E-06(# 39) ||g||=.66E-04(# 39);    0.000 s

 ************* Run Complete, status =   0.


 function # 5

  [Prnt] pt   0; f=  629.0000000000000    (#  1) ||g||=.46E+03(#  1);    0.000 s
  [Prnt] pt  26; f= 0.1268884276519305E-11(# 30) ||g||=.10E-03(# 30);    0.000 s

 ************* Run Complete, status =   0.


 function # 6

  [Prnt] pt   0; f=  148032.5653500000    (#  1) ||g||=.30E+05(#  1);    0.000 s
  [Prnt] pt  19; f= 0.7446886540286594E-04(# 20) ||g||=.29E-04(# 20);    0.000 s

 ************* Run Complete, status =   0.


 function # 7

  [Prnt] pt   0; f=  162.6526819887061    (#  1) ||g||=.50E+03(#  1);    0.000 s
  [Prnt] pt  18; f= 0.1947559660561768E-03(# 24) ||g||=.13E-04(# 24);    0.000 s

 ************* Run Complete, status =   0.


 function # 8

  [Prnt] pt   0; f=  2150.000000000000    (#  1) ||g||=.15E+04(#  1);    0.000 s
  [Prnt] pt  35; f= 0.1830050294747058E-05(# 36) ||g||=.79E-03(# 36);    0.040 s

 ************* Run Complete, status =   0.


 function # 9

  [Prnt] pt   0; f=  24.20000000000000    (#  1) ||g||=.23E+03(#  1);    0.000 s
  [Prnt] pt  35; f= 0.3316606905652118E-10(# 43) ||g||=.26E-03(# 43);    0.000 s

 ************* Run Complete, status =   0.


 function #10

  [Prnt] pt   0; f= -2.860065561048750    (#  1) ||g||=.84E+00(#  1);    0.000 s
  [Prnt] pt  13; f= -2.999999999962793    (# 18) ||g||=.35E-04(# 18);    0.000 s

 ************* Run Complete, status =   0.

1 beginning run # 3: differencing,  forward calls; meth= Available.

 function # 1

  [Prnt] pt   0; f=  41.68169586167801    (#  1) ||g||=.85E+02(#  1);    0.020 s
  [Prnt] pt   9; f= 0.9979563487512387E-02(# 10) ||g||=.46E-02(# 10);    0.020 s

 ************* Run Complete, status =   0.


 function # 2

  [Prnt] pt   0; f= 0.7790700756559702    (#  1) ||g||=.26E+01(#  1);    0.000 s
  [Prnt] pt  43; f= 0.5655650640066523E-02(# 46) ||g||=.10E-03(# 46);    0.080 s

 ************* Run Complete, status =   0.


 function # 3

  [Prnt] pt   0; f=  1031.153810609398    (#  1) ||g||=.15E+03(#  1);    0.000 s
  [Prnt] pt  18; f= 0.1155940541066556E-03(# 23) ||g||=.46E-03(# 23);    0.040 s

 ************* Run Complete, status =   0.


 function # 4

  [Prnt] pt   0; f=  2.266182511289055    (#  1) ||g||=.12E+02(#  1);    0.000 s
  [Prnt] pt  37; f= 0.2598058395814465E-06(# 39) ||g||=.66E-04(# 39);    0.020 s

 ************* Run Complete, status =   0.


 function # 5

  [Prnt] pt   0; f=  629.0000000000000    (#  1) ||g||=.46E+03(#  1);    0.000 s
  [Prnt] pt  26; f= 0.7350504582619462E-10(# 30) ||g||=.10E-03(# 30);    0.040 s

 ************* Run Complete, status =   0.


 function # 6

  [Prnt] pt   0; f=  148032.5653500000    (#  1) ||g||=.30E+05(#  1);    0.000 s
  [Prnt] pt  19; f= 0.7446898158028722E-04(# 20) ||g||=.29E-04(# 20);    0.040 s

 ************* Run Complete, status =   0.


 function # 7

  [Prnt] pt   0; f=  162.6526819887061    (#  1) ||g||=.50E+03(#  1);    0.000 s
  [Prnt] pt  18; f= 0.1947559661114342E-03(# 24) ||g||=.13E-04(# 24);    0.060 s

 ************* Run Complete, status =   0.


 function # 8

  [Prnt] pt   0; f=  2150.000000000000    (#  1) ||g||=.15E+04(#  1);    0.000 s
  [Prnt] pt  35; f= 0.1845272671545411E-05(# 36) ||g||=.11E-02(# 36);    0.160 s

 ************* Run Complete, status =   0.


 function # 9

  [Prnt] pt   0; f=  24.20000000000000    (#  1) ||g||=.23E+03(#  1);    0.000 s
  [Prnt] pt  35; f= 0.5161578294273413E-10(# 43) ||g||=.24E-03(# 43);    0.000 s

 ************* Run Complete, status =   0.


 function #10

  [Prnt] pt   0; f= -2.860065561048750    (#  1) ||g||=.84E+00(#  1);    0.000 s
  [Prnt] pt  13; f= -2.999999999963143    (# 18) ||g||=.35E-04(# 18);    0.000 s

 ************* Run Complete, status =   0.

1 beginning run # 4: testing mode,  forward calls; meth= Available.

 function # 1

  [Prnt] pt   0; f=  41.68169586167801    (#  1) ||g||=.85E+02(#  1);    0.000 s
  [Prnt] pt   9; f= 0.9979563513253990E-02(# 10) ||g||=.46E-02(# 10);    0.000 s

 ************* Run Complete, status =   0.


 function # 2

  [Prnt] pt   0; f= 0.7790700756559702    (#  1) ||g||=.26E+01(#  1);    0.020 s
  [Prnt] pt  43; f= 0.5655650634086444E-02(# 46) ||g||=.10E-03(# 46);    0.200 s

 ************* Run Complete, status =   0.


 function # 3

  [Prnt] pt   0; f=  1031.153810609398    (#  1) ||g||=.15E+03(#  1);    0.000 s
  [Prnt] pt  18; f= 0.1155940389680368E-03(# 23) ||g||=.46E-03(# 23);    0.020 s

 ************* Run Complete, status =   0.


 function # 4

  [Prnt] pt   0; f=  2.266182511289055    (#  1) ||g||=.12E+02(#  1);    0.000 s
  [Prnt] pt  37; f= 0.2598111368328460E-06(# 39) ||g||=.66E-04(# 39);    0.020 s

 ************* Run Complete, status =   0.


 function # 5

  [Prnt] pt   0; f=  629.0000000000000    (#  1) ||g||=.46E+03(#  1);    0.000 s
  [Prnt] pt  26; f= 0.1268884276519305E-11(# 30) ||g||=.10E-03(# 30);    0.000 s

 ************* Run Complete, status =   0.


 function # 6

  [Prnt] pt   0; f=  148032.5653500000    (#  1) ||g||=.30E+05(#  1);    0.000 s
  [Prnt] pt  19; f= 0.7446886540286594E-04(# 20) ||g||=.29E-04(# 20);    0.040 s

 ************* Run Complete, status =   0.


 function # 7

  [Prnt] pt   0; f=  162.6526819887061    (#  1) ||g||=.50E+03(#  1);    0.000 s
  [Prnt] pt  18; f= 0.1947559660561768E-03(# 24) ||g||=.13E-04(# 24);    0.080 s

 ************* Run Complete, status =   0.


 function # 8

  [Prnt] pt   0; f=  2150.000000000000    (#  1) ||g||=.15E+04(#  1);    0.020 s
  [Prnt] pt  35; f= 0.1830050294747058E-05(# 36) ||g||=.79E-03(# 36);    0.340 s

 ************* Run Complete, status =   0.


 function # 9

  [Prnt] pt   0; f=  24.20000000000000    (#  1) ||g||=.23E+03(#  1);    0.000 s
  [Prnt] pt  35; f= 0.3316606905652118E-10(# 43) ||g||=.26E-03(# 43);    0.000 s

 ************* Run Complete, status =   0.


 function #10

  [Prnt] pt   0; f= -2.860065561048750    (#  1) ||g||=.84E+00(#  1);    0.000 s
  [Prnt] pt  13; f= -2.999999999962793    (# 18) ||g||=.35E-04(# 18);    0.000 s

 ************* Run Complete, status =   0.



 Testing mode derivative estimation errors

 max error  component  iterate  av. decimals

  0.19E-07      2           3     8.13
  0.66E-07      4           2     7.85
  0.50E-03      2           3     7.56
 -0.70E-06      1           2     7.99
  0.28E-05      2          24     8.08
  0.29E-05      1           2     7.95
  0.95E-05      1           4     8.14
  0.36E-03      7           2     8.74
  0.77E-07      1          18     8.11
  0.21E-06      3           2     8.10

1 beginning run # 5: analytic mode, forward calls; meth= FixTerms.

 function # 1

  [Prnt] pt   0; f=  41.68169586167801    (#  1) ||g||=.85E+02(#  1);    0.000 s
  [Prnt] pt   8; f= 0.9979046504339782E-02(#  9) ||g||=.33E-02(#  9);    0.000 s

 ************* Run Complete, status =   0.


 function # 2

  [Prnt] pt   0; f= 0.7790700756559702    (#  1) ||g||=.26E+01(#  1);    0.000 s
  [Prnt] pt  62; f= 0.1449025279228232E-01(# 82) ||g||=.11E-01(# 82);    0.060 s

 ************* Run Complete, status =   0.


 function # 3

  [Prnt] pt   0; f=  1031.153810609398    (#  1) ||g||=.15E+03(#  1);    0.000 s
  [Prnt] pt  18; f= 0.1224664189148040E-03(# 25) ||g||=.57E-03(# 25);    0.040 s

 ************* Run Complete, status =   0.


 function # 4

  [Prnt] pt   0; f=  2.266182511289055    (#  1) ||g||=.12E+02(#  1);    0.000 s
  [Prnt] pt  24; f= 0.1885171251948210E-05(# 31) ||g||=.21E-03(# 31);    0.000 s

 ************* Run Complete, status =   0.


 function # 5

  [Prnt] pt   0; f=  629.0000000000000    (#  1) ||g||=.46E+03(#  1);    0.000 s
  [Prnt] pt  27; f= 0.7521861258578740E-04(# 36) ||g||=.22E-01(# 36);    0.000 s

 ************* Run Complete, status =   0.


 function # 6

  [Prnt] pt   0; f=  148032.5653500000    (#  1) ||g||=.30E+05(#  1);    0.000 s
  [Prnt] pt  19; f= 0.7446692822484672E-04(# 20) ||g||=.29E-04(# 20);    0.000 s

 ************* Run Complete, status =   0.


 function # 7

  [Prnt] pt   0; f=  162.6526819887061    (#  1) ||g||=.50E+03(#  1);    0.000 s
  [Prnt] pt  16; f= 0.1948184130374006E-03(# 21) ||g||=.39E-05(# 21);    0.000 s

 ************* Run Complete, status =   0.


 function # 8

  [Prnt] pt   0; f=  2150.000000000000    (#  1) ||g||=.15E+04(#  1);    0.000 s
  [Prnt] pt  32; f= 0.1888895835608475E-03(# 45) ||g||=.80E-02(# 45);    0.000 s

 ************* Run Complete, status =   0.


 function # 9

  [Prnt] pt   0; f=  24.20000000000000    (#  1) ||g||=.23E+03(#  1);    0.000 s
  [Prnt] pt  44; f= 0.2146041211599826E-07(# 63) ||g||=.15E-02(# 63);    0.000 s

 ************* Run Complete, status =   0.


 function #10

  [Prnt] pt   0; f= -2.860065561048750    (#  1) ||g||=.84E+00(#  1);    0.000 s
  [Prnt] pt  12; f= -2.999999998873182    (# 20) ||g||=.50E-04(# 20);    0.000 s

 ************* Run Complete, status =   0.

1 beginning run # 6: analytic mode, reverse calls; meth= QN.

 function # 1

  [Prnt] pt   0; f=  41.68169586167801    (#  1) ||g||=.85E+02(#  1);    0.000 s
  [Prnt] pt   9; f= 0.9979563513253990E-02(# 10) ||g||=.46E-02(# 10);    0.000 s

 ************* Run Complete, status =   0.


 function # 2

  [Prnt] pt   0; f= 0.7790700756559702    (#  1) ||g||=.26E+01(#  1);    0.000 s
  [Prnt] pt  43; f= 0.5655650634086444E-02(# 46) ||g||=.10E-03(# 46);    0.000 s

 ************* Run Complete, status =   0.


 function # 3

  [Prnt] pt   0; f=  1031.153810609398    (#  1) ||g||=.15E+03(#  1);    0.000 s
  [Prnt] pt  18; f= 0.1155940389680368E-03(# 23) ||g||=.46E-03(# 23);    0.000 s

 ************* Run Complete, status =   0.


 function # 4

  [Prnt] pt   0; f=  2.266182511289055    (#  1) ||g||=.12E+02(#  1);    0.000 s
  [Prnt] pt  37; f= 0.2598111368328460E-06(# 39) ||g||=.66E-04(# 39);    0.000 s

 ************* Run Complete, status =   0.


 function # 5

  [Prnt] pt   0; f=  629.0000000000000    (#  1) ||g||=.46E+03(#  1);    0.000 s
  [Prnt] pt  26; f= 0.1268884276519305E-11(# 30) ||g||=.10E-03(# 30);    0.000 s

 ************* Run Complete, status =   0.


 function # 6

  [Prnt] pt   0; f=  148032.5653500000    (#  1) ||g||=.30E+05(#  1);    0.000 s
  [Prnt] pt  19; f= 0.7446886540286594E-04(# 20) ||g||=.29E-04(# 20);    0.000 s

 ************* Run Complete, status =   0.


 function # 7

  [Prnt] pt   0; f=  162.6526819887061    (#  1) ||g||=.50E+03(#  1);    0.000 s
  [Prnt] pt  18; f= 0.1947559660561768E-03(# 24) ||g||=.13E-04(# 24);    0.000 s

 ************* Run Complete, status =   0.


 function # 8

  [Prnt] pt   0; f=  2150.000000000000    (#  1) ||g||=.15E+04(#  1);    0.000 s
  [Prnt] pt  35; f= 0.1830050294747058E-05(# 36) ||g||=.79E-03(# 36);    0.040 s

 ************* Run Complete, status =   0.


 function # 9

  [Prnt] pt   0; f=  24.20000000000000    (#  1) ||g||=.23E+03(#  1);    0.000 s
  [Prnt] pt  35; f= 0.3316606905652118E-10(# 43) ||g||=.26E-03(# 43);    0.000 s

 ************* Run Complete, status =   0.


 function #10

  [Prnt] pt   0; f= -2.860065561048750    (#  1) ||g||=.84E+00(#  1);    0.020 s
  [Prnt] pt  13; f= -2.999999999962793    (# 18) ||g||=.35E-04(# 18);    0.020 s

 ************* Run Complete, status =   0.

1 beginning run # 7: analytic mode, forward calls, meth= Available, Nocedal ups.

 function # 1

  [Prnt] pt   0; f=  41.68169586167801    (#  1) ||g||=.85E+02(#  1);    0.000 s
  [Prnt] pt  10; f= 0.9977313147861875E-02(# 11) ||g||=.33E-02(# 11);    0.000 s

 ************* Run Complete, status =   0.


 function # 2

  [Prnt] pt   0; f= 0.7790700756559702    (#  1) ||g||=.26E+01(#  1);    0.000 s
  [Prnt] pt  45; f= 0.5689689075421895E-02(# 59) ||g||=.36E-02(# 59);    0.080 s

 ************* Run Complete, status =   0.


 function # 3

  [Prnt] pt   0; f=  1031.153810609398    (#  1) ||g||=.15E+03(#  1);    0.000 s
  [Prnt] pt  18; f= 0.1026354148996728E-03(# 25) ||g||=.43E-03(# 25);    0.000 s

 ************* Run Complete, status =   0.


 function # 4

  [Prnt] pt   0; f=  2.266182511289055    (#  1) ||g||=.12E+02(#  1);    0.000 s
  [Prnt] pt  40; f= 0.1673668524595292E-06(# 46) ||g||=.44E-04(# 46);    0.020 s

 ************* Run Complete, status =   0.


 function # 5

  [Prnt] pt   0; f=  629.0000000000000    (#  1) ||g||=.46E+03(#  1);    0.000 s
  [Prnt] pt  38; f= 0.4834610081576529E-03(# 51) ||g||=.43E-01(# 51);    0.040 s

 ************* Run Complete, status =   0.


 function # 6

  [Prnt] pt   0; f=  148032.5653500000    (#  1) ||g||=.30E+05(#  1);    0.000 s
  [Prnt] pt  19; f= 0.7446694567243586E-04(# 20) ||g||=.29E-04(# 20);    0.000 s

 ************* Run Complete, status =   0.


 function # 7

  [Prnt] pt   0; f=  162.6526819887061    (#  1) ||g||=.50E+03(#  1);    0.000 s
  [Prnt] pt  18; f= 0.1947769195679623E-03(# 24) ||g||=.60E-05(# 24);    0.000 s

 ************* Run Complete, status =   0.


 function # 8

  [Prnt] pt   0; f=  2150.000000000000    (#  1) ||g||=.15E+04(#  1);    0.000 s
  [Prnt] pt  73; f= 0.1977415180254950E-04(# 95) ||g||=.11E-02(# 95);    0.000 s

 ************* Run Complete, status =   0.


 function # 9

  [Prnt] pt   0; f=  24.20000000000000    (#  1) ||g||=.23E+03(#  1);    0.000 s
  [Prnt] pt  39; f= 0.1112474255870166E-09(# 57) ||g||=.77E-04(# 57);    0.000 s

 ************* Run Complete, status =   0.


 function #10

  [Prnt] pt   0; f= -2.860065561048750    (#  1) ||g||=.84E+00(#  1);    0.000 s
  [Prnt] pt  10; f= -2.999999933497466    (# 18) ||g||=.50E-03(# 18);    0.020 s

 ************* Run Complete, status =   0.

1 beginning run # 8: analytic mode, forward calls; meth= Available, big n.

 function #11

  [Prnt] pt   0; f=  26875.00000000000    (#  1) ||g||=.51E+04(#  1);    0.000 s
  [Prnt] pt  39; f= 0.1826181873108587E-04(# 40) ||g||=.10E-02(# 40);    0.040 s

 ************* Run Complete, status =   0.

1 beginning run # 9: analytic mode, forward calls; meth= Dynamic,   big n.

 function #11

  [Prnt] pt   0; f=  26875.00000000000    (#  1) ||g||=.51E+04(#  1);    0.000 s
  [Prnt] pt  20; f= 0.2851056588268701E-05(# 37) ||g||=.19E-03(# 37);    0.060 s

 ************* Run Complete, status =   0.

1 beginning run #10: analytic mode, forward calls; meth= Dynamic, big expense,n.

 function #11

  [Prnt] pt   0; f=  26875.00000000000    (#  1) ||g||=.51E+04(#  1);    0.280 s
  [Prnt] pt  20; f= 0.2851056588268701E-05(# 37) ||g||=.19E-03(# 37);   10.560 s

 ************* Run Complete, status =   0.



 rn its funct. value fns | rn its funct. value fns | rn its funct. value fns
 ------------------------|-------------------------|------------------------
  1   9 0.997956E-02  10 |  2  43 0.565565E-02  46 |  3  18 0.115594E-03  23
  4  37 0.259811E-06  39 |  5  26 0.126888E-11  30 |  6  19 0.744689E-04  20
  7  18 0.194756E-03  24 |  8  35 0.183005E-05  36 |  9  35 0.331661E-10  43
 10  13 -.300000E+01  18 | 11   9 0.997956E-02  10 | 12  43 0.565565E-02  46
 13  18 0.115594E-03  23 | 14  37 0.259811E-06  39 | 15  26 0.126888E-11  30
 16  19 0.744689E-04  20 | 17  18 0.194756E-03  24 | 18  35 0.183005E-05  36
 19  35 0.331661E-10  43 | 20  13 -.300000E+01  18 | 21   9 0.997956E-02  10
 22  43 0.565565E-02  46 | 23  18 0.115594E-03  23 | 24  37 0.259806E-06  39
 25  26 0.735050E-10  30 | 26  19 0.744690E-04  20 | 27  18 0.194756E-03  24
 28  35 0.184527E-05  36 | 29  35 0.516158E-10  43 | 30  13 -.300000E+01  18
 31   9 0.997956E-02  10 | 32  43 0.565565E-02  46 | 33  18 0.115594E-03  23
 34  37 0.259811E-06  39 | 35  26 0.126888E-11  30 | 36  19 0.744689E-04  20
 37  18 0.194756E-03  24 | 38  35 0.183005E-05  36 | 39  35 0.331661E-10  43
 40  13 -.300000E+01  18 | 41   8 0.997905E-02   9 | 42  62 0.144903E-01  82
 43  18 0.122466E-03  25 | 44  24 0.188517E-05  31 | 45  27 0.752186E-04  36
 46  19 0.744669E-04  20 | 47  16 0.194818E-03  21 | 48  32 0.188890E-03  45
 49  44 0.214604E-07  63 | 50  12 -.300000E+01  20 | 51   9 0.997956E-02  10
 52  43 0.565565E-02  46 | 53  18 0.115594E-03  23 | 54  37 0.259811E-06  39
 55  26 0.126888E-11  30 | 56  19 0.744689E-04  20 | 57  18 0.194756E-03  24
 58  35 0.183005E-05  36 | 59  35 0.331661E-10  43 | 60  13 -.300000E+01  18
 61  10 0.997731E-02  11 | 62  45 0.568969E-02  59 | 63  18 0.102635E-03  25
 64  40 0.167367E-06  46 | 65  38 0.483461E-03  51 | 66  19 0.744669E-04  20
 67  18 0.194777E-03  24 | 68  73 0.197742E-04  95 | 69  39 0.111247E-09  57
 70  10 -.300000E+01  18 | 71  39 0.182618E-04  40 | 72  20 0.285106E-05  37
 73  20 0.285106E-05  37 |


 *****Test Finished****   problems done  73; number of errors is  0.
                total function calls = 2317 total iterations = 1916


 time taken was      131.840 seconds.
 test ended at  1:30 p.m., Monday, August 30, 1993
! <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> example.out
  [Prnt] pt   0; f=  24.20000000000000    (#  1) ||g||=.23E+03(#  1);    0.000 s
  [Prnt] pt  10; f=  1.866316831898981    (# 15) ||g||=.27E+01(# 15);    0.000 s
  [Prnt] pt  20; f= 0.4875838224001645    (# 32) ||g||=.12E+01(# 32);    0.000 s
  [Prnt] pt  30; f= 0.1136216817825097E-03(# 51) ||g||=.47E+00(# 51);    0.000 s
  [Prnt] pt  36; f= 0.2005359678709316E-08(# 59) ||g||=.69E-03(# 59);    0.000 s
 Least function value:         2.0053596787093158E-09 .
 Function evaluation count:  59 .
 Iteration count:            36 .
! <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> cputime.c

#include <sys/time.h>
#include <sys/resource.h>

double cputime_()
{
  struct rusage buffer;
  if (getrusage(RUSAGE_SELF,&buffer))
    return 0.0;
  return buffer.ru_utime.tv_sec + buffer.ru_utime.tv_usec*1.0e-6;
}
! <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> min.doc
! GENERAL COMMENTS.
!
!  The calling sequence is described below.  The purpose of the
!  algorithm is to find an estimate of a local minimum of a given
!  nonlinear function  f  of  n  real variables  x(1),...,x(n).
!  The program uses one of two methods:  a  matrix storage quasi-Newton
!  algorithm or a variable storage vector based algorithm (for which
!  there are 3 options).  This code was developed for problems with
!  moderate to very large n (using the variable storage technique),
!  but it will usually also work very well for small n.

!  The program contains an extension of the routine  CONMIN  published
!  earlier by Shanno and Phua (see TOMS, Dec 1980, Vol. 6, No. 4 ).
!  The matrix based quasi-Newton part of our code is very similar to
!  the quasi-Newton part of CONMIN.

!  One option for the variable storage method is described in the paper
!  "QN-like Variable Storage Conjugate Gradients" by Buckley and LeNir,
!  which has appeared in Mathematical Programming (1983, Vol. 27, pp.
!  155-175). An earlier version of the code was published as Algorithm 630
!  (ACM TOMS, 1985, Vol. 11, No. 2, pp. 103-119) and revised substantially
!  in a subsequent "Remark on Algorithm 630" (ACM TOMS, 1989, Vol. 15,
!  No. 3, pp. 262-274).  The current algorithm is described in "Conversion
!  to Fortran 90: A Case Study", ACM TOMS, 1993.

!  The program also includes implementations of two other methods: the
!  product form updating of Nocedal (Mathematics of Computation, 1980,
!  Vol. 35, No. 151,  pp. 773-782) and a limited memory variation of a
!  factored updating algorithm ("Updating Conjugate Directions by the BFGS
!  Formula with Variable Storage", A. Lee, M.Sc. thesis, University of
!  Victoria, 1993) given by Powell (Mathematical Programming, Vol. 38, No. 1,
!  pp. 29-46).  These may be chosen as options by the user.
!
!  For complex problems, note that it is possible to redefine the metric
!  of the space in which the minimization takes place. See the discussion
!  of Inner Products below.
!
! Algorithm Description.
!
!  Here we describe those details which will aid in understanding
!  subsequent comments.  Further details should be obtained from
!  the papers. The conjugate gradient part of the Buckley-LeNir code
!  will be primarily discussed here as it is the original contribution.
!
!  Throughout this documentation, the notation `thing[i]' will denote
!  the status of the entity `thing' at iteration i.
!
!  The algorithm starts from an initial point  x[0], which must be
!  given.  The initial search proceeds along a direction  d[1] to
!  x[1].  We refer to  d[1] as a restart direction, and to x[1] as a
!  restart point.  The algorithm is in two parts: a quasi-Newton
!  part and a conjugate gradient part.  Let  x[r]  denote a restart
!  point (of which the first is x[1]).  At a restart point, a quasi-
!  Newton update is calculated, say H[1], which is an update of H[0]
!  (normally the identity), and the current point is relabelled as
!  x[1] (if it isn't already).  The update matrix is saved, by storing
!  some (1 to 4) vectors and some (2 to 3) scalars, or by storing the updated
!  quasi-Newton matrix.  The point  x[r]  marks the start of the quasi-
!  Newton part.
!
!  At each subsequent point x[2], x[3],..., a new update is formed,
!  namely  H[2], H[3],..., and a new search direction is formed as
!  d[i+1] = - H[i]*g[i].  Each update matrix  H[i] is defined as an
!  update of the previous matrix  H[i-1] and H[i] is saved by stor-
!  ing additional vectors and scalars, or by updating the quasi-Newton
!  matrix.  In the limited memory cases, when the update terms which
!  have been stored have used all of the storage which is available,
!  we end the quasi-Newton part. Thus the quasi-Newton part extends
!  from  x[1]  to  x[m+1], assuming that there is room for  m  update
!  terms.  Upon reaching  x[m+1], we switch to the conjugate gradient
!  (CG)  part.
!
!  In this description, for simplicity, `H' will denote the update matrix
!  defined when the current point is reached; `H^' will denote the update
!  matrix to be computed and used in forming the next search
!  direction.  The matrix H must be updated to H^.
!
!  Note that in the Nocedal option using product form updates, there
!  is no conjugate gradient part.  There are no restarts either.
!  The method is basically a quasi-Newton strategy, which is described
!  fully by Nocedal. Here we just note that all steps are quasi-Newton
!  steps, and it is the manner in which the updates are made which is
!  different. Also note that only 2 vectors and 1 scalar are stored
!  for each update. There is still a limit  m  on the number of update
!  terms which can be stored.
!
!  The CG part continues in much the same way as the QN part, with
!  directions d[i+1] = -H[i]*g[i].  The difference is that at each step,
!  the update matrix  H[i]  (for i > m) is defined as an update of
!  H[m], but  H[i]  is neither stored nor explicitly calculated.
!  Whether one is in the  quasi-Newton part or conjugate gradient
!  part also may have ramifications in the strategy employed in the
!  line search.  This is explained in the  Mathematical Programming
!  paper by Buckley and LeNir and in the code.
!
!  The CG part continues until it is decided to do a restart.
!  Suppose that we have just completed the line search to reach
!  a point  x[i].  In certain circumstances, which are explained
!  in the paper and below, we will declare  x[i]  to be a restart
!  point, in which case we will refer to it as  x[r], and in fact
!  we will relabel it as  x[1].  The step leading to  x[r]  will
!  be referred to as a restart step.  Note that the initial step
!  from  x[0] along  d[1] is the first restart step, and  x[1]
!  is the first restart point.  Upon declaring  x[r] to be a
!  restart point, we declare the CG part ended, relabel x[r] as x[1],
!  and we start the QN part again from x[1].
!
!  In the implementation of the factored updates, as described by
!  Powell, the strategy is much the same. What differs is the means
!  by which each update H[i] is stored, and the amount of data needed
!  to record each update.
!
! ----------------
! CALLING SEQUENCE.     The section "Reverse Communication" below
! ----------------      explains some extensions to the call.
!
!                       There are also many optional arguments, which
!                       are also explained later.  References to these
!                       are indicated as [OA].
!
!                       The user may wish to read the section on
!                       named literal constants below to clarify
!                       some of the discussion.
!
!                       Changing the metric of the minimization space is
!                       *not* done through an argument, as is the section
!                       on inner products below.
!
!
!    CALL
!    ------------------------------------------------------------
!    Minimize_f ( F, x, fx, g, Accuracy, State, Memory, C, ...
!    ------------------------------------------------------------
!
!--Module required:
!
!       In order to access Minimize_f, a program must include
!       the statement
!                       USE Minimize
!
!       This will also provide: the definition of the type for the
!       state vector C described below (through the use of the module
!       SystemState); the definitions of the two standard status codes
!       Normal  and  Done; and the definitions of the precision parameters
!       stnd, long, short  and  extd.
!
!--Declarations:
!
!       In Minimize_f, the non-optional arguments are declared as follows:
!
!           Real (stnd),           intent(INOUT)         :: fx,            &
!                                                           x (:),         &
!                                                           g (size(x))
!           Real (stnd),           intent(IN)            :: Accuracy
!           Integer (short),       intent(INOUT)         :: State
!           Integer (long),        intent(IN)            :: Memory
!           Type  (MinimizeState), intent(INOUT), TARGET :: C
!
!--On entry:
!
!    F       The name of the evaluation subroutine which defines
!            the function to be minimized. A subroutine to evaluate
!            the function must be provided and it must either be
!            declared as EXTERNAL in the calling routine or it must
!            be in a module which is accessible to the calling routine.
!            F must have the calling sequence defined by
!
!               Interface
!                   Subroutine F ( x, fx, g, job )
!                       Real(stnd), intent(IN)         :: x(:)
!                       Real(stnd), intent(OUT)        :: fx, g(size(x))
!                       Integer(short), intent(INOUT)  :: job
!                   end Subroutine
!               end Interface
!
!            Here x, fx and g mean the same as they do in the call
!            to Minimize_f.
!
!            On entry to F, job will have one of the values
!            JustF, JustG, Both or NoOp, as described in the
!            module Supp_Codes. F should perform accordingly.
!
!            On exit, job must be set to one of OK, Abort, NoF,
!            NoG or NoForG, as described in the module Supp_Codes.
!
!    x       A vector of length  *exactly*  n  which contains an
!            initial guess at the minimum.  Thus on entry  x
!            is the vector referred to as  x[0].  There is no
!            restriction on the values of the components of  x,
!            but the closer the guess is to a local minimum, the
!            more rapid the convergence will usually be.  The number
!            of elements of x must be exactly n, the dimension of the
!            problem. If the declared size of x in the calling routine
!            is greater than the current value of n, then the call to
!            Minimize_f should have arguments (F,x(1:n),fx,g(1:n),...)
!
!    fx, g   These may be required on input, according to the
!            value of State, below. The vector g must have the
!            same length on entry as x or be of greater size. Normally,
!            no values are required on entry.
!
!    Accuracy This specifies the accuracy desired in the final estimate
!            of the minimum. The default is to terminate when
!
!                               ||g||    <= Accuracy
!            and              ||x - xp|| <= Accuracy * max(1,||x||)
!
!            Here x is the current point and xp denotes the previous iterate.
!            See  Test_Done  for more information, as well as some of the
!            optional arguments; there are other termination criteria
!            possible, and it can be made relative to initial values.
!
!    State   This is a code to indicate the routine's status on entry
!            and exit.  The code is a named literal integer constant,
!            as defined in the module Min_Codes.
!
!            On entry, we have:
!
!         Normal  An "ordinary" call. Minimize the function and
!                 call Evaluate_f when function and/or gradient
!                 values are required.
!         NormalWithFG  This is just like the case State=Normal,
!                 except that it indicates that, upon entry,
!                 the function and gradient values at the initial
!                 point x are already available in fx and g.
!         RevCommStart  This is an initial call indicating that
!                 reverse communication is to be used; see the discussion
!                 of reverse communication below.
!         RevCommReStart   This is a secondary call with reverse
!                 communication; continue the computation.
!         RevCommNoF  This is also a secondary call with reverse
!                 communication, but it indicates that the main
!                 routine was unable to provide the desired function
!                 value.
!         RevCommNoG     Like RevCommNoF, but no gradient value.
!         RevCommNoForG  Like RevCommNoF, but neither value.
!         Resume  This is used to indicate the continuation of an
!                 aborted run; see the discussion below on checkpoints.
!
!    Memory  The user may specify the maximum amount of memory to
!            be used. If 0 is specified, the algorithm will only be
!            limited by the amount of memory which the operating system
!            will allocate. This is often not a good way to proceed.
!            The exact effect of this argument will depend on the
!            setting of  Method [OA]. The description
!            there should be read carefully, especially if n is large.
!
!    C       This is a state record: all non-local variables used in
!            the minimization process are stored here. Some of these may
!            be of interest after completion of a minimization. These
!            values are described below. No values need to be set in C
!            before entry to Minimize_f.
!
!    Optional Arguments: These are described below.
!
!--Upon exit:
!
!    x       The final estimate of the minimum which was found,
!            provided that State is `Done'. If State is not Done,
!            the values in x, fx and g  may be unreliable. Otherwise,
!            x contains the approximation to the minimum which the
!            routine has determined is within the specified accuracy.
!
!    fx      The function value at the final estimate  x (provided
!            State = Done).
!
!    g       The gradient value at the final estimate  x (provided
!            State = Done).
!
!    State    An integer code defining the current status of the routine.
!          If State = Done, you may be quite confident that the vector x
!          does indeed represent a good approximation to a local minimum
!          of the function.
!
!          = Done          Normal termination: an accurate solution appears to
!                          have been found.
!          = RevCommF      These are used for reverse communication; see below.
!          = RevCommG
!          = RevCommFandG
!          = StorageError  Execution was terminated because there was
!                          insufficient storage allocated.  See Method [OA].
!          = InitialMin    The initial x was a critical point. No further
!                          computation was attempted.
!          = InitialUndefd The function or gradient value of the initial point x
!                          was undefined.  No further computation was attempted.
!          = BadInput      Execution never began because some error was
!                          detected in the values of the arguments passed
!                          to the routine.  See the error vector in the
!                          state record C below.
!          = LsFail        The line search failed.  This is probably because
!                          too high an accuracy requirement was given for the
!                          machine in use, or because the function and/or
!                          gradient evaluations are incorrectly coded. This
!                          exit is more likely when finite differences
!                          are being used to calculate derivatives.
!          = NoDescent     A non-descent search direction was generated. This
!                          can only be due to roundoff and the cause is
!                          possibly the same as for State = LsFail.
!          = ExcessFEvals  Execution halted when more than the allowed number
!                          of function evaluations was attempted.
!                          See  EvalLimit [OA].
!          = InvalidM      The invalid combination of no stored update terms
!                          with Nocedal's method was attempted.
!          = AbortMin      An abort was requested by the function evaluation
!                          routine.
!
!--Reverse Communication:
!
!      In some applications it may not be appropriate to obtain function
!      values by calling the routine Evaluate_f.  (This is much less likely
!      with Fortran 90 than it was with Fortran 77.)  In such a case, an
!      alternative is to use reverse communication.  The arguments to
!      Minimize_f have the same meanings as above, with the following
!      modifications.
!
!      1. On the initial call to Minimize_f, State must be set to
!         RevCommStart, and fx  and  g must contain the value of the
!         function and gradient at the point  x  which is specified
!         as the starting point for the minimization.  If the user
!         calls Evaluate_f to obtain the function/gradient values, then
!         some initialization is necessary. In particular, using the
!         module Supp_Defs, before calling Evaluate_f, one must execute
!         the statement
!
!                        C%Eval    = DefaultEvalState
!
!         Also note that the optional argument  first  of Evaluate_f must
!         be present and true on the first call to Evaluate_f each time a
!         new problem is begun.  On subsequent calls to Evaluate_f  first
!         must be false.
!
!      2. When  Minimize_f requires further function and gradient values,
!         it will return to the calling program with
!
!           State = RevCommF, RevCommG or RevCommFandG
!
!         and with  x  containing a set of  n coordinates.  In this case,
!         the calling program must obtain the value of the function
!         and/or the gradient (as indicated by the value of State) at the
!         specified point  x, and then call Minimize_f again with these
!         values in fx and g.  None of the other arguments must be altered
!         except that  State must to set to
!
!           RevCommReStart  Continue with minimization
!           RevCommNoF      Could not compute fx
!           RevCommNoG      Could not compute g at x
!           RevCommNoForG   Could not compute fx or g at x
!
!         before calling Minimize_f again.
!
!         Note that, even if fx and/or g could not be computed, one should
!         still reenter Minimize_f, as it may still be possible to find a
!         minimum.
!
!      3. Execution of Minimize_f will terminate as usual, and any value
!         of State other than those noted in point 1 or point 2 must be
!         taken as a signal to quit.
!
!--I/O.
!
!     Input:
!
!        There is no input required.  All information needed by the
!        routine is taken from the calling sequence.
!
!     Output:
!
!        The current version is set up to print the initial guess
!        x[0]  and the solution.  All output is on unit 6 by default.
!
!        If it is desired, this output may be deleted or more
!        extensive output may be obtained. See the optional arguments.
!
!--Optional Arguments
!  ------------------
!
!  There are a large number of optional arguments to this routine.
!  These are now described, although some will be explained more fully
!  elsewhere. For a fuller description, see the specific routine
!  referenced in [ ].
!
!  Each of these has a default value. These values are set in the
!  modules Min_Defaults and Supp_Defs and may be determined
!  by consulting those modules.
!
!  In the following description,  `+' denotes that the argument must
!  be positive, and `0+' indicates a value which must be 0 or positive.
!  Real means of type `real(stnd)', Long means type `integer(long)' and
!  Short means `integer(short)'.
!
!   Optional arguments most commonly changed:
!   ----------------------------------------
!
!   EvalLimit  Long 0+  Maximum number of function evaluations allowed
!                       [Evaluate_f]. If it is set to 0, no limit is imposed,
!                       a permitted, but inadvisable, choice.
!   Frequency  Long 0+  Interval between iterates for printing intermediate
!                       output [Print_Iterate]. If it is set to 0, all
!                       output is suppressed, including error messages.
!                       If it is non-zero, the first and last points and
!                       error messages are always printed, so use a large
!                       positive value.
!   CheckPoint Long 0+  Interval between iterates for checkpointing the
!                       run [Check_Point]. If it is set to 0, no check-
!                       pointing is done. An interrupted run may be
!                       continued by setting State=Resume and calling
!                       Minimize_f, as described below under Checkpointing.
!   CheckFile           See Checkpointing, below.
!   CheckUnit Short 0+  See Checkpointing, below.
!
!   Method  (also see supplementary comments (*) after the list of options)
!
!               Note that if  n  is of small to moderate size, the
!               default is likely quite acceptable, and neither Method
!               nor Terms need to be specified.
!
!        SD        Use the steepest descent algorithm. No updates need
!                  to be stored, so m = 0.
!        CG        Use the ordinary CG algorithm with preconditioner H0,
!                  implemented with d = -H0*g for all steps. No updates
!                  need to be stored; thus m = 0.
!        ConMin    Use Shanno's 2-step CONMIN algorithm. This means that
!                  one update must be stored, so m = 1.  If this is chosen,
!                  certain parameters will be set to defaults and user-
!                  defined settings ignored.  This includes
!                      DoInterpolation   = Every,
!                      QuadInterpolation = false,
!                      IgnoreInterval    = false,
!                      StartAlpha        = Before2QN.
!        FixTerms  Use a variable memory algorithm with a specified number
!                  of terms to be stored as given by the argument  Terms [OA].
!        Variable  Use a limited memory algorithm with as many update terms
!                  as can fit into the available memory, up to a maximum
!                  specified by the constant  MaxUpdates  in the module
!                  Min_Defaults. The memory available is taken from the
!                  non-optional argument Memory described above, if it is
!                  greater than zero.
!        Available Use the QN algorithm if there is enough storage;
!                  otherwise use a limited memory algorithm with as many
!                  update terms as are possible. In this case, the memory
!                  available is taken from the non-optional argument Memory, if
!                  it is greater than zero.
!                  The algorithm chosen is viewed as a `pure' QN or
!                  `pure' limited memory algorithm, and some of the optional
!                  arguments are set to specific values which override any
!                  given by the user.  In particular,
!                                                   QN Case    Limited Memory
!                      DoInterpolation   is set to  Never      On1,
!                      StartAlpha        is set to  AlwaysQN   Before2QN,
!                      QuadInterpolation is set to  false      true,
!                      IgnoreInterval    is set to  false      false.
!        Dynamic   Use a dynamic strategy. Start with a limited memory
!                  algorithm with a few updates. If performance is poor and
!                  if there is enough memory, try a QN algorithm.  Certain
!                  optional arguments are set as given for Method = Available
!                  and change when the strategy changes.
!        QN        Use the QN algorithm, provided storage is sufficient.
!                  The storage available is taken from the non-optional
!                  argument Memory described above, if it is greater than zero.
!                  This is not viewed as a `pure' QN algorithm as mentioned
!                  above, and any optional arguments set by the user are
!                  taken and applied as given.
!
!      * In all of the methods described above, the amount of `available' memory
!        is determined by the required argument `Memory' (above), if it has
!        been set to a positive value. Otherwise, if Memory is 0 the available
!        memory is limited only by what the operating system will provide.
!        The user should be cautioned that, when the algorithm determines the
!        amount of available memory, it does so by attempting to execute
!       `Allocate' statements. If no error occurs, the allocation is deemed to
!        have succeeded and it is assumed the memory requested is available.
!        On many operating systems, allocation may succeed by the use
!        of virtual memory, a fact which would undoubtedly cause very poor
!        performance for the algorithm if n is large. On such systems,
!        it is highly advisable to specify a value for Memory to control
!        any such problems.  The exact memory requirements are given in the
!        paper "Algorithm 734: A Fortran 90 Code for Unconstrained Nonlinear
!        Minimization", ACM TOMS, 1993.
!
!   Terms      Long 0+   Number of update terms permitted [above].  It is
!                        ignored unless FixTerms has been chosen for Method.
!
!   Derivatives     Mode for computing derivatives [Evaluate_f].
!           = Analytic     calculate gradients from formulae. The user
!                          routine F must be able to do this calculation.
!           = Difference   use finite difference calculations.
!           = CompareTest  find both and compare for accuracy.
!           = FirstTest    compare for accuracy on first evaluation only.
!
!   DecreaseInF Real       Expected reduction in function value.
!       This may be an estimate of the expected decrease in the function
!       value.  If such a value is not known, then this may be set to be
!       negative and it will be ignored.  It can however be very helpful
!       to have an estimate of |f(x[0])-f(x*)|, where x[0] is the initial
!       point and f(x*) is the function value at the minimum x*.  Note that
!       it is often possible to estimate the expected function reduction
!       without knowledge of x*.  In particular, if f(x*) is expected to
!       be 0, then DecreaseInF may be set to zero and f(x[0]) will be
!       used as an estimate of the expected reduction in f.
!
!   SystemMemory  Long 0+   User-set memory limit for allocations [My_Allocate].
!       If SystemMemory is positive, then an upper limit is set on the amount of
!       memory that can be allocated.  This is basically for testing only and
!       is not normally used.
!
!   ExactLS  Logical       Sets up an exact line search.  When this argument
!       is true, the required parameters are set so as to guarantee that
!       an exact line search is conducted.  The only termination criterion
!       used is on ||g||.
!
!   Optional arguments for Evaluate_f   --see Evaluate_F for details
!   ---------------------------------
!
!   ScaleF        Short +   Apply a nonlinear scaling to the function
!                           and hence to the gradient.
!   Expense       Long  +   Artificially inflate the cost of evaluating
!                           the function by a factor of Expense.
!   TraceF        logical   set to trace function evaluations.
!   TraceG        logical   set to trace gradient evaluations.
!   TraceDervTest logical   set to trace derivative test calculations.
!   EvalTraceUnit Short 0+  unit for trace output.
!
!   Optional arguments for Print_Iterate   --see Print_Iterate for details
!   ------------------------------------
!
!   PrintUnit     Short 0+  unit for printing output.
!   PrintGrad     logical   set to print gradients.  See  Frequency [OA].
!   PrintX        logical   set to print point coordinates.
!
!   Optional arguments for Test_Done   --see Test_Done for details
!   --------------------------------
!
!   UseGrad       logical   apply gradient test.
!   UseStep       logical   apply step test.
!   UseShanno     logical   apply Shanno's test.
!   UseFunc       logical   apply function test.
!   TheNorm       literal   norm to use for vectors.
!   TraceTerm     logical   set to trace termination tests.
!   TermTraceUnit Short 0+  unit for trace output.
!
!   RelativeToF0
!            true  This value stipulates that termination tests are to be
!                  relative to the initial function value, where appropriate.
!            false The tests are absolute.
!
!   RelativeToG0
!            true  This value stipulates that termination tests are to be
!                  relative to the initial gradient value, where appropriate.
!            false The tests are absolute.
!
!   Optional arguments for Minimize_f --see modules Min_Codes for named literals
!   ---------------------------------
!     Read the concluding comments if it is desired to do test computations
!     on a quadratic function which require exact line searches on all steps.
!
!     Most of these arguments are of interest only to persons doing detailed
!     studies of the performance of these algorithms.
!
!     DoInterpolation  This determines in what circumstances an interpolation
!           step must be done before a line search can be deemed complete.
!           The fundamental idea is that an interpolation must often be
!           done on line searches in conjugate gradient methods. In effect,
!           this decides what steps to regard as CG steps, at least as far
!           as interpolation is concerned.
!
!           Every: quadratic interpolation forced on every step.
!           On1  : quadratic interpolation forced on d[m+1] and later steps.
!           On2  : quadratic interpolation forced on d[m+2] and later steps.
!           On3  : quadratic interpolation forced on d[m+3] and later steps.
!           Never: quadratic interpolation is never forced.
!
!     QuadInterpolation
!           true   Then the application of DoInterpolation, as described
!                  above, is decided by monitoring whether the part of the
!                  code which does the actual interpolation has
!                  successfully accepted an interpolation point or not.
!           false  Then the strategy used by Shanno in CONMIN is
!                  followed, i.e. any computation of a new second alpha counts,
!                  which may include a non-interpolation step. This
!                  is implemented by simply checking the number of calls,
!                  which is incremented each time the function is evaluated.
!
!     StartAlpha  This determines in what circumstances a line search
!           is begun with the step of length 1, i.e. with alpha = 1,
!           which is normally the strategy for quasi-Newton methods.
!           In effect, this decides what steps to regard as QN steps,
!           at least as far as the initial choice of alpha is concerned.
!
!           NeverQN   alpha = 1 is never used initially.
!           Before1QN alpha = 1 used on steps before d[m+1] (not inclusive)
!           Before2QN alpha = 1 used on steps before d[m+2] (not inclusive)
!           Before3QN alpha = 1 used on steps before d[m+3] (not inclusive)
!           AlwaysQN  alpha = 1 is initial choice on all steps.
!
!     ScaleGamma  The so-called gamma scaling of Oren and Spedicato, which
!           is described by Shanno, may be used at each update step. This
!           can in fact be done only if the BFGS update is being used, i.e.
!           if Beta = 1. No extra storage is needed to implement this scaling.
!
!           = NoGammaScale Then do not use this scaling
!           = GammaFirst   Then use this just on the first QN update.
!           = GammaAll     Then use this for all QN updates.
!
!     HTest This is used to determine how to control when restarts are
!           are done in the CG-QN strategy.
!
!           = NoRestart  Then do not use any restart test.
!           = UseI       Just use Powell's simple test (i.e. H = I )
!           = UseH       Use the restart test which involves the matrix
!                        H as described in the Buckley-LeNir paper.
!
!     UpdateForm This is used to establish what form of matrix updates
!                should be used when a limited memory approach is used.
!
!           = SumForm      Use the sum form of updating, as in Buckley-LeNir.
!           = ProductForm  Use Nocedal's product form.
!           = FactoredForm Use Powell's factored form, as in Lee.
!
!     StartStep This controls the scaling of the conjugate gradient directions,
!               which is reflected in the initial choice of alpha.
!
!           = Fletcher Use the formula given by Fletcher and used in his VA08.
!           = Powell   Then use the formula appearing in CONMIN and
!                      used by Powell in VA14.
!
!     IgnoreInterval  In the cubic interpolation, the generated point must
!               normally lie within a specified interval. In order to
!               override this requirement, set IgnoreInterval to true.
!               This should not normally be done; the one time it is
!               appropriate is when a quadratic function is being
!               minimized, and other parameters are set to guarantee an
!               exact line search. This would only be done for test purposes.
!               See Cubic_Interpolation for more information.
!
!     CountFromRestart
!            true  Then a restart is forced after  n  steps from the
!                  last restart point x[r] (which is x[1], i.e. at x[n+1]).
!            false Then a restart is not forced until  n  steps have
!                  been done from the beginning of the CG part, which is
!                  x[m+1], so the restart is forced at x[m+n+1].
!
!     Rho Real This is the parameter of the same name from the Buckley-LeNir
!              paper which controls the restart test, i.e. if tau[i] > Rho,
!              a restart will be done.
!
!     Beta Real This is the scalar parameter for the Broyden update family.
!              If it is equal to 1, then the BFGS update formula is obtained.
!              Using 0 gives the DFP update.
!
!     SetH0    This controls the form of setting H.
!           = Ident        Use the identity matrix.
!           = Diagonal     Use a diagonal matrix.  Note that this increases
!                          the storage requirement for  H  by  n  locations.
!           = Computed1    Use a special form of matrix (see H0v_Multiply).
!           = Computed2    Use a special form of matrix (see H0v_Multiply).
!           = Computed3    Use a special form of matrix (see H0v_Multiply
!                          and ParH0 [OA]).
!
!     ParH0 Real   This is a parameter used to set H if SetH0 [OA] above has the
!             value Computed3.
!
!     ScaleColumns   If true, scale the matrix columns in Powell's factored
!             form update case.  Otherwise, do not incorporate column scaling.
!
!     Traces  This is a record containing a number of trace flags which can
!             be set to control trace output. The fields are as follows:
!
!         TRunit          The unit (integer, 0+) to receive the trace output.
!         TRlevel         Not to be altered.
!         TRinput         Set to echo input values.
!         TRflow          Set to trace program flow.
!         TRsteptypes     Set to trace types of steps taken.
!         TRlsalpha       Set to watch calculation of step length alpha.
!         TRlsreal        Set to look at reals used to find alpha.
!         TRlsflow        Set to watch line search flow.
!         TRupdate        Set to see update calculations.
!         TRvalues        Set to watch various calculations.
!         TRvectors       Set to print out vectors; otherwise scalars only.
!         TRXandD         Set to watch points and search directions.
!         TRcubic         Set to trace cubic interpolation process.
!
!   Quadratic minimization:
!
!       There are instances, especially for test purposes, where it is desired
!       to minimize a quadratic function, and to ensure that each line search
!       is exact.  The normal line search strategy will not ensure this, since
!       that is well known to often impede progress on non-quadratic functions.
!       If this behaviour is however desired, it may be achieved by setting
!       optional arguments appropriately.
!
!       First, the method must NOT be Available, Dynamic or Variable. In those
!       cases, the algorithm automatically selects certain appropriate settings.
!       The user must therefore indicate explicitly what method is to be chosen,
!       i.e. SD, CG, ConMin, FixTerms or QN.
!
!       Optional arguments must then be set to ensure that a correct quadratic
!       interpolation is guaranteed to be done on every iteration. This
!       is achieved with
!
!           DoInterpolation   = Every
!           StartAlpha        = AlwaysQN
!           QuadInterpolation = true
!           IgnoreInterval    = true
!           UseGrad           = true
!           UseFunc           = false
!           UseStep           = false
!           UseShanno         = false
!
!---Checkpoints:
!
!       In order to accomodate the risk of a machine failure during a
!       particularly long computation, the routine has the option available
!       to check point the computation. There are three relevant optional
!       arguments:
!
!       CheckPoint      This defines the interval at which to write check
!                       point information to an output file. If Checkpoint
!                       = k, then after each iteration k, 2k, 3k, ... is
!                       complete, enough information is written to an
!                       output file to be able to continue the computation
!                       from that point. If a value of 0 is given, or if
!                       this argument is not present, no checkpoint data
!                       is written.
!       CheckFile       This names the file onto which to write the data.
!                       Actually, two files are used, alternately. The first
!                       has 'a' appended to the name given; the second has
!                       'b' appended. This is to avoid a disaster if a
!                       crash occurred during writing of the checkpoint data.
!                       A default name is used if this argument is not
!                       present; see the module Minimize.
!       CheckUnit       The unit number for writing the data. A default is
!                       used if this argument is not present.
!
!       In order to resume an interrupted computation, Minimize_f should be
!       called with State = Resume.  In this case, the argument CheckFile
!       *must* be present, and it must give the full file name (including
!       the trailing 'a' or 'b') from which to read the data before proceeding.
!       In this case, the user must decide from what point to continue the
!       computation by selecting the appropriate file.  The unit number to
!       use may be specified in the argument CheckUnit. It is possible that
!       an attempt to resume computation may fail. The two possible reasons are
!       1) occurrence of an error in reading the checkpoint file; or 2) failure
!       to allocate the required memory.  The first is likely to result from
!       incorrect specification of the file name, although it should be noted
!       that if an attempt to open the named file fails, an attempt will be made
!       to open the alternate file (i.e. with the trailing 'a' replaced by 'b',
!       or vice-versa).  The second may happen because less memory is available
!       at this time than when the calculation was previously attempted. There
!       is no way to correct this, other than to try again. The routine will
!       always attempt to reallocate any memory allocated during the aborted
!       run.
!
!       No other arguments need be, or should be, set. If they are, their values
!       will simply be ignored, and overwritten by the restored data.
!
!---Fields in C
!
!       The status record  C  contains a complete record of the state of
!       the computation at any time. Here we just list those fields which
!       may be of interest to a user after completion of an optimization.
!
! short C%Shared% Error(0:NumErrs) Here ne = Error(0) contains the number of
!                       errors found in the arguments passed to the routine.
!                       The actual error codes are in Error(1),...,Error(ne).
!
! long  C%Shared% RestartCt  A count of all the restarts.
! long  C%Shared% ForceCt    A count of the restarts forced after n steps.
! long  C%Shared% ct         A count of the iterations from the last restart.
!                            the restart point is indexed as number 1.
! long  C%Shared% it         A count of all the iterations.
!
! long  C%EvalCts% FEvals    The number of points at which the function
!                            value was computed.
! long  C%EvalCts% GEvals    The number of points at which the gradient
!                            value was computed (or estimated).
! real  C%EvalCts% time      The time spent in the computation of the
!                            function and/or gradient values.
!
! real  C%EvalErs% Worst     See Evaluate_f for more explanation of the next
!                            four values. The first is the worst error
!                            encountered in estimation of the finite
!                            difference derivatives.
! real  C%EvalErs% Average  This is the average error.
! long  C%EvalErs% Gradcnt  This is the value of GEvals at the time when the
!                           worst error was encountered.
! long  C%EvalErs% Index    This was the index of the component of the
!                           gradient for which the worst error was found.
!
! real  C%PrVals% time      This was the time spent in the routine for
!                           printing iterates.
!
!---Inner Products
!
!       It is possible that for some particularly sophisticated problems,
!       it is desirable to work in a space other than that defined by the
!       usual Euclidean metric on Rn.  This is easily accomodated by this
!       algorithm, using the facilities of Fortran 90.  There is a module
!       called Inner_Product, which contains 5 routines, each invoked by
!       an appropriate user defined operator.  The details are described
!       in the introductory section to that module and will not be repeated
!       here.  To summarize however, there is an operator .IP. defined
!       for the normal inner product <x,y> = x'*y, where x' means the
!       transpose of x.  The code uses a second inner product .GIP. in
!       all places where it is appropriate to change the metric of the
!       space where the optimization takes place. The default is that .GIP.
!       is identical to .IP.  The user however is free to redefine .GIP.
!       Of course, there are corresponding norms defined, namely .Norm. and
!       .GNorm.
!
!---Implementation Notes.
!
!     1. When developing this code, it was found useful to include
!        some ability to trace parts of the code with some appropriate
!        output.  This is still in the code, but it is turned off. To
!        turn it on, set all or some of the trace parameters in  the
!        optional arguments.
!
!     2. The code contains a number of decision variables. These have a
!        definite effect on the execution of the code and were used for
!        the experimental testing documented in the paper describing the
!        algorithm. It could be suggested that these should be removed
!        for a publication version, and to some extent I would agree
!        with that.  However, I have not removed them, and I would like
!        to give the following justification:
!
!        (a) Since the code requires O(mn) or O(n^2) operations for
!        each iteration, the removal of a few logical decisions would
!        have a negligible effect on the execution speed.
!
!        (b) The user need not be concerned with any of the possible
!        choices, for default values are provided for all of them.
!
!        (c) Some people might choose to experiment with the code,
!        and that would be greatly facilitated by leaving it as it is.
!
!     3. Where the effect on execution speed is not likely to be
!        significant, I have often opted for coding in a fashion
!        which gives the greatest clarity to the code, rather than
!        seeking the slickest or quickest way.  For example, the use
!        of some logical variables could easily be eliminated, but I
!        think the code as it is is quite clear.  Also note that with
!        an optimizing compiler, writing the code as it is should have
!        no effect at all on execution speed. Finally, note that the
!        trace referred to above will also have little effect on execution
!        speed as long as it is turned off.
!
!     4. The routines Print_Iterate, Test_Done and Evaluate_f are not
!        central to the minimization process. They perform certain useful
!        auxiliary tasks, and have certain facilities which some
!        users may wish to take advantage of.  There is some price
!        to having these separate routines, but it is again small
!        compared to the overall computation. they can easily be
!        removed if that is felt to be essential.
!
!     5. The routine has been significantly restructured to use the
!        facilities of Fortran 90, especially Modules.  See the paper
!        on conversion to Fortran 90.
!
!---Named literal constants:
!
!       In order to be able to write meaningful code such as
!
!           if ( Derivative == Analytic ) then ...,
!
!       rather than the much less obvious
!
!           if ( Derivative == 1 ) then ...,
!
!       the code uses named literal constants whenever a small set of
!       integer values, e.g. 1, 2, 3, 4, would do.
!
!       These values are defined in Modules and are accessible to
!       the user.  The two main modules where these are defined
!       are Min_Codes and Supp_Codes. In all of the documentation
!       for this routine, the named literal values are used. The
!       user should access these modules with an appropriate USE statement
!       and should use them as named. Nothing will be gained by
!       attempting to use the actual integer values. If there are
!       name conflicts, these may be resolved using the renaming
!       capability of the USE statement.
!
!       The modules Min_Codes and Supp_Codes each contain a number of
!       character functions that return the character string equivalent of
!       a specified integer code.  For example, the function call
!       Str_Method(1) would yield the result 'CG', since the named literal
!       constant CG is assigned the value 1.
!
! End of documentation
! <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> true_false.f90
MODULE True_False       ! some convenient true false abbreviations

                         Implicit NONE
    PUBLIC
    !-----               -------------!

    Logical, PARAMETER  ::                      &
                                true  = .true., &
                                false = .false.

end Module True_False
! <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> low.f90
MODULE  Low  ! precision specification for real computations

    PUBLIC :: stnd, extd

    ! This requests the processor to use a real implementation 'stnd'
    ! which provides at least 6 decimal digits of precision and an
    ! exponent range of at least 10 ^ +- 35.  This would be suitable for
    ! low accuracy computations.  It is expected that this precision will
    ! be available on all machines.

    Integer, PARAMETER :: stnd = Selected_Real_Kind ( 6, 35 )
    !-------------------------

    ! A few computations are preferably done in higher precision 'extd'. The
    ! numbers chosen here should be such that the underlying hardware will
    ! select a higher precision for kind 'extd' than for kind 'stnd', if
    ! this is feasible.  If a higher precision is not readily available,
    ! the same values may be used as are given above for 'stnd'. It is
    ! anticipated that on most machines this higher precision will also
    ! be available.

    Integer, PARAMETER :: extd = Selected_Real_Kind ( 12, 35 )
    !-------------------------

end Module Low
! <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> normal.f90
MODULE  Normal  ! precision specification for real computations

    PUBLIC :: stnd, extd

    ! This requests the processor to use a real implementation 'stnd'
    ! which provides at least 12 decimal digits of precision and an
    ! exponent range of at least 10 ^ +- 50.  It is expected that this
    ! precision will be available on all machines.

    Integer, PARAMETER :: stnd = Selected_Real_Kind ( 12, 50 )
    !-------------------------

    ! A few computations are preferably done in higher precision 'extd'. The
    ! numbers chosen here should be such that the underlying hardware will
    ! select a higher precision for kind 'extd' than for kind 'stnd', if
    ! this is feasible.  If a higher precision is not readily available,
    ! the same values may be used as are given above for 'stnd'. It is
    ! anticipated that on many machines this higher precision may
    ! not be available.

   !Integer, PARAMETER :: extd = Selected_Real_Kind ( 20, 50 ) ! preferred
    Integer, PARAMETER :: extd = Selected_Real_Kind ( 12, 50 ) ! NAG f90: Sun 4
    !-------------------------

end Module Normal
! <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> extended.f90
MODULE  Extended  ! precision specification for real computations

    PUBLIC :: stnd, extd

    ! This requests the processor to use a real implementation 'stnd'
    ! which provides at least 20 decimal digits of precision and an
    ! exponent range of at least 10 ^ +- 80.  It is expected that this
    ! precision may not be available on all machines.

    Integer, PARAMETER :: stnd = Selected_Real_Kind ( 20, 80 )
    !-------------------------

    ! A few computations are preferably done in higher precision 'extd'. The
    ! numbers chosen here should be such that the underlying hardware will
    ! select a higher precision for kind 'extd' than for kind 'stnd', if
    ! this is feasible.  If a higher precision is not readily available,
    ! the same values may be used as are given above for 'stnd'. It is
    ! anticipated that on many machines, such an even higher precision may
    ! not be available.

    Integer, PARAMETER :: extd = Selected_Real_Kind ( 30, 80 )
    !-------------------------

end Module Extended
! <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> long.f90
MODULE  Long  ! precision specification for real computations

    Type  VeryLong           ! not yet implemented

        PRIVATE
        Integer                 :: value
        Type(VeryLong), POINTER :: next

    end Type VeryLong

end Module Long
! <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> integers.f90
MODULE  Integers  ! precision specification for integer computations

    PUBLIC :: short, long

    ! This is provided for those machines where using short integers
    ! has some advantage. The range here is from -999 to +999. Note that
    ! 999 = 10^3 -1. No harm will be done if short integers are made
    ! the same as long integers.

    Integer, PARAMETER :: short = Selected_Int_Kind ( 3 )
    !-------------------------

    ! The range here is at least from  -9 999 999  to +9 999 999. Note
    ! that 10^7 - 1 = 9,999,999. This may limit the largest possible value
    ! of the dimension  n  of problems which can be solved. If n is to
    ! be larger, the 7 should be replaced with a number k so that
    ! n is considerably less than 10^k.

    Integer, PARAMETER :: long  = Selected_Int_Kind ( 7 )
    !-------------------------

end Module Integers
! <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> precision.f90
MODULE Precision

    ! This provides a convenient way of selecting the precision
    ! required for a computation. By simply ensuring that a leading '!'
    ! appears on all but exactly one of the following USE statements,
    ! and then recompiling all routines, the precision of an entire
    ! computation can be altered.

    !    USE Low
         USE Normal
    !    USE Extended
    !    USE Long

         USE Integers

         PRIVATE

         PUBLIC :: stnd, extd, short, long

end Module Precision
! <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> num_constants.f90
MODULE  Num_Constants   ! Values of machine numeric characteristics

    ! This provides simple names for the various machine dependent
    ! constants with intrinsic values in Fortran 90.  All are for
    ! precision 'stnd'.

    USE Precision, only :       stnd

                         Implicit NONE
    PUBLIC
    !-----               -------------!

    PRIVATE :: stnd, X

    Real(stnd)                  :: X  !dummy value
    Real(stnd), PARAMETER       ::              &

        MachTol         = Epsilon(X),           &
        MachHuge        = Huge(X),              &
        MachMaxExp      = MaxExponent(X),       &
        MachMinExp      = MinExponent(X),       &
        MachDecPrec     = Precision(X),         &
        MachBase        = Radix(X),             &
        MachDecExpR     = Range(X),             &
        MachTiny        = Tiny(X)

end Module Num_Constants
! <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> reals.f90
MODULE  Reals   ! Real constants at a given precision

    ! This provides names for all required real values. By only
    ! using real values as defined within this module, all
    ! problems associated with the precision of real literal
    ! values can be totally avoided.

    ! All values are at 'stnd' precision. There are values for the
    ! integral values to 100, the fractions in tenths from 0 to 1,
    ! the reciprocals of the integers to 10, some common
    ! fractions, and whatever miscellaneous real values are
    ! necessary.  A standard naming convention is used.


    USE Precision, only :       stnd

                 Implicit NONE
    PUBLIC
    !-----       -------------!

    PRIVATE :: stnd

    Real(stnd), PARAMETER       ::      & ! digits

        zero    = 0,            &
        one     = 1,            &
        two     = 2,            &
        three   = 3,            &
        four    = 4,            &
        five    = 5,            &
        six     = 6,            &
        seven   = 7,            &
        eight   = 8,            &
        nine    = 9

    Real(stnd), PARAMETER       ::      & ! tenths

        c0_1    = 0.1_stnd,     &
        c0_2    = 0.2_stnd,     &
        c0_3    = 0.3_stnd,     &
        c0_4    = 0.4_stnd,     &
        c0_5    = 0.5_stnd,     &
        c0_6    = 0.6_stnd,     &
        c0_7    = 0.7_stnd,     &
        c0_8    = 0.8_stnd,     &
        c0_9    = 0.9_stnd

    Real(stnd), PARAMETER       ::      & ! reciprocals

        tenth   = 0.1_stnd,             &
        ninth   = one/nine,             &
        eighth  = 0.125_stnd,           &
        seventh = one/seven,            &
        sixth   = one/six,              &
        fifth   = 0.2_stnd,             &
        quarter = 0.25_stnd,            &
        third   = one/three,            &
        half    = 0.5_stnd

    Real(stnd), PARAMETER       ::      & ! fractions a/b named as fa_b

        f1_29   = one/29,               &
        f2_3    = two/three,            &
        f4_3    = four/three,           &
        f7_3    = seven/three

    Real(stnd), PARAMETER       ::      & ! integral values to 99

        ten     = 10,                                                   &
        c10     = 10,           c40     = 40,           c70     = 70,   &
        c11     = 11,           c41     = 41,           c71     = 71,   &
        c12     = 12,           c42     = 42,           c72     = 72,   &
        c13     = 13,           c43     = 43,           c73     = 73,   &
        c14     = 14,           c44     = 44,           c74     = 74,   &
        c15     = 15,           c45     = 45,           c75     = 75,   &
        c16     = 16,           c46     = 46,           c76     = 76,   &
        c17     = 17,           c47     = 47,           c77     = 77,   &
        c18     = 18,           c48     = 48,           c78     = 78,   &
        c19     = 19,           c49     = 49,           c79     = 79,   &
        c20     = 20,           c50     = 50,           c80     = 80,   &
        c21     = 21,           c51     = 51,           c81     = 81,   &
        c22     = 22,           c52     = 52,           c82     = 82,   &
        c23     = 23,           c53     = 53,           c83     = 83,   &
        c24     = 24,           c54     = 54,           c84     = 84,   &
        c25     = 25,           c55     = 55,           c85     = 85,   &
        c26     = 26,           c56     = 56,           c86     = 86,   &
        c27     = 27,           c57     = 57,           c87     = 87,   &
        c28     = 28,           c58     = 58,           c88     = 88,   &
        c29     = 29,           c59     = 59,           c89     = 89,   &
        c30     = 30,           c60     = 60,           c90     = 90,   &
        c31     = 31,           c61     = 61,           c91     = 91,   &
        c32     = 32,           c62     = 62,           c92     = 92,   &
        c33     = 33,           c63     = 63,           c93     = 93,   &
        c34     = 34,           c64     = 64,           c94     = 94,   &
        c35     = 35,           c65     = 65,           c95     = 95,   &
        c36     = 36,           c66     = 66,           c96     = 96,   &
        c37     = 37,           c67     = 67,           c97     = 97,   &
        c38     = 38,           c68     = 68,           c98     = 98,   &
        c39     = 39,           c69     = 69,           c99     = 99

    Real(stnd), PARAMETER       ::      & ! miscellaneous integral values

        c100    = 100,          &
        c180    = 180,          &
        c200    = 200,          &
        c256    = 256,          &
        c360    = 360,          &
        c400    = 400,          &
        c600    = 600,          &
        c681    = 681,          &
        c991    = 991,          &
        c1162   = 1162,         &
        c2324   = 2324,         &
        c10000  = 10000,        &
        c40000  = 40000

    Real(stnd), PARAMETER       ::      & ! miscellaneous real values

                        ! form: d.dd          named as  cd_dd

                        !                 nn
                        ! form: d.dd x 10     named as  cd_ddEnn

                        !                -nn
                        ! form: d.dd x 10     named as  cd_ddMnn

        c1_E6   = 1.0E6_stnd,   &
        c2_M6   = 2.0E-6_stnd,  &
        c1_M13  = 1.0E-13_stnd, &
        c1_M5   = 1.0E-5_stnd,  &
        c1_M4   = 1.0E-4_stnd,  &
        c4_M2   = 4.0E-2_stnd,  &
        c1_M2   = 1.0E-2_stnd,  &
        c0_1136 = 0.1136_stnd,  &
        c1_0001 = 1.0001_stnd,  &
        c1_2    = 1.2_stnd,     &
        c1_5    = 1.5_stnd,     &
        c2_25   = 2.25_stnd,    &
        c2_5    = 2.5_stnd,     &
        c2_625  = 2.625_stnd,   &
        c7_5    = 7.5_stnd,     &
        c10_1   = 10.1_stnd,    &
        c19_8   = 19.8_stnd,    &
        c20_2   = 20.2_stnd

end Module  Reals
! <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> strings.f90
MODULE  Strings ! Routines for simple string stuff

    USE   Precision,  only : short

                         Implicit NONE
    PUBLIC
    !------              -------------!

    Character*1, PARAMETER ::   &        ! Names for common characters

        Ampersand   = "&"  ,    &
        Apostrophe  = "'"  ,    &
        AtSign      = '@'  ,    &
        Backslash   = '\'  ,    &
        Backquote   = '`'  ,    &
        Bang        = '!'  ,    &
        Blank       = ' '  ,    &
        Caret       = '^'  ,    &
        Cbrace      = '}'  ,    &
        Cbracket    = ']'  ,    &
        Cparen      = ')'  ,    &
        Colon       = ':'  ,    &
        Comma       = ','  ,    &
        Dash        = '-'  ,    &
        Dollar      = '$'  ,    &
        Equals      = '='  ,    &
        Exclamation = '!'  ,    &
        Greaterthan = '>'  ,    &
        Hash        = '#'  ,    &
        Lessthan    = '<'  ,    &
        Minus       = '-'  ,    &
        Obrace      = '{'  ,    &
        Obracket    = '['  ,    &
        Oparen      = '('  ,    &
        Percent     = '%'  ,    &
        Period      = '.'  ,    &
        Plus        = '+'  ,    &
        Quesmark    = '?'  ,    &
        Quote       = '"'  ,    &
        Semicolon   = ';'  ,    &
        Slash       = '/'  ,    &
        Star        = '*'  ,    &
        Tilde       = '~'  ,    &
        VertBar     = '|'  ,    &
        Underscore  = '_'


    Character *0, PARAMETER     ::      &

        Null    = ''

    Integer(short), PARAMETER           ::      & ! Codes for case conversions

        ToUpper       = 1,      &
        ToLower       = 2,      &
        Capitalize    = 3

    Integer(short), PARAMETER, PRIVATE  ::      & ! conversion

        shift = ichar('a') - ichar('A')

        ! This assumes that the relation between a lower case letter and
        ! its corresponding upper case letter is the same for every letter.

CONTAINS

SUBROUTINE ASCII_Case_Change (string, type)

                             Implicit NONE
                            !-------------!

    ! ARGUMENTS:

          Character *(*), intent(INOUT) :: string
          Integer(short), intent(IN)    :: type

    ! DESCRIPTION:

    !       This converts each lower case alphabetic letter in string to upper
    !       case, or vice versa.  Specifically,
    !
    !          If type = ToUpper,    conversion is lower to upper
    !          If type = ToLower,    conversion is upper to lower
    !          If type = Capitalize, use upper for first letter; lower for rest
    !
    !       Definitions of ToUpper, ToLower and Capitalize may be obtained from
    !       the host module Strings.
    !
    !       All non-alphabetic characters are left unchanged.
    !
    !   It uses the ASCII character set.

    ! LOCAL DECLARATIONS:

          Integer(short)            :: i

    ! EXECUTION:

          DO i = 1, len(string)
              Select CASE ( type )
                  Case (ToUpper)
                      Select CASE( string(i:i) )
                          Case( 'a':'z' )
                              string(i:i) = achar( iachar(string(i:i)) + shift )
                      end select
                  Case ( ToLower, Capitalize )
                      Select CASE( string(i:i) )
                          Case( 'A':'Z' )
                              string(i:i) = achar( iachar(string(i:i)) - shift )
                      end select
               end select
           end do

           IF ( type == Capitalize ) then
               Select CASE( string(1:1) )
                   Case( 'a':'z' )
                       string(1:1) = achar( iachar(string(1:1)) + shift  )
               end select
           end if

    ! EXIT:
          return

    ! FORMATS:  none.

end Subroutine ASCII_Case_Change


SUBROUTINE Case_Change (string, type)

                             Implicit NONE
                            !-------------!

    ! ARGUMENTS:

          Character *(*), intent(INOUT) :: string
          Integer(short), intent(IN)    :: type

    ! DESCRIPTION:

    !       This converts each lower case alphabetic letter in string to upper
    !       case, or vice versa.  Specifically,
    !
    !          If type = ToUpper,    conversion is lower to upper
    !          If type = ToLower,    conversion is upper to lower
    !          If type = Capitalize, use upper for first letter; lower for rest
    !
    !       Definitions of ToUpper, ToLower and Capitalize may be obtained from
    !       the host module Strings.
    !
    !       All non-alphabetic characters are left unchanged.
    !
    !   It uses the underlying machine character set.

    ! LOCAL DECLARATIONS:

          Integer(short)            :: i

    ! EXECUTION:

          DO i = 1, len(string)
              Select CASE ( type )
                 Case (ToUpper)
                     Select CASE( string(i:i) )
                         Case('a':'i')
                             string(i:i) = char( ichar(string(i:i)) + shift  )
                         Case('j':'r')
                             string(i:i) = char( ichar(string(i:i)) + shift  )
                         Case('s':'z')
                             string(i:i) = char( ichar(string(i:i)) + shift  )
                     end select
                 Case ( ToLower, Capitalize )
                     Select CASE( string(i:i) )
                         Case('A':'I')
                             string(i:i) = char( ichar(string(i:i)) - shift  )
                         Case('J':'R')
                             string(i:i) = char( ichar(string(i:i)) - shift  )
                         Case('S':'Z')
                             string(i:i) = char( ichar(string(i:i)) - shift  )
                     end select
              end select
          end do

          IF ( type == Capitalize ) then
              Select CASE( string(1:1) )
                  Case('a':'i')
                      string(1:1) = char( ichar(string(1:1)) + shift  )
                  Case('j':'r')
                      string(1:1) = char( ichar(string(1:1)) + shift  )
                  Case('s':'z')
                      string(1:1) = char( ichar(string(1:1)) + shift  )
              end select
          end if

    ! EXIT:
          return

    ! FORMATS:  none.

end Subroutine Case_Change


SUBROUTINE Mid_Shift (string, from, to, number )

                             Implicit NONE
                            !-------------!

    ! ARGUMENTS:

          Character *(*), intent(INOUT) :: string
          Integer(short), intent(IN)    :: from, to, number

    ! DESCRIPTION:

    !     This routine performs a shift of characters within string. The
    !     number of characters shifted is number and they are shifted so
    !     that the character in position 'from' is moved to position 'to'.
    !     Characters in the to position are overwritten. Blanks replace
    !     characters in the from position. Shifting may be left or right,
    !     and the from and to positions may overlap.  Care is taken not to
    !     alter or use any characters beyond the defined limits of the string.

    ! LOCAL DECLARATIONS:

          Integer(short)         :: end, end1, n, shorten, slen
          Character (Len=number) :: substring

    ! EXECUTION:

          slen  = len (string)

          IF ( from /= to ) then

              end1 = from+number-1    ! end1 is the initial position of the last
                                      ! character in the substring specified to
                                      ! be shifted.

              ! n is the number of characters that will be shifted and that will
              ! remain within the confines of string.  n may have to be reduced
              ! for a shift to the right to ensure that characters beyond the
              ! end of string are not dealt with (this is not necessary for left
              ! shifts since the substring moved to the left can never extend
              ! beyond the end of string).

              IF ( end1 > slen ) then
                  shorten = end1 - slen
                  n       = number - shorten
              else
                  n       = number
              end if

              IF ( from < to ) n = min(slen,to+n-1_short) - to + 1

              end = from + n - 1   ! end is the last character that will
                                   ! actually be shifted (and still remain
                                   ! within the limits of string).

! substring is a temporary fix until a compiler bug is fixed.
              substring(1:n)                      = string(from:end )
              string( to:min(slen,to+n-1_short) ) = substring(1:n)

              IF ( from < to ) then            ! shift to right
                  string(from:min(to-1_short,end1) ) = blank
              else                             ! shift to left
                  string(max(to+n,from):end ) = blank
              end if

          end if

    ! EXIT:
          return

    ! FORMATS:  none.

    end Subroutine Mid_Shift


    SUBROUTINE Center ( string )

                             Implicit NONE
                            !-------------!

    ! ARGUMENTS:

          Character *(*), intent(INOUT) :: string

    ! DESCRIPTION:
    !
    !     This routine shifts the nonblank characters of string so that
    !     there is a balance of blanks on left and right.
    !

    ! LOCAL DECLARATIONS:

          Integer(short)     :: start, endch, clen, left

    ! EXECUTION:

        endch = len_trim( string )    ! Find last non-blank character.

        IF ( endch /= 0 ) then

            start = verify( string, blank )    ! Find first nonblank character.

            clen = endch - start + 1           ! Compute shift and do it.
            left = 1 + (len(string) - clen) / 2

            IF ( start > left ) then
                string(left:)    = adjustl( string(left:) )    ! move left
            else
                string(1:left+1) = adjustr( string(1:left+1) ) ! move right
            end if

        end if

    ! EXIT:
          return

    ! FORMATS:  None.

    end Subroutine Center

end Module Strings
! <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> general.f90
MODULE  General         ! General purpose routines

    USE   Reals,      only : ONE
    USE   Strings,    only : blank, Mid_Shift
    USE   Precision,  only : long, short, stnd
!!!!USE   F90_UNIX    ! for use with the second version of CpuSecs below

                         Implicit NONE
    PRIVATE
    !------              -------------!

    PUBLIC ::   Entering, Leaving, Indent,      &
                CpuSecs,                        &
                My_Date_Time,                   &
                WriteMat, WriteVec

    Integer(short), PARAMETER   :: Spaces    = 2
    Integer(short)              :: LastCount = 0

    Character*9, PARAMETER :: months(12) = (/   'January  ', 'February ',  &
                                                'March    ', 'April    ',  &
                                                'May      ', 'June     ',  &
                                                'July     ', 'August   ',  &
                                                'September', 'October  ',  &
                                                'November ', 'December '/),&

                              Days(0:6)  = (/   'Sunday   ', 'Monday   ',  &
                                                'Tuesday  ', 'Wednesday',  &
                                                'Thursday ', 'Friday   ',  &
                                                'Saturday '             /)

    Integer(short), PARAMETER   :: defunit   =  6  ! For WriteMat and WriteVec
    Integer(short), PARAMETER   :: defline   = 80  ! Default values
    Integer(short), PARAMETER   :: defindent =  0
    Character*1,    PARAMETER   :: deff      = 'f'
    Integer(short), PARAMETER   :: defw      = 12
    Integer(short), PARAMETER   :: defd      =  6
    Integer(short), PARAMETER   :: defs      =  3

CONTAINS

    FUNCTION Entering ( string, trace, unit, level )

        ! Upon entering a procedure, this function will be called.
        ! It will return a prefix string suitable for indenting
        ! output lines from the procedure. It takes the given string
        ! and prepends 'level' blanks, followed by a '[', and appends
        ! the character ']'. For example, if string were 'hi' and level
        ! were 7, it would return '       [hi]'.  Level is then also
        ! incremented by the value of Spaces.

        ! If trace is true, it also outputs a message that the
        ! routine identified by string was entered.

        ! ARGUMENTS:

        Character*(*),  intent(IN)          :: string
        Logical,        intent(IN)          :: trace
        Integer(short), intent(IN)          :: unit
        Integer(short), intent(INOUT)       :: level

        ! LOCAL DECLARATIONS:

        Character (Len=len(string)+2+level) :: Entering

        ! EXECUTION:

        Entering(1:level ) = blank
        IF (trace) write (unit,'(A)') Entering(1:level) // '[Into '//string//']'
        Entering(level+1:) = '[' // string // ']'

        level = level + Spaces

    end Function Entering

    SUBROUTINE Leaving  ( string, trace, unit, level )

        ! This is the 'opposite' to Entering. It should be called
        ! just before leaving a routine. Level is reduced by
        ! Spaces and if trace is true, an exit message is output.

        ! ARGUMENTS:

        Character*(*),  intent(IN)      :: string
        Logical,        intent(IN)      :: trace
        Integer(short), intent(IN)      :: unit
        Integer(short), intent(INOUT)   :: level

        ! EXECUTION:

        level = level - Spaces
        IF (trace) write (unit,'(A)') repeat(blank,int(level)) // &
                                      '[Done '//string//']'

    end Subroutine Leaving

    SUBROUTINE Indent  ( id, unit, level )

        ! This is also used to indent output, albeit in a manner
        ! different from Entering and Leaving. It simply writes
        ! out 'level' blanks followed by the string id in [], and
        ! leaves the output file marker where it is. It uses
        ! nonadvancing output.  If level is not present, just
        ! the id part is output; i.e. level is treated as zero.

        ! ARGUMENTS:

        Character*(*),  intent(IN)           :: id
        Integer(short), intent(IN)           :: unit
        Integer(short), intent(IN), OPTIONAL :: level

        ! LOCAL DECLARATIONS:

        Integer(short)                       :: lev

        ! EXECUTION:

        IF ( PRESENT(level) ) then
            lev = level
        else
            lev = 0
        end if

        write(unit,'(A)',ADVANCE='no') repeat(blank,int(lev)) // '[' //ID// ']'

    end Subroutine Indent

!!!!FUNCTION CpuSecs()

    ! This function obtains, from a C system routine cputime,
    ! the current value of the system CPU usage clock. This value (in seconds)
    ! is then returned as a standard precision real value.

!!!!    Real(stnd) :: CpuSecs, cputime

!!!!    CpuSecs  = cputime()

!!!!    return

!!!!end Function CpuSecs

!!!!FUNCTION CpuSecs()

    ! This function obtains, from the Unix module F90_UNIX,
    ! the current value of the system CPU usage clock. This value (in seconds)
    ! is then returned as a standard precision real value.
    ! The module F90_UNIX, provided with NAG compiler v2.0, contains the
    ! functions times and clock_ticks_per_second, as well as the defined type
    ! TMS.  The USE statement for the F90_UNIX module, located at line 6 of
    ! general.f90, must be uncommented when using this version of CpuSecs.

!!!!    Real(stnd) :: CpuSecs
!!!!    Type(TMS)  :: buffer

!!!!    CpuSecs  = times(buffer)
!!!!    CpuSecs  = real((buffer%utime+buffer%stime),stnd) / &
!!!!               clock_ticks_per_second()

!!!!    return

!!!!end Function CpuSecs

    FUNCTION CpuSecs()

    ! This function obtains, from the intrinsic routine system_clock,
    ! the current value of the system CPU usage clock. This value
    ! is then converted to seconds and returned as a standard precision
    ! real value.

    ! LOCAL DECLARATIONS:

        Real(stnd) :: CpuSecs
        Integer    :: count, count_rate, count_max
        Real(stnd) :: secs

    ! EXECUTION:

        call system_clock( count, count_rate, count_max )

        secs  = real(count,stnd) / real(count_rate,stnd)

        IF (count < LastCount) &      ! wraparound of clock ticker
            secs = secs + real(count_max,stnd) / real(count_rate,stnd)

        LastCount = count

        CpuSecs  = secs

        return

    end Function CPUsecs

    Subroutine My_Date_Time ( chdate )

    ! ARGUMENTS:

        Character *(*) :: chdate

    ! DESCRIPTION:
    !
    !  This routine returns in chdate a 41-character date of the form given
    !  in model (below). It uses the time and date as obtained from the
    !  intrinsic routine Date_and_Time and converts them to the form of the
    !  model given below.  The time and date are returned from date_and_time
    !  as character strings, respectively, of the form:
    !
    !        time:  hhmmss.sss
    !        date:  yyyymmdd
    !
    !  Note that excess blanks in the date are eliminated.
    !  If chdate is more than 41 characters in length, only the
    !  leftmost 41 will be altered.  If it is less than 41 in
    !  length, only the leftmost characters of the date will be returned.

    ! LOCAL DECLARATIONS:

        Integer(short), PARAMETER ::   pthour =  1,      &
                                       ptmin  =  4,      &
                                       ptampm =  7,      &
                                       ptmon  = 24,      &
                                       ptday  = 34,      &
                                       ptyear = 38,      &
                                       ptdayn = 13

        Character*(*), PARAMETER  ::                &

            model ='00:00 a.m., Wednesday, September 00, 1999'

        Integer(short)            :: kmon, to, k, modlen
        Integer(long)             :: dayno

        Character *10 ::    time
        Character * 8 ::    date
        Character *41 ::   tdate

    ! EXECUTION:

        tdate  = model
        modlen = len_trim(tdate)

        call date_and_time( date, time )

        IF ( date(7:7) == '0' ) date(7:7) = ' '

        tdate ( ptday  :  ptday+1 ) = date(7:8)
        tdate ( ptyear : ptyear+3 ) = date(1:4)

        read ( date(7:8), '(i2)' )  dayno
        read ( date(1:4), '(i4)' )   k

        read ( date(5:6), '(i2)' )  kmon
        tdate(ptmon:ptmon+8) = months(kmon)
        to = len_trim ( months(kmon) )

        IF ( to /= 9 ) call Mid_Shift ( tdate, ptmon+9_short, ptmon+to, modlen )

        IF ( kmon == 1 .or. kmon == 2 ) then
             kmon = kmon + 13
             k    = k    - 1
        else
             kmon = kmon + 1
        end if

        dayno = dayno + int ( real(kmon) * 30.6001 )
        dayno = dayno + int ( real(  k ) * 365.25  )
        dayno = mod ( dayno+5, 7 )

        tdate(ptmin:ptmin+1) = time(3:4)  ! minute
        read ( time(1:2), '(i2)' ) k      ! hour

        IF ( k >= 13 ) then
             k = k-12
             tdate(ptampm:ptampm) = 'p'
        else if ( k == 12 ) then
             tdate(ptampm:ptampm) = 'p'
        else if ( k ==  0 ) then
             k = k + 12
             tdate(ptampm:ptampm) = 'a'
        else
             tdate(ptampm:ptampm) = 'a'
        end if

        write ( tdate(pthour:pthour+1), '(i2)' ) k
        tdate(ptdayn:ptdayn+8) = days(dayno)
        k = len_trim (days(dayno))

        IF ( k /= 9 ) then ! ==> shift over blanks.
             call Mid_Shift ( tdate, ptdayn+9_short, ptdayn+k, modlen )
        end if

        modlen = min ( modlen, int( len_trim(chdate), short ) )
        chdate(1:modlen) = tdate

        return

    end Subroutine My_Date_Time

    Subroutine WriteMat (x,                              &
                         a, b, y, f, w, d, s, unit,      &  ! Optional
                         name, indent, line )

                             Implicit NONE
                            !-------------!

    ! ARGUMENTS:

        Real(stnd),     intent(IN)           :: x(:,:)

        Real(stnd),     intent(IN), OPTIONAL :: y(size(x,1),size(x,2)), a, b
        Integer(short), intent(IN), OPTIONAL :: unit, w, d, s, indent, line
        Character*1 ,   intent(IN), OPTIONAL :: f
        Character *(*), intent(IN), OPTIONAL :: name

    ! DESCRIPTION:

    !   Print out a submatrix of a matrix with given format, as below.

    !   Print a title for the matrix: name

    !   If the value of the argument  indent  is positive, then each output
    !   line is preceded by  indent  blank characters.  If  indent  is negative,
    !   then only the matrix output will be indented (not the title).

    !   Print the values from the matrix a*X + b*Y.
    !   a and b are scalars; X and Y are matrices.

    !   Print each entry in format  fw.d
    !              ..f is a character 'f', 'g', 'e' or 'd'
    !              ..w and d are integers
    !              ..s is the number of spaces between each entry.
    !              ..line is the number of characters per line.
    !                  (if line=0, then line is replaced with 80)

    !   All output is on the unit 'unit'.

    !   Defaults are defined for all optional arguments.  See start of module.


    !   LOCAL DECLARATIONS:

        Real(stnd)              :: fa, fb
        Integer(short)          :: actunit, actw, actd, acts, actindent, &
                                   actline, i,    j
        Character*1             :: actf
        Character*34, PARAMETER :: defform ='((??x,??(? ??.??, ?? x), ? ??.??))'
                               !  e.g.       ((02x,05(f 09.04, 03 x), f 09.04))
                               !             1234567890123456789012345678901234
        Character*34            :: form

    !   EXECUTION:

    !   First set appropriate default values.

        form = defform

        IF ( PRESENT(unit) )   then; actunit   = unit
        else;                        actunit   = defunit
        end if

        IF ( PRESENT(line) )   then; actline   = line
        else;                        actline   = defline
        end if

        IF ( PRESENT(indent) ) then; actindent = indent
        else;                        actindent = defindent
        end if

        IF ( PRESENT(f) )      then; actf      = f
        else;                        actf      = deff
        end if

        IF ( PRESENT(w) )      then; actw      = w
        else;                        actw      = defw
        end if

        IF ( PRESENT(d) )      then; actd      = d
        else;                        actd      = defd
        end if

        IF ( PRESENT(s) )      then; acts      = s
        else;                        acts      = defs
        end if

        IF ( PRESENT(a) )      then; fa        = a
        else;                        fa        = ONE
        end if

        IF ( PRESENT(b) )      then; fb        = b
        else;                        fb        = ONE
        end if

        IF ( actindent == 0 ) then
            write ( form(03:06), 99998 ) blank
        else
            write ( form(03:04), 99999 ) abs(actindent)
        end if

        write ( form(07:08), 99999 ) (actline-abs(actindent)-actw)/(actw+acts)
        write ( form(10:10), 99997 ) actf
        write ( form(12:13), 99999 ) actw
        write ( form(15:16), 99999 ) actd

        IF ( acts /= 0 ) then
            write ( form(19:20), 99999 ) acts
        else
            write ( form(17:22), 99998 ) blank
        end if

        write ( form(26:26), 99997 ) actf
        write ( form(28:29), 99999 ) actw
        write ( form(31:32), 99999 ) actd

        DO i = 1, actindent
            write ( unit, 99998, ADVANCE='no' ) blank
        end do

        IF ( PRESENT(name) ) write ( unit, 99998 ) name

        DO i = 1, size(x,1)
            IF ( PRESENT(y) ) then
                write ( unit, form ) ( fa*x(i,j)+fb*y(i,j), j=1, size(x,2) )
            else
                write ( unit, form ) ( fa*x(i,j), j=1, size(x,2) )
            end if
        end do

        return

        ! FORMATS:  Also see character string form.

        99997   format (A1)
        99998   format (A)
        99999   format (i2)

    end Subroutine WriteMat

    Subroutine WriteVec (x,                              &
                         a, b, y, f, w, d, s, unit,      &  ! Optional
                         name, indent, line )

                         Implicit NONE
                        !-------------!

    ! ARGUMENTS:

        Real(stnd),     intent(IN)           :: x(:)

        Real(stnd),     intent(IN), OPTIONAL :: y(size(x)), a, b
        Integer(short), intent(IN), OPTIONAL :: unit, w, d, s, indent, line
        Character*1 ,   intent(IN), OPTIONAL :: f
        Character *(*), intent(IN), OPTIONAL :: name

    ! DESCRIPTION: This functions just as WriteMat, except that it
    !              prints a vector instead of a matrix.

    ! LOCAL DECLARATIONS:

        Real(stnd)              :: fa, fb
        Integer(short)          :: actunit, actw, actd, acts, actindent, &
                                   actline, i
        Character*1             :: actf
        Character*34, PARAMETER :: defform ='((??x,??(? ??.??, ?? x), ? ??.??))'
                               !  e.g.       ((02x,05(f 09.04, 03 x), f 09.04))
                               !             1234567890123456789012345678901234
        Character*34            :: form

    ! EXECUTION:

    !   First set appropriate default values.

        form = defform

        IF ( PRESENT(unit) )   then; actunit   = unit
        else;                        actunit   = defunit
        end if

        IF ( PRESENT(line) )   then; actline   = line
        else;                        actline   = defline
        end if

        IF ( PRESENT(indent) ) then; actindent = indent
        else;                        actindent = defindent
        end if

        IF ( PRESENT(f) )      then; actf      = f
        else;                        actf      = deff
        end if

        IF ( PRESENT(w) )      then; actw      = w
        else;                        actw      = defw
        end if

        IF ( PRESENT(d) )      then; actd      = d
        else;                        actd      = defd
        end if

        IF ( PRESENT(s) )      then; acts      = s
        else;                        acts      = defs
        end if

        IF ( PRESENT(a) )      then; fa        = a
        else;                        fa        = ONE
        end if

        IF ( PRESENT(b) )      then; fb        = b
        else;                        fb        = ONE
        end if

        IF ( actindent == 0 ) then
            write ( form(03:06), 99998 ) blank
        else
            write ( form(03:04), 99999 ) abs( actindent )
        end if

        write ( form(07:08), 99999 ) (actline-abs(actindent)-actw)/(actw+acts)
        write ( form(10:10), 99997 ) actf
        write ( form(12:13), 99999 ) actw
        write ( form(15:16), 99999 ) actd

        IF ( acts /= 0 ) then
            write ( form(19:20), 99999 ) acts
        else
            write ( form(17:22), 99998 ) blank
        end if

        write ( form(26:26), 99997 ) actf
        write ( form(28:29), 99999 ) actw
        write ( form(31:32), 99999 ) actd

        DO i = 1, actindent
            write ( unit, 99998, ADVANCE='no' ) blank
        end do

        IF ( PRESENT(name) ) write ( unit, 99998 ) name

        IF ( PRESENT(y) ) then
            write ( unit, form ) ( fa*x(i)+fb*y(i), i=1, size(x) )
        else
            write ( unit, form ) ( fa*x(i), i=1, size(x) )
        end if

        return

        ! FORMATS:  Also see character string form.

        99997   format (A1)
        99998   format (A)
        99999   format (i2)

    end Subroutine WriteVec

end Module General
! <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> inner_product.f90
MODULE  Inner_Product

! This contains routines for computing the normal inner product of
! two vectors, as given by their dot product, as well as a routine
! for doing a generalized inner product. Without modification, the
! generalized inner product is a duplicate of the normal one.
!
! An operator is provided for applying each inner product, namely
!
!       x .GIP. y       for the generalized inner product of x and y
!       x .IP.  y       for the normal inner product of x and y
!
! The operator .GIP. is in fact overloaded; there must be a second,
! specialized version which computes the generalized inner product
! of the vector x with the vector e[j] = (0,0,...,0,1,0,...,0), i.e.
! with the canonical jth unit vector. It is accessed as
!
!       x .GIP. j
!
! For each inner product, the norm ||.|| it induces is also available,
! as defined by
!
!                                  1/2
! .GNORM. x = ||x||  =  (x .GIP. x)     for the generalized norm
!
!                                  1/2
! .NORM.  x = ||x||  =  (x .IP.  x)     for the usual norm
!
! In the case of the usual norm, a special routine is used for
! computing the value with due regard to avoiding unnecessary overflow.
!----------------------------------------------------------------------
!
! Users who wish may replace the general inner product routine with
! one of their own. In this case, the interface should NOT be changed.
! Only the code WITHIN the functions GenInner, GenInnerJ and GenNorm
! should be modified; i.e. all changes should be restricted to these
! functions.
!
! It is up to the user to verify that a legal inner product is used.
! Users who do not understand this discussion may safely ignore this;
! anyone who may need this capability will undoubtedly know what this
! is all about.
!
! If the general inner product routine is altered, the general norm
! function must also be changed, in accordance with the definition above.
! This may be done by activating the line so marked in the routine GenNorm.
!
! If overflow is likely to be a problem when the generalized norm is computed
! by taking the square root of the inner product, a special general norm
! routine may be written. It is the responsibility of the user.
!
!----------------------------------------------------------------------

    USE Precision, only : stnd, short, long

                         Implicit NONE
    PRIVATE
    !------              -------------!

    PUBLIC  ::  OPERATOR(.IP.),         &
                OPERATOR(.GIP.),        &
                OPERATOR(.NORM.),       &
                OPERATOR(.GNORM.)

    INTERFACE  OPERATOR  ( .GIP. )

        Module Procedure  GenInner, GenInnerJ

    end Interface

    INTERFACE  OPERATOR  ( .GNorm. )

        Module Procedure  GenNorm

    end Interface

    INTERFACE  OPERATOR  ( .IP. )

        Module Procedure  Inner

    end Interface

    INTERFACE  OPERATOR  ( .Norm. )

        Module Procedure  Norm2

    end Interface

CONTAINS

Real(stnd) FUNCTION  GenInner ( x, y )

                     Implicit NONE
                    !-------------!

    ! ARGUMENTS:

        Real(stnd), intent(IN)  :: x (:)
        Real(stnd), intent(IN)  :: y (size(x))

    ! DESCRIPTION:

    !   This is made available for users wishing to redefine the
    !   underlying metric of the space involved by redefining the
    !   inner product used for the updating of the quasi-Newton
    !   matrices.

    ! EXECUTION:

        ! Replace code below this line if required---------------

        GenInner = Dot_Product ( x, y )

        ! Replace code above this line if required---------------

end Function GenInner


Real(stnd) FUNCTION  GenInnerJ ( x, j )

                     Implicit NONE
                    !-------------!

    ! ARGUMENTS:

        Real(stnd),    intent(IN)       :: x (:)
        Integer(long), intent(IN)       :: j

    ! DESCRIPTION:

    !   This is made available for users wishing to redefine the
    !   underlying metric of the space involved by redefining the
    !   inner product used for the updating of the quasi-Newton
    !   matrices.  Specifically, this routine computes the general
    !   inner product of the vector x and the jth unit coordinate
    !   vector  [0,...,0,1,0,...,0], where the 1 is in the jth
    !   position.  In general, this may *not* just equal  x[j].

    ! EXECUTION:

        ! Replace code below this line if required---------------

        GenInnerJ =  x(j)

        ! Replace code above this line if required---------------

end Function GenInnerJ


Real(stnd) FUNCTION  Norm2 ( v )

        USE Num_Constants, only :  MachTol, MachHuge, MachTiny
        USE Reals,         only :  one, zero

                     Implicit NONE
                    !-------------!

    ! ARGUMENTS:

        Real (stnd), intent(IN)      :: v(:)
    !
    ! DESCRIPTION:
    !
    !     This computes the 2-norm (i.e. the Euclidean norm) of the vector  v
    !     of length n, with due regard to avoiding overflow and underflow.
    !
    !     The routine is based on snrm2 from the blas (in linpack), but this
    !     version is written in Fortran 90. It is machine independent.
    !
    !     The machine constants MachTiny (the smallest magnitude), MachHuge(the
    !     largest magnitude), and MachTol (epsilon) are used to calculate the
    !     constants cutlo and cuthi.  Three different cases must be considered
    !     when calculating the norm:
    !
    !        (1)  All components of v are below cutlo.
    !
    !               To avoid underflow, each component is divided by sqrt(min)/n
    !               and then the regular Euclidean norm of this modified vector
    !               is calculated.  This result is then multiplied by
    !               sqrt(min)/n  in order to get the correct value for the norm.
    !
    !        (2)  One or more components are greater than cuthi.
    !
    !                 To avoid overflow, the same method as in case (1) is used
    !                 with a scaling factor of   sqrt(max)*n .
    !
    !        (3)  All components are less than cuthi, with at least one
    !             component greater than cutlo.
    !
    !                 The regular formula for the Euclidean norm is used.
    !
    ! PARAMETERS:

        Integer(short), PARAMETER           :: null   = 0,     &
                                               small  = 1,     &
                                               normal = 2,     &
                                               large  = 3

    ! LOCAL DECLARATIONS:

        Integer(long)                       :: i, n
        Integer(short)                      :: range

        Real(stnd)                          :: cutlo, cuthi, summ, xmax

    ! EXECUTION:

        n = size(v)

        IF ( n <= 0 ) then
            Norm2 = ZERO
            return
        end if

        cutlo = sqrt ( MachTiny / MachTol )
        cuthi = sqrt ( MachHuge ) / n

        summ  = ZERO
        range = null

        ! Evaluate the norm by accumulating a scaled sum of squares and
        ! adjusting the scaling as numbers of increasingly large magnitude
        ! are found.

        DO  i = 1,n

            Select CASE (range)

            Case (normal)
                IF ( abs(v(i)) < cuthi ) then
                    summ = summ + v(i)**2
                else
                    range = large
                    xmax = abs(v(i))
                    summ = ONE + (summ/v(i))/v(i)
                end if

            Case (small)
                IF ( abs(v(i)) <= cutlo ) then
                    IF ( abs(v(i)) <= xmax ) then
                        summ = summ + (v(i)/xmax) **2
                    else
                        summ = ONE + (xmax/v(i)) **2
                        xmax = abs(v(i))
                    end if
                else if ( abs(v(i)) >= cuthi ) then
                    range = large
                    xmax  = abs(v(i))
                    summ  = ONE + (summ/v(i))/v(i)
                else
                    range = normal
                    summ  = (summ*xmax)*xmax + v(i)**2
                end if

            Case (large)
                IF ( abs(v(i)) <= xmax ) then
                    summ = summ + (v(i)/xmax)**2
                else
                    summ = ONE + summ * (xmax/v(i))**2
                    xmax = abs(v(i))
                end if

            Case (null)
                IF      ( abs(v(i)) == ZERO  ) then
                    !                                 just fall through...
                else if ( abs(v(i)) <= cutlo ) then
                    range = small
                    xmax  = abs (v(i))
                    summ  = ONE
                else if ( abs(v(i)) >= cuthi ) then
                    range = large
                    xmax  = abs (v(i))
                    summ  = ONE
                else
                    range = normal
                    summ  = v(i)**2
                end if

            end select

        end do

        Select CASE (range)
            Case (normal, null); Norm2 = sqrt(summ)
            Case Default       ; Norm2 = xmax * sqrt(summ)
        end select

    ! EXIT:
            return

    ! FORMATS:  none are defined.

end Function Norm2

Real(stnd) FUNCTION  GenNorm  ( x )

                     Implicit NONE
                    !-------------!

    ! ARGUMENTS:

        Real(stnd), intent(IN)  :: x (:)

    ! DESCRIPTION:

    !   This is made available for users wishing to redefine the
    !   underlying metric of the space involved by redefining the
    !   inner product used for the updating of the quasi-Newton
    !   matrices.  It is used in conjunction with GenInner and indeed
    !   this routine computes the norm of x associated with the
    !   redefined inner product.

    ! EXECUTION:

        ! GenNorm = sqrt ( x .GIP. x )  ! Activate this line if desired.

        ! The above line *defines* the generalized norm; the user may wish
        ! however to evaluate it in some other fashion, possibly to prevent
        ! unwanted overflows, as in the routine Norm2.

        GenNorm = Norm2 (x)        ! Remove this line if inner product changed.

end Function GenNorm


Real(stnd) FUNCTION  Inner ( x, y )

                     Implicit NONE
                    !-------------!

    ! ARGUMENTS:

        Real(stnd), intent(IN)  :: x (:)
        Real(stnd), intent(IN)  :: y (size(x))

    ! DESCRIPTION:

    !   This is provided so that an operator may be defined for
    !   computation of the standard inner product.

    ! EXECUTION:

        Inner = Dot_Product ( x, y )

end Function Inner


end Module Inner_Product
! <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> supp_codes.f90
MODULE Supp_Codes

! See Module Min_Codes for an explanation of how these codes work.

    USE  Precision, only :  short

                         Implicit NONE
     PRIVATE
    !------              -------------!

    PUBLIC  ::  Str_Evaluation,  &
                Str_Derivative,  &
                Str_ReturnState

    !=================
    ! For Evaluate_f |
    !=================

    !Str_Evaluation
    Integer(short), PARAMETER, PUBLIC   :: & ! Function evaluation

        justF   = 0,                    & ! just evaluate f at x
        both    = 1,                    & ! evaluate both f and g at x
        justG   = 2,                    & ! just evaluate g at x
        noOp    = 3                       ! Evaluate_f just calls the
                                          !   user routine and then returns.


    !Str_Derivative
    Integer(short), PARAMETER, PUBLIC   :: & ! Derivative calculation modes

        Analytic        = 1,            & ! Compute from analytic formulae
        CompareTest     = 2,            & ! Compute both and compare
        FirstTest       = 3,            & ! Like CompareTest, just iteration 1
        Differences     = 4               ! Compute using finite differences

    !Str_ReturnState
    Integer(short), PARAMETER, PUBLIC   :: & ! Return from Evaluation

        OK      =  0,                   & ! f and/or g succesfully computed.
        Abort   = -1,                   & ! User requested abort.
        Limit   = -2,                   & ! Function count limit exceeded.
        NoF     = -3,                   & ! f could not be computed.
        NoG     = -4,                   & ! g could not be computed.
        NoForG  = -5                      ! Neither f nor g could be computed.

    !================
    ! For Test_Done |
    !================

    Integer(short), PARAMETER, PUBLIC   :: & ! type of norm

        L1        = 1,                  & ! use absolute sum norm
        L2        = 2,                  & ! use sqrt(sum of squares) norm
        Linf      = 3,                  & ! use max absolute term norm
        G2        = 4                     ! use sqrt(x .GIP. x) norm


CONTAINS


FUNCTION Str_Evaluation(i)

! ARGUMENTS:
            Integer(short) :: i

! LOCAL DECLARATIONS:

    Character*5,  PARAMETER       :: str(justF:noOp) = (/   &
                                         'justF',           &
                                         'both ',           &
                                         'justG',           &
                                         'noOp '       /)

    Character(len_trim(str(i)))   :: Str_Evaluation

! DESCRIPTION: This function returns the specified value for the evaluation
!              to be done.

! EXECUTION:
            Str_Evaluation = str(i)
            return

end Function Str_Evaluation


FUNCTION Str_Derivative(i)

! ARGUMENTS:
            Integer(short) :: i

! LOCAL DECLARATIONS:

    Character*11, PARAMETER       :: str(Analytic:Differences) = (/   &
                                         'Analytic   ',               &
                                         'CompareTest',               &
                                         'FirstTest  ',               &
                                         'Differences'           /)

    Character(len_trim(str(i)))   :: Str_Derivative

! DESCRIPTION: This function returns the specified value for the derivative
!              method.

! EXECUTION:
            Str_Derivative = str(i)
            return

end Function Str_Derivative


FUNCTION Str_ReturnState(i)

! ARGUMENTS:
            Integer(short) :: i

! LOCAL DECLARATIONS:

    Character*6,  PARAMETER       :: str(NoForG:OK) = (/   &
                                         'NoForG',         &
                                         'NoG   ',         &
                                         'NoF   ',         &
                                         'Limit ',         &
                                         'Abort ',         &
                                         'OK    '     /)

    Character(len_trim(str(i)))   :: Str_ReturnState

! DESCRIPTION: This function returns the specified value for the return
!              condition from the function evaluation.

! EXECUTION:
            Str_ReturnState = str(i)
            return

end Function Str_ReturnState


end Module Supp_Codes
! <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> supp_states.f90
MODULE Supp_States

    USE Precision, only : stnd, long, short

                         Implicit NONE
     PUBLIC
    !------              -------------!

    !=================
    ! For Evaluate_f |
    !=================

    TYPE EvalState
        Integer(short)  :: ScaleF,      &
                           Derivatives, &
                           Expense,     &
                           EvalLimit,   &
                           EvalTraceUnit
        Logical         :: TraceF,      &
                           TraceG,      &
                           TraceDervTest
    end type

    TYPE EvalCounts
        Integer(long)   :: FEvals,      &
                           GEvals
        Real(stnd)      :: time
    end type

    TYPE EvalErrors
        Real(stnd)      :: Worst,       &
                           Average,     &
                           AccumSum
        Integer(long)   :: Gradcnt,     &
                           Index,       &
                           AccumNumber
    end type

    !====================
    ! For Print_Iterate |
    !====================

    TYPE PrintState
        Integer(long)   :: Frequency
        Integer(short)  :: PrintUnit
        Logical         :: PrintX, PrintGrad
    end type

    TYPE LastPrint
        Integer(short)  :: unit
        Integer(long)   :: iter
        Logical         :: prx
        Logical         :: prg
    end type

    TYPE PrintValues
        Real(stnd)      :: time
        Integer(long)   :: NextPoint
        Type(LastPrint) :: last
    end type

    !================
    ! For Test_Done |
    !================

    TYPE TermState
        Integer(short)  :: TheNorm
        Logical         :: TraceTerm
        Integer(short)  :: TermTraceUnit
        Logical         :: UseGrad,     &
                           UseStep,     &
                           UseShanno,   &
                           UseFunc
        Real(stnd)      :: FatX0,       &
                           NormGatX0
    end type

    TYPE TermValues
        Real(stnd)      :: NormGsq,     &
                           NormXsq,     &
                           Diffsq
    end type

end Module Supp_States
! <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> supp_defs.f90
MODULE Supp_Defs                ! Default values for support routines

    USE True_False
    USE Precision,   only : stnd, short, long
    USE Reals,       only : zero, one
    USE Supp_States, only : EvalState,  EvalCounts,  EvalErrors,        &
                            PrintState, LastPrint,   PrintValues,       &
                            TermState
    USE Supp_Codes,  only : Analytic, L2

                         Implicit NONE
    PRIVATE
    !------              -------------!

    PUBLIC  :: DefaultEvalState,  &
               DefaultPrintState, &
               DefaultTermState,  &
               InitEvalCts,       &
               InitEvalErs,       &
               InitPrVals

    !=================
    ! For Evaluate_f |
    !=================

    Integer(short), PARAMETER, PRIVATE ::       &  ! Default values

        ScaleF          = 0,            &
        Derivatives     = Analytic,     &
        Expense         = 1,            &
        EvalTraceUnit   = 6

    Integer(long),  PARAMETER, PRIVATE ::       &

        EvalLimit       = 300

    Logical,        PARAMETER, PRIVATE ::       &

        TraceF          = false,        &
        TraceG          = false,        &
        TraceDervTest   = false

    Type (EvalState)    :: DefaultEvalState = &

          evalstate (   ScaleF,         &
                        Derivatives,    &
                        Expense,        &
                        EvalLimit,      &
                        EvalTraceUnit,  &
                        TraceF,         &
                        TraceG,         &
                        TraceDervTest   &
                    )


    Integer(long), PARAMETER, PRIVATE ::        &  ! Initial values

        FEvals          = 0,            &
        GEvals          = 0

    Real(stnd),    PARAMETER, PRIVATE ::        &

        etime           = ZERO

    Type (EvalCounts)   :: InitEvalCts = &

          evalcounts (  FEvals,         &
                        GEvals,         &
                        etime           &
                     )


    Real(stnd), PARAMETER, PRIVATE ::   &  ! Initial values for derivative est.

        Worst           = ZERO,         &
        Average         = ZERO,         &
        AccumSum        = ZERO

    Integer(long), PARAMETER, PRIVATE ::        &

        Iteration       = 0,            &
        Index           = 0,            &
        AccumNumber     = 0

    Type (EvalErrors)   :: InitEvalErs = &

          evalerrors (  Worst,          &
                        Average,        &
                        AccumSum,       &
                        Iteration,      &
                        Index,          &
                        AccumNumber     &
                     )

    !====================
    ! For Print_Iterate |
    !====================

    Integer(long),  PARAMETER, PRIVATE ::       & ! Default Values

        Frequency       = 10000

    Integer(short), PARAMETER, PRIVATE ::       & ! Default Values

        PrintUnit        = 6

    Logical,        PARAMETER, PRIVATE ::       &

        PrintX           = false,       &
        PrintGrad        = false

    Type (PrintState)   ::  DefaultPrintState = &

          printstate (                  &
                        Frequency,      &
                        PrintUnit,      &
                        PrintX,         &
                        PrintGrad       &
                     )


    Real(stnd),    PARAMETER, PRIVATE ::        &  ! Initial Values

        time            = ZERO

    Integer(long), PARAMETER, PRIVATE ::        &

        NextPoint       = 0

    Type (PrintValues)  ::  InitPrVals   =      &

          printvalues(  time,                   &
                        NextPoint,              &
                        LastPrint(PrintUnit,-1,false,false) &
                     )

    !================
    ! For Test_Done |
    !================

    Integer(short), PARAMETER, PRIVATE ::       &  ! Default Values

        TheNorm         = L2,           &
        TermTraceUnit   = 6

    Logical,        PARAMETER, PRIVATE ::       &

        TraceTerm       = false,        &
        UseGrad         = true,         &
        UseStep         = false,        &
        UseShanno       = true,         &
        UseFunc         = false

    Real(stnd),     PARAMETER, PRIVATE ::       &

        FatX0           = ONE,          &
        NormGatX0       = ONE

    Type (TermState)    ::      DefaultTermState = &

          termstate (   TheNorm,        &
                        TraceTerm,      &
                        TermTraceUnit,  &
                        UseGrad,        &
                        UseStep,        &
                        UseShanno,      &
                        UseFunc,        &
                        FatX0,          &
                        NormGatX0       &
                    )

end Module Supp_Defs
! <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> fscale.f90
MODULE FScale     ! 'USE'ed in modules Support and EvaluateF

    USE Precision,        only  : stnd,  short
    USE Supp_Codes,       only  : justF, justG, both
    USE Reals,            only  : one,   two,   three
    USE True_False

                         Implicit NONE
    PRIVATE
    !------              -------------!

    PUBLIC  ::  F_Scale

CONTAINS

SUBROUTINE F_Scale ( Ft, Scale, FScaled, GScale, which )


! ARGUMENTS:

    Real (stnd),     intent(IN)            :: Ft
    Integer (short), intent(IN)            :: Scale
    Real (stnd),     intent(OUT)           :: FScaled, GScale

    Integer(short),  intent(IN),  OPTIONAL :: which

! DESCRIPTION:
!
!   This subroutine applies one of several scalings (linear or nonlinear)
!   to a function, thereby modifying the function and/or gradient value.
!
!   On Entry:
!
!           Ft    - the present function value
!
!           Scale - the code for the type of scale desired, where the scaling
!                   function is one of the following:
!
!                     1:   ff(z) = 1 + z
!                     2:   ff(z) = z*z
!                     3:   ff(z) = -1 / (1 + z*z)
!                     4:   ff(z) =  sqrt(1 + z*z)
!                     5:   ff(z) = z*z*z
!
!           which - See Evaluate_F. If it is omitted, the value both is assumed.
!
!   On Exit:
!           FScaled - the scaled function value.
!           GScale  - gradient scaling factor.
!
! LOCAL DECLARATIONS:

    Logical     :: doF, doG

! EXECUTION:

    IF ( .not. PRESENT(which) ) then
        doF = true
        doG = true
    else
        doF =   which == justf  .or. which == both
        doG =   which == justg  .or. which == both
    end if

    Select CASE ( int( Scale ) )

        Case (1)      ! ff(z) = 1 + f(z)

            IF ( doF ) FScaled = Ft + ONE
            IF ( doG ) Gscale  = ONE

        Case (2)      ! ff(z) = z*z

            IF ( doF ) FScaled =  Ft * Ft
            IF ( doG ) Gscale  = TWO * Ft

        Case (3)      ! ff(z) = -1/(1+z**2)

            IF ( doF ) FScaled =           -  ONE / ( ONE + Ft**2 )
            IF ( doG ) Gscale  =  TWO * Ft * (ONE / ( ONE + Ft**2 ))**2

        Case (4)      ! ff(z) = sqrt(1+z**2)

            IF ( doF ) FScaled =     sqrt(ONE + Ft**2)
            IF ( doG ) Gscale  =  Ft/sqrt(ONE + Ft**2)

        Case (5)      ! ff(z) = z*z*z

            IF ( doF ) FScaled =    Ft*Ft*Ft
            IF ( doG ) Gscale  = THREE*Ft*Ft

        Case Default        ! ff(z) = z

            IF ( doF ) FScaled = Ft
            IF ( doG ) Gscale  = ONE

    end select

    return

! FORMATS:  none.

end Subroutine F_Scale

end Module FScale
! <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> evaluatef.f90
MODULE EvaluateF     ! 'USE'ed in module Support

    USE Precision,        only  : stnd, long, short
    USE Supp_States,      only  : EvalCounts, EvalState, EvalErrors
    USE Supp_Codes
    USE Supp_Defs,        only  : InitEvalCts, InitEvalErs
    USE General,          only  : Indent, CpuSecs, WriteVec
    USE Num_Constants,    only  : MachTol
    USE Reals,            only  : zero, one, c100
    USE True_False

    USE FScale,           only  : F_Scale

                         Implicit NONE
    PRIVATE
    !------              -------------!

    PUBLIC  ::  Evaluate_F

CONTAINS

RECURSIVE &
SUBROUTINE Evaluate_f ( FName, x, fx, g, job, Ev, Cts, &

                        first,                        & ! optional
                        Test,                         &
                        level )


    INTERFACE
            Subroutine FName ( x, fx, g, job )
                Real(stnd),     intent(INOUT) :: x(:)
                Real(stnd),     intent(OUT)   :: fx, g(size(x))
                Integer(short), intent(INOUT) :: job
            end Subroutine
    end Interface

! ARGUMENTS:

    Real(stnd),        intent(INOUT)            :: x(:), fx
    Real(stnd),        intent(OUT)              :: g(size(x))

    Integer(short),    intent(INOUT)            :: job

    Type (EvalState),  intent(IN)               :: Ev
    Type (EvalCounts), intent(INOUT)            :: Cts

    Logical,           intent(IN),    OPTIONAL  :: first
    Type (EvalErrors), intent(INOUT), OPTIONAL  :: Test
    Integer(short),    intent(IN),    OPTIONAL  :: level

! DESCRIPTION:
!
!   This subroutine evaluates a test function at the given point x.  It returns
!   the value of the function and/or the value of the gradient at x.  It allows
!   the application of a nonlinear scaling to the function if desired (see
!   ScaleF below). It also allows the use of finite differences (see Derivatives
!   below). It can also act as a noop, i.e. as a do nothing routine (see
!   job below).
!
!  On Entry:
!  --------
!
!   First  This must be present and true each time a new problem is begun.
!          It causes initialization of counts described below to be done.
!
!   FName  is the name of the function to evaluate.  There must be a subroutine
!          provided of the form
!
!                    Subroutine FName(x,fx,g,job)
!
!          (x, fx, g and job mean the same as in this subroutine.)
!          The precise interface definition for FName appears above.
!
!   x      contains the value of the n-coordinates x(1),...,x(n) at which to
!          evaluate the function.
!
!   job =  justf   only evaluate the function.
!       =  both    evaluate both.
!       =  justg   only evaluate the gradient.
!       =  noop    actually, if job has any value other than one of the first
!                  three, then just call FName with this same code for job;
!                  i.e. Evaluate_f should do nothing. This is intended for
!                  the possible convenience of the writer of FName.
!
!   Ev     This record contains a number of control fields. These are explained
!          below.
!
!   level  If present, indent trace output by this number of spaces.
!
!   Cts    See below.
!
!   Test   See Finite Difference Error Estimates below.
!
!  On Exit:
!  --------
!
!   fx     contains the function value (with the scaling applied if required).
!
!   g      contains the gradient value (with the scaling applied if required).
!
!   job = OK      The request made on the call was completed satisfactorily.
!                 fx and/or g are available as requested.
!         Abort   The minimization routine which called Evaluate_f is hereby
!                 requested to exit immediately to the routine which called
!                 it.  This can be used by the routine FName to trigger
!                 premature termination due to circumstances of which the
!                 minimization routine may not be aware.
!         Limit   Terminate the minimization; the preset limit on the number
!                 of function evaluations allowed has been exceeded.
!         NoF     The function value could not be determined.
!         NoG     The gradient value could not be determined.
!         NoForG  Neither fx nor g could be evaluated.
!
!   Cts     See below.
!
!  Control values in Ev:   Ev contains the following fields (amongst others).
!  -------------------
!
!   ScaleF      controls the nonlinear scaling of FName.
!
!          = 0     no effect.
!
!          = k > 0 This routine computes and returns  ff( FName(x) ), where ff
!                  is the  k-th  of the nonlinear functions of one variable
!                  defined in the routine F_Scale.
!
!                Note that for certain scalings, the function value is needed to
!                scale the gradient vector. So, in this case,  if you call
!                Evaluate_f just for a gradient value, it is necessary to supply
!                the function value in fx as well, in order to do the scaling.
!
!   Derivatives This specifies the method by which derivatives are to be
!               computed, when requested. The choice is between:
!
!      Analytic Use analytic formulae which must be coded and available in the
!               user routine FName.
!
!      Differences Use finite difference approximations. In this case, the user
!               routine FName may ignore calls with job /= justf, and need only
!               be able to compute function values.  Further comments appear in
!               the discussion of finite difference computations (below).
!
!      CompareTest  In this case both analytic and finite differences are
!               computed.  They are then compared and a record is kept to see to
!               what extent they disagree. A record of the level of agreement is
!               available through the optional argument Test.  A more complete
!               description is also given below.
!
!      FirstTest   This case is precisely the same as for CompareTest, with
!               the sole exception that the testing only takes place on the
!               first call to Evaluate_f.
!
!   EvalLimit   The maximum value allowed for the count Cts%FEvals.
!
!         = 0      On entry specifies no maximum, i.e. any number of function
!                  evaluations may be done. This is inadvisable.
!
!         = k > 0  Specifies the maximum number of times that FName may be
!                called.  If the function evaluation count in FEvals is greater
!                than or equal to  EvalLimit on entry to Evaluate_f, then the
!                function is not evaluated and the return code job is set as
!                above. Note that the count in FEvals does NOT include function
!                evaluations used for computing finite difference gradients.
!
!   Expense     This may be used to artificially increase the expense of a
!               function evaluation. If Expense is >1, then the function is
!               simply evaluated Expense times. Of course, Expense-1 of these
!               are totally redundant. This can be used for testing purposes.
!
!   It is possible to trace parts of the execution of Evaluate_f.
!
!   TraceF        if true, the function value is to be printed
!   TraceG        if true, the gradient value is to be printed
!   TraceDervTest if true, the function values are to be printed during testing
!                          mode
!
!   EvalTraceUnit  the unit number for output of computed values
!
!   Note that an error message is printed when the maximum number of function
!   evaluations is exceeded, provided either TraceF or TraceG is true.
!
!  Counts available on exit.
!  ------------------------
!
!   The following counts are available in the record Cts on exit.  As noted
!   above, Evaluate_f must be called once with First = true to ensure that these
!   are correctly initialized.
!
!   FEvals  the number of calls to evaluate the function, i.e. calls with job
!           = justf or both. Note that calls to evaluate the function for the
!           purpose of doing finite differences are not included in this count.
!
!   GEvals  the number of calls to evaluate the gradient, i.e. calls with
!           job = justg or both.
!
!   time    the amount of cpu time spent in  Evaluate_f.  The time used in
!           the final scaling is included in the timing.  Timing commences on
!           entry to Evaluate_f, and ends just before return from Evaluate_f.
!
!  Finite Difference Error Estimates
!  ---------------------------------
!
!   If the derivative mode is CompareTest, then the accuracy of finite
!   difference/analytic derivative calculations is monitored. On return, if
!   Test is present, one may find in the fields of Test:
!
!      Worst      The worst error which occurred.
!      Average    Estimate of the average number of figures of agreement.
!      GradCnt    Count of gradient evaluations where the worst error occurred.
!      Index      Component of the gradient where the worst error occurred.
!
!   To be specific, when in test mode, each component of the analytic derivative
!   is computed, and these are returned in g as the gradient.  As well, for each
!   component, a finite difference approximation is computed (as described
!   below) and the relative difference between that and the analytic component
!   is determined.  This quantity is monitored, and the largest such value is
!   recorded. In addition, Index records in which component of that gradient the
!   error occurred, and GradCnt tells which gradient evaluation was in
!   progress when the error occurred; i.e. GradCnt just records the current
!   value of Cts%GEvals.  Note that Index and GradCnt only refer to the point
!   at which the largest error occurred.
!
!   If the function and gradient evaluations are correct, one would normally
!   expect the relative error to be of the order of 10**-(t/2), where  t  is the
!   number of figures of relative accuracy of the machine in use.  However, as
!   the minimum is approached and the gradient components generally become very
!   small, this relative accuracy may be much worse than expected. Therefore we
!   also maintain an estimate of the average agreement. Here, for each component
!   of each gradient computation, we compute the base 10 log of the relative
!   accuracy; this is roughly the number of significant figures of agreement
!   between the two values. This quantity is monitored and  Average is returned
!   as the average value of the number of significant figures of agreement.
!
!   When function and gradient computations are correct, Worst will generally be
!   at least as small as  10**(-t/2), although it can be more like 10**(-t/4).
!   Gross blunders will usually give the worst error a value very near to 1, but
!   not always.  If all is well, Average will usually be about t/2; blunders
!   will often result in Average being near 0 or 1.
!
!   Finite difference computations
!
!   For first derivatives, simple forward differences are used.
!   To estimate the i-th component of the gradient of f, we compute
!
!                 ( f(x + h*e[i]) - f(x) ) / h,
!
!   where h = eps * abs(x[i]).  When x[i] = 0, we just choose h = eps.
!   Here eps is sqrt(MachTol), where MachTol is the machine accuracy. This is
!   used when Derivatives = Differences, CompareTest or FirstTest.
!
!   When Derivatives = CompareTest, more information is required; thus we also
!   compute f(x + sqrt(h)*e[i]).  This means that when in test mode, twice as
!   many function evaluations are needed.  This is required to eliminate
!   scaling effects in the estimate of figures of agreement.
!
! SUBROUTINES:
!               FName    ...the user routine.
!               F_Scale  ...performs scaling.

! PARAMETERS:

    Character *(*), PARAMETER   :: id     = 'Eval'

! LOCAL DECLARATIONS:

    Logical             ::  FirstTime, DoCompare, doF, doG

    Integer(short)      ::  RememberBad, dervs, Job_Return, calls
    Integer(long)       ::  count, kk, zdcnt, zindex, zgcnt

    Real(stnd)          ::  Ft, Fv, tt,  scale,  rh, zerr, zserr, &
                            Fval, Fval2, h, terr

! EXECUTION:

    IF ( Ev%TraceF .or. Ev%TraceG ) then
        call Indent( id, Ev%EvalTraceUnit, level )
        write ( Ev%EvalTraceUnit,992 ) job,justf,justg,both
    end if

    IF ( job /= justf .and. job /= justg .and. job /= both ) then ! noop call.
       call FName ( x, fx, g, job )
       goto 905
    end if

    IF ( Ev%EvalLimit > 0 .and. Cts%FEvals >= Ev%EvalLimit ) then
       goto 910
    end if

    dervs = Ev%Derivatives

    IF ( PRESENT(first) ) then
        FirstTime = first
    else
        FirstTime = false
    end if

    IF ( FirstTime ) then
        Cts  = InitEvalCts
        IF ( PRESENT(Test) ) Test = InitEvalErs
        IF ( Ev%Derivatives == FirstTest ) dervs = CompareTest
    else
        IF ( Ev%Derivatives == FirstTest ) dervs = Analytic
    end if

    doF =   job == justf    .or.   job == both
    doG =   job == justg    .or.   job == both

    Cts%time = Cts%time - CpuSecs()

    IF ( doF ) Cts%FEvals = Cts%FEvals + 1
    IF ( doG ) Cts%GEvals = Cts%GEvals + 1

!-----First compute required function and/or gradient values.

    DoCompare =  PRESENT(Test) .and. dervs == CompareTest

    IF ( DoCompare ) then
        zerr   = Test%Worst
        zserr  = Test%AccumSum
        zdcnt  = Test%AccumNumber
        zindex = Test%Index
        zgcnt  = Test%GradCnt
    end if
    RememberBad = OK

    EXPENSE: &
    DO kk = 1, Ev%Expense   ! Repeat if required to simulate expensive call.

        IF (dervs == Analytic  .or.  .not. doG) then
            calls = 0
        else
            calls = size(x)      ! extra calls to FName needed.
        end if

        Job_Return = job                ! First compute  f(x)  and/or  g(x).
        call FName ( x, Fval, g, Job_Return )

        Select CASE (Job_Return)
            Case (Limit,Abort,NoF,NoG,NoForG);  RememberBad = Job_Return
                                                CYCLE
        end select

        IF ( job == justG ) then
            IF ( scale /= 0 ) Ft = fx
        else
            Ft = Fval
        end if

        NCALLS: &
        DO count = 1, calls  !Do extra calls, if required: function values only.

            tt = x(count)  ! save x

            h = sqrt(MachTol)
            IF ( tt /= ZERO ) then ! finite difference step
                h = h * abs(tt)
            end if

            x(count) = tt + h      ! Compute  f( x + h * e[count] )

            Job_Return = justF
            call  FName ( x, Fval, g, Job_Return )

            x(count) = tt       ! restore x

            Select CASE (Job_Return)
                Case (Limit,Abort,NoF,NoG,NoForG); RememberBad = Job_Return
                                                   CYCLE Expense
            end select

            DOCOMPAR: &
            IF ( DoCompare ) then

                IF ( Ev%TraceDervTest ) then
                    call Indent( id, Ev%EvalTraceUnit, level )
                    write(Ev%EvalTraceUnit,995) g(count),count,(fval-ft)/h
                end if

                ! Estimate error, and leave computed analytic gradients in g.
                ! Use f at x + a * e[count], for a = h and sqrt(h).

                rh       = sqrt(h)
                x(count) = tt + rh

                Job_Return = justF
                call  FName ( x, Fval2, g, Job_Return )
                x(count) = tt

                Select CASE (Job_Return)
                    Case (Limit,Abort,NoF,NoG,NoForG); RememberBad = Job_Return
                                                       CYCLE Expense
                End Select

                IF ( abs(Fval2-Ft) > c100*MachTol*abs(Ft) ) then
                    terr = (Fval-Ft - h*g(count))/ (Fval2-Ft - rh*g(count))
                    IF (tt > ONE) terr = terr / tt

                    terr = max( min(ONE,abs(terr)), MachTol ) ! in [MachTol,1]

                    zserr = zserr - log10 (terr) ! Number of figures agreement.
                    zdcnt = zdcnt + 1

                    IF (Ev%TraceDervTest) then
                        call Indent( id, Ev%EvalTraceUnit, level )
                        write(Ev%EvalTraceUnit,994) terr,-log10(terr)
                    end if
                    IF ( terr > abs(zerr) ) then
                       zindex = count
                       zgcnt  = Cts%GEvals
                       zerr   = sign (terr, zerr)
                    end if
                 else
                    zerr = - abs(zerr) ! Flag case with excessive cancellation.
                    IF (Ev%TraceDervTest) then
                        call Indent( id, Ev%EvalTraceUnit, level )
                        write(Ev%EvalTraceUnit,993)
                    end if
                 end if
            else  ! DOCOMPAR  Estimate gradients with forward finite difference
                g(count) = ( Fval - Ft ) / h
            end if  DOCOMPAR

        end do NCALLS

        IF ( Ev%ScaleF /= 0 ) then ! Do scaling: define Fv and scale.
            call F_Scale ( Ft, Ev%ScaleF, Fv, scale, job )
        else
            Fv    = Ft
            scale = ONE
        end if

        IF ( doF ) then         ! Revise function and gradient as necessary.
          fx  = Fv
        end if

        IF ( doG .and. scale /= ONE ) then
            g = scale * g
        end if

    end do EXPENSE

    IF ( DoCompare ) then
        Test%Worst       = zerr
        Test%Index       = zindex
        Test%GradCnt     = zgcnt
        Test%AccumNumber = zdcnt
        Test%AccumSum    = zserr
        Test%Average     = zserr/zdcnt
    end if

    job = RememberBad

! EXIT:
900 Cts%time = Cts%time + CpuSecs()

    IF ( Ev%TraceF .and. job == OK ) then
        call Indent( id, Ev%EvalTraceUnit, level )
        write (Ev%EvalTraceUnit,998) fx
    end if

    IF ( Ev%TraceG .and. job == OK ) then
        call WriteVec(g,f='g',w=15_short,d=8_short,unit=Ev%EvalTraceUnit, &
                        name='gradient',indent=level)
    end if

905 return  !  NoOp

910 IF ( Ev%TraceF .or. Ev%TraceG ) then ! max. number of func. evals exceeded.
        call Indent( id, Ev%EvalTraceUnit, level )
        write ( Ev%EvalTraceUnit,999 )
    end if
    job = limit
    return

! FORMATS:

992 format( ' job (f,g,fg)=',4i3)
993 format( ' Excessive error in gradient estimation.')
994 format( ' Error estimate in gradient estimation: ', g15.7/        &
            ' Estimated figures of agreement:        ', g9.2 )
995 format( ' Analytic gradient   ', g22.15, ' (component ',i3,')'/   &
              ' Estimated derivative', g22.15                       )
998 format( ' Function = ', g26.16 )
999 format(/' The number of function evaluations allowed has been exceeded.')

end Subroutine Evaluate_f

End Module EvaluateF
! <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> print.f90
MODULE Print     ! 'USE'ed in module Support

    USE Precision,        only  : stnd, long, short
    USE Supp_States,      only  : EvalCounts, PrintState, PrintValues
    USE General,          only  : Indent, CpuSecs, WriteVec
    USE True_False

                         Implicit NONE
    PRIVATE
    !------              -------------!

    PUBLIC  ::  Print_Iterate

CONTAINS

SUBROUTINE Print_Iterate ( n, iteration, Fx, nrmg, Counts, C, V, &
                           x,                                    & ! OPTIONAL
                           g,                                    &
                           force,                                &
                           first,                                &
                           copy,                                 &
                           copyunit,                             &
                           level                                 )


! ARGUMENTS:

    Integer(long),     intent(IN)               :: n, iteration

    Real(stnd),        intent(IN)               :: Fx, nrmg

    Type (EvalCounts), intent(IN)               :: Counts
    Type (PrintState), intent(IN)               :: C
    Type (PrintValues),intent(INOUT)            :: V


    Real(stnd),        intent(IN),    OPTIONAL  :: x(n), g(n)
    Logical,           intent(IN),    OPTIONAL  :: force, first

    Logical,           intent(IN),    OPTIONAL  :: copy
    Integer(short),    intent(IN),    OPTIONAL  :: copyunit
    Integer(short),    intent(IN),    OPTIONAL  :: level

! DESCRIPTION:
!
!   This routine prints the value Fx of some function, and the norm nrmg of
!   its gradient, at some point x, along with (optionally) the point x, and
!   (optionally) the value of the gradient g at the point x.
!
!   Arguments.
!
!   n           the dimension of the problem
!   iteration   current iteration number
!   Fx          the function value at x
!   nrmg        the norm of the gradient at x
!   Counts      function and gradient evaluation counts (from Evaluate_f)
!   C           the control record
!                   PrintUnit   unit for output
!                   frequency   interval between output
!                   PrintX      true to include point x in output
!                   PrintGrad   true to include gradient g in output
!   V           current data; needed for next call
!                   time        cumulative time herein
!                   NextPoint   next point to print at
!                   last..iter  iteration no of last point printed
!                         unit  unit used for last print
!                         prx   value of printx from last print
!                         prg   value of printgrad from last print
!
!   Optional Arguments (see below).
!
!   x        the current point
!   g        the gradient value at x
!   force    force output
!   first    this is first call
!   copy     duplicate output wanted
!   copyunit duplicate unit
!   level    if present, indent trace output by this number of spaces
!
!
!  1. Control is under C%frequency.
!
!     frequency  <= 0   there is no output.
!
!     frequency  >  0   print every frequency-th iteration:
!
!               the iteration number in iteration
!               the function value in Fx
!               the no. of function evaluations in Counts@FEvals
!               the norm of the gradient in nrmg
!               the no. of gradient evaluations in Counts@GEvals
!               the function/gradient evaluation time
!               the point x (if C%PrintX  is true and x is present)
!               the gradient g (if C%PrintGrad is true and g is present)
!
!  2. V%NextPoint records the number of the next iteration at which to print.
!     If, on entry, iteration = NextPoint, generate the output.
!     If on entry the value of iteration is already greater than that of
!     nextpoint, nextpoint is repeatedly incremented by frequency until
!     that is no longer true. It is initialized to 0 on a call with first
!     present and true.
!
!  3. Setting force to true will cause the current point to be printed, even if
!     iteration does not match the value of NextPoint.  This is useful for
!     forcing printing of the final point reached.
!
!  4. The routine is careful not to repeat a printing request.  If the output
!     unit or the status of C%PrintX  or C%PrintGrad or the iteration count is
!     different, then the printing is done; otherwise it is considered a
!     repeat of a previous request and it is ignored.  Information about the
!     previous iterate is stored in V%last and should not be altered by
!     the calling routine.
!
!  5. V%time is used for accumulating the time spent in the print routine.
!     It is started from zero on a call with first present and true,
!     and each call increments time by the time spent in the routine.
!
!  6. If copy if present and true and copyunit is present,
!     all output is duplicated on the designated unit.

! PARAMETERS:

    Character *(*), PARAMETER   :: id     = 'Prnt'

! LOCAL DECLARATIONS:

    Logical       :: IsFirst, ForceIt, DoCopy

    Real(stnd)    :: secs

! EXECUTION:

    secs = CpuSecs()

    IF ( PRESENT(first) ) then
        IsFirst = first
    else
        IsFirst = false
    end if

    IF ( PRESENT(force) ) then
        ForceIt = force
    else
        ForceIt = false
    end if

    IF ( PRESENT(copy) ) then
        DoCopy = copy  .and. PRESENT(copyunit)
    else
        DoCopy = false
    end if

    IF ( IsFirst ) then
        V%NextPoint = 0
        V%time      = -secs
    else
        V%time      = V%time - secs
    end if

    PRINT: &
    IF (   IsFirst                          .or.  &  ! Need to print?
         ( iteration    /=    V%last%iter ) .or.  &
         ( C%PrintUnit  /=    V%last%unit ) .or.  &
         ( C%PrintX    .neqv. V%last%prx  ) .or.  &
         ( C%PrintGrad .neqv. V%last%prg  ) )     &
        then

        IF ( C%frequency > 0  ) then
            DO while (V%NextPoint < iteration)
                V%NextPoint = V%NextPoint + C%frequency
            end do
        end if

        IF ( (C%PrintUnit /= 0 ) .and.          &
             (C%frequency >  0 ) .and.          &
             (ForceIt    .or. (iteration == V%NextPoint)) ) then

            !        Save information defining this print request.
            V%last%iter = iteration
            V%last%unit = C%PrintUnit
            V%last%prx  = C%PrintX
            V%last%prg  = C%PrintGrad

            ! Print iteration number, function value, norm of g, and
            !       number of function/gradient evaluations.

            call Indent( id, C%PrintUnit, level )
            write ( C%PrintUnit, 999 )  iteration,Fx,Counts%FEvals,nrmg, &
                                               Counts%GEvals,Counts%time
            IF ( DoCopy ) then
                call Indent( id, copyunit, level )
                write ( copyunit, 999 ) iteration,Fx,Counts%FEvals,nrmg, &
                                               Counts%GEvals,Counts%time
            end if

            ! if appropriate, also print x and g.

            IF ( PRESENT(x) .and. C%PrintX ) then
                call WriteVec( x, f='g', unit=C%PrintUnit,         &
                               name='['//id//'] x->', indent=level )
                IF ( DoCopy ) then
                    call WriteVec( x, f='g', unit=copyunit,            &
                                   name='['//id//'] x->', indent=level )
                end if
            end if

            IF ( PRESENT(g) .and. C%PrintGrad ) then
                call WriteVec( g, f='g', unit=C%PrintUnit,         &
                               name='['//id//'] g->', indent=level )
                IF ( DoCopy ) then
                    call WriteVec( g, f='g', unit=copyunit,            &
                                   name='['//id//'] g->', indent=level )
                end if
            end if
        end if

        IF ( iteration == V%NextPoint  .and.  C%frequency > 0 )  &
                                                              ! Update counter.
            V%NextPoint = V%NextPoint + C%frequency

    end if  PRINT

! EXIT:

    V%time = V%time + CpuSecs()

! FORMATS:

!999 format(' ',' ...pt ',i3,'; f=',g23.16,'(#',i3,') ||g||=',        &
!                           e7.2, '(#',i3,'); '/,17x,f8.3,' secs'    )
999 format(' ','pt ',i3,'; f=',g23.16,'(#',i3,') ||g||=',        &
                           e7.2, '(#',i3,'); ',f8.3,' s'    )

end Subroutine Print_Iterate

end Module Print
! <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> testdone.f90
MODULE TestDone     ! 'USE'ed in module Support

    USE Precision,        only  : stnd, short
    USE Supp_States,      only  : TermState, TermValues
    USE Supp_Codes,       only  : L1, L2, Linf, G2
    USE General,          only  : Indent
    USE Inner_Product,    only  : OPERATOR(.IP. ), &
                                  OPERATOR(.GIP.)
    USE Reals,            only  : zero, one
    USE True_False

                         Implicit NONE
    PRIVATE
    !------              -------------!

    PUBLIC  ::  Test_Done

CONTAINS

Logical FUNCTION Test_Done ( eps, C, Fx, g, xi, xim1, V, level )


! ARGUMENTS:

    Real(stnd),       intent(IN)                    :: eps
    Type(TermState),  intent(IN)                    :: C
    Real(stnd),       intent(IN),  OPTIONAL         :: Fx, g(:), xi(:), xim1(:)
    Type(TermValues), intent(OUT), OPTIONAL, TARGET :: V
    Integer(short),   intent(IN),  OPTIONAL         :: level

! DESCRIPTION:
!
!   This routine is used to test whether or not to terminate a minimization
!   routine.  It provides a means of using uniform criteria for different
!   routines.  A choice of criteria is provided, according to values which are
!   passed in the the state structure C.
!
!   Note that in one case, one test cannot be applied; i.e. on the first point,
!   since a pair of successive points is required, one can not use the test on
!   the stepsize.  In this case, the argument xim1 must NOT be passed to the
!   routine, and the function value is always returned as false if one applies
!   the test which looks at more than one point.
!
!   Note that Test_Done will always return a true value if the norm of the
!   gradient computes to 0, since in this case, no further steps can be taken
!   anyway.
!
!   Here ||u|| denotes the appropriate norm of the vector u.
!
!   n     is the length of the vectors.
!
!   Some of the actions of the routine are determined by values set in the
!   state structure C. Appropriate integer codes are defined in Supp_Codes.
!   The fields of C have the following effects:
!
!     TheNorm  = L1    use the   L1      (abssum) norm of vectors.
!              = L2    use the   L2   (Euclidean) norm of vectors.
!              = Linf  use the maximum (infinity) norm of vectors.
!              = G2    use the generalized        norm of vectors.
!
!     TraceTerm  If the trace argument is set to true, then the result of
!            each test will be printed on the trace unit.  Note that when
!            several tests are being applied, the trace will show each of the
!            possible test values, whereas normally an exit occurs as soon as
!            any test fails.
!
!   Tests selected: there are currently four. They are applied independently,
!   and all tests chosen must be passed. The arguments required, depending
!   on the tests in use, must be present.
!
!   The tests may be scaled relative to certain values, normally the
!   value of the function and gradient at the initial point. See below.
!
!      UseGrad     Test if the appropriate norm of g is <= eps.  This first
!                  type of test is most commonly used to see if the gradient is
!                  sufficiently small.  Thus the test applied is
!
!                           ||g|| <= eps * NormGatX0
!
!      UseStep     Test if the appropriate norm of the difference between xi and
!                  xim1 is <= eps.  The test is absolute if the norm of xi is
!                  less than 1, and relative otherwise.  This type of test is
!                  normally used to test the distance between successive points.
!                  Thus the test is
!
!                       ||xi-xim1|| <= eps * max(1,||xi||)
!
!      UseShanno   Use a test appearing in Shanno's CONMIN using x and g.
!                  Termination is indicated when
!
!                              ||g||
!                           ------------  <=   eps * NormGatX0
!                           max(1,||xi||)
!
!      UseFunc     Terminate if the function value is sufficiently small.  This
!                  test would normally only be used in a relative manner.
!                  Thus the test is
!
!                         |Fx| <= eps * FatX0
!
!   It is often desired to make termination tests relative to the function
!   and/or gradient values at the initial point.  In the tests above, the values
!   FatX0  and  NormGatX0 are used; these may be thought of as the function
!   value at X0, along with the norm of the gradient at that point.  The values
!   for FatX0 and NormGatX0 must be set by the user before calling Test_Done.
!   If relative tests are not desired, these values should be set to 1. These
!   values are fields in C.
!
!   Other points to note are:
!
!   Some tests are actually done by comparing the squares of the norms against
!   eps**2.  Thus it is possible that this version of this routine might
!   generate an unwanted overflow or underflow.
!
!   Note:  Neither  g  nor xi nor xim1 is altered by this routine.  Only those
!          vectors used in the test are actually referenced. For example, if the
!          only test to be applied is UseGrad, then neither xi nor xim1 is
!          referenced, and they can be omitted from the call.  Vectors which
!          should be present but are not are treated as zero.
!
!   On Return:  If the desired tests are *all* passed, then Test_Done is set
!               to true; otherwise it is set to false.
!
!               In addition, the vector norms computed during application of the
!               tests are available.  Of course, only those which were actually
!               computed in applying the desired tests will be defined. These
!               are returned in the fields of V, if V is present.
!
!               We have specifically:
!
!        gsq    norm squared of  g,       gsq    = ||g||**2
!        xsq    norm squared of  xi,      xsq    = ||xi||**2
!        diffsq norm squared of  xi-xim1, diffsq = ||xi-xim1||**2
!
!   level    if present, indent trace output by this number of spaces
!
! PARAMETERS:

    Character *(*), PARAMETER   :: id     = 'Term'

! LOCAL DECLARATIONS:

    Logical                     :: pass, passthis

    Real(stnd), POINTER         ::     gsq,     xsq,     diffsq
    Real(stnd), TARGET          :: locgsq,   locxsq,  locdiffsq

! EXECUTION:

    IF ( PRESENT(V) ) then      ! return values if V present in call
        gsq    => V%NormGsq
        xsq    => V%NormXsq
        diffsq => V%Diffsq
    else
        gsq    => locgsq
        xsq    => locxsq
        diffsq => locdiffsq
    end if

    IF ( C%UseGrad .or. C%UseShanno ) then      ! (norm of g) ^2

        IF ( PRESENT(g) ) then
            Select CASE ( C%TheNorm)
                Case(L1);   gsq = SUM(abs(g))   **2
                Case(L2);   gsq = g .IP.  g
                Case(Linf); gsq = maxval(abs(g))**2
                Case(G2);   gsq = g .GIP. g
            end select
        else
            gsq = ZERO
        end if

        IF ( gsq == ZERO ) then
            Test_Done = true
            goto 900
        end if
    end if

    IF ( C%UseStep .or. C%UseShanno ) then      ! (norm of xi) ^2

        IF ( PRESENT(xi) ) then
            Select CASE ( C%TheNorm)
                Case(L1);   xsq = SUM(abs(xi))   **2
                Case(L2);   xsq = xi .IP.  xi
                Case(Linf); xsq = maxval(abs(xi)) **2
                Case(G2);   xsq = xi .GIP. xi
            end select
        else
            xsq = ZERO
        end if
    end if

    IF ( C%UseStep ) then       ! ( norm of xi-xim1 ) ^2

        IF ( PRESENT(xim1) .and. PRESENT(xi)  ) then
            Select CASE ( C%TheNorm)
                Case(L1);   diffsq = SUM(abs(xi-xim1))    **2
                Case(L2);   diffsq = (xi-xim1) .IP.  (xi-xim1)
                Case(Linf); diffsq = maxval(abs(xi-xim1)) **2
                Case(G2);   diffsq = (xi-xim1) .GIP. (xi-xim1)
            end select
        else
            Test_Done = false
            goto 900
        end if
    end if

    IF (C%TraceTerm) then
        call Indent( id, C%TermTraceUnit, level )
        write(C%TermTraceUnit,999) eps
    end if

    Pass = true
    IF ( C%UseGrad ) then
        passthis = gsq <= (eps*C%NormGatX0)**2
        Pass     = Pass .and.  passthis
        IF (C%TraceTerm) then
            call Indent( id, C%TermTraceUnit, level )
            write(C%TermTraceUnit,998) &
                passthis,'(grad) gsq = ', gsq, ' NormGatX0= ',C%NormGatX0
        end if
    end if

    IF ( C%UseStep .and. (Pass .or. C%TraceTerm) ) then
        passthis = diffsq <= eps**2 * max(ONE,xsq)
        Pass     = Pass .and.  passthis
        IF (C%TraceTerm) then
            call Indent( id, C%TermTraceUnit, level )
            write(C%TermTraceUnit,998) &
                passthis, '(step) diffsq= ', diffsq, '  xsq= ', xsq
        end if
    end if

    IF ( C%UseShanno .and. (Pass .or. C%TraceTerm) ) then
        passthis = gsq <= (eps*C%NormGatX0)**2 * max(ONE,xsq)
        Pass     = Pass .and.  passthis
        IF (C%TraceTerm) then
            call Indent( id, C%TermTraceUnit, level )
            write(C%TermTraceUnit,998)  passthis, &
               '(shxg) g = ', gsq, '  xsq= ',xsq, '  NormGatX0= ',C%NormGatX0
        end if
    end if

    IF ( C%UseFunc .and. (Pass .or. C%TraceTerm) ) then
        passthis = abs(Fx) <= eps * abs(C%FatX0)
        Pass     = Pass .and.  passthis
        IF (C%TraceTerm) then
            call Indent( id, C%TermTraceUnit, level )
            write(C%TermTraceUnit,998) &
                passthis, '(func) fx = ', fx, '  fx0= ', C%FatX0
        end if
    end if

    Test_Done = pass

900 return

! FORMATS:

998 format ( ' Pass= ', l1, 3(a, g8.3) )
999 format ( ' eps = ', g8.3 )

end Function Test_Done

end Module TestDone
! <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> support.f90
MODULE  Support ! Support routines for minimization -'USE'ed in module MinimizeF

    USE Print
    USE EvaluateF
    USE TestDone
    USE FScale

                         Implicit NONE
    PRIVATE
    !------              -------------!

    PUBLIC ::   Print_Iterate,  &
                Evaluate_f,     &
                Test_Done,      &
                F_Scale

end Module Support
! <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> min_codes.f90
MODULE Min_Codes        ! Simulation of Pascal enumerated types

    !---
    ! This provides a facility for selecting multiple cases, when there
    ! are more than 2, i.e. when logical variables are not suitable.
    !
    ! The codes may be accessed with a statement
    !
    !   USE Min_Codes
    !
    ! A specific code, e.g. Resume, may be accessed as in
    !
    !   USE Min_Codes, only : Resume
    !
    ! For each group of codes, which correspond to the cases possible
    ! for some situation , there is a subroutine Str_*(i) which will return
    ! a string corresponding to the current value of i. For example,
    ! Str_Entrystate(Resume), which is in fact Str_Entrystate(7), will
    ! return the string 'Resume'.
    !
    ! The subroutine Control_Codes will print the entry status and the values
    ! of the minimization control codes that have been set.
    !
    ! The subroutine Error_Codes will print the completion status if an error
    ! is detected.  If bad arguments have been provided, the routine will also
    ! specify the arguments that are in error.
    !
    !------------------------------------------------------------------------

    USE   Precision, only : short

                         Implicit NONE
    PRIVATE
    !-----               -------------!

    PUBLIC  ::  Str_EntryState,  &
                Str_ExitState,   &
                Str_ErrorCodes,  &
                Str_Method,      &
                Str_DoInterp,    &
                Str_StartAlpha,  &
                Str_StartStep,   &
                Str_UpdateForm,  &
                Str_ScaleGamma,  &
                Str_HTest,       &
                Str_SetH0

    !------------------------------------------------------------------------
    !Str_EntryState

    Integer(short), PARAMETER, PUBLIC   :: & ! Entry Status of minimization.

        Normal          = 0,            & ! Usual case, no RC, no F or G
        NormalWithFG    = 1,            & ! No RC, but F, G at x0 given
        RevCommStart    = 2,            & ! Start from scratch with RC
        RevCommRestart  = 3,            & ! Reentry for RC: continue
        RevCommNoF      = 4,            & ! Reentry for RC: F not available
        RevCommNoG      = 5,            & ! Reentry for RC: G not available
        RevCommNoForG   = 6,            & ! Reentry for RC: F & G not available
        Resume          = 7               ! Resume a checkpointed run

    !------------------------------------------------------------------------
    !Str_ExitState

    Integer(short), PARAMETER, PUBLIC   :: & ! Completion Status of minimization

        Done            = 0,            & ! Normal Completion
        RevCommF        = 1,            & ! RC: compute F
        RevCommG        = 2,            & ! RC: compute G
        RevCommFandG    = 3,            & ! RC: compute F and G
        StorageError    = 4,            & ! Quit: storage request error
        InitialMin      = 5,            & ! Quit: initial point is min
        InitialUndefd   = 6,            & ! Quit: f undefd at initial point
        BadInput        = 7,            & ! Quit: bad argument; see Error
        LSFail          = 8,            & ! Quit: line search failed
        NoDescent       = 9,            & ! Quit: non descent direction
        ExcessFEvals    = 10,           & ! Quit: too many f evaluations
        InvalidM        = 11,           & ! Quit: m=0 invalid with ProductForm
        AbortMin        = 12              ! Abort requested by Evaluate_f

    !------------------------------------------------------------------------
    !Str_ErrorCodes

    Integer(short), PARAMETER, PUBLIC   :: & ! Error codes regarding input

        BadN            = 0,            & ! n must be 2 or more
        BadAcc          = 1,            & ! accuracy must be positive
        BadState        = 2,            & ! Unacceptable state
        BadMemory       = 3,            & ! memory must be nonnegative
        BadEvalLim      = 4,            & ! limit must be nonnegative
        BadFreq         = 5,            & ! print frequency must be nonnegative
        BadCheckPoint   = 6,            & ! chkpt frequency must be nonnegative
        BadCheckOpen    = 7,            & ! error opening/reading checkpnt file
        BadCheckUnit    = 8,            & ! unit must be non-negative integer
        BadMethod       = 9,            & ! no such method defined
        BadCombination  = 10,           & ! productform not used with SD or CG
        BadTerms        = 11,           & ! must be non-negative integer
        BadDeriv        = 12,           & ! no such derivative mode
        BadSysMemory    = 13,           & ! test memory must be non-negative
        BadScaleF       = 14,           & ! scale must be positive integer
        BadExpense      = 15,           & ! expense must be positive integer
        BadEvalUnit     = 16,           & ! unit must be non-negative integer
        BadPrintUnit    = 17,           & ! unit must be non-negative integer
        BadNorm         = 18,           & ! no such kind of norm
        BadTermUnit     = 19,           & ! unit must be non-negative integer
        BadInterp       = 20,           & ! bad interpolation strategy
        BadAlpha        = 21,           & ! bad method for first alpha
        BadGamma        = 22,           & ! bad gamma strategy
        BadHTest        = 23,           & ! bad restart test type
        BadUpdate       = 24,           & ! bad update choice
        BadStep         = 25,           & ! bad step length for CG alpha
        BadRho          = 26,           & ! rho strictly positive
        BadBeta         = 27,           & ! beta between zero and one, inclusive
        BadSetH0        = 28              ! no such kind of initial H0 setting

    !------------------------------------------------------------------------
    !Str_Method

    Integer(short), PARAMETER, PUBLIC   ::      & ! Choice of method

        SD              = 0,            & ! Use steepest descent steps
        CG              = 1,            & ! Use H0 and conjugate gradient
        ConMin          = 2,            & ! Use Shanno's 2-step CONMIN
        FixTerms        = 3,            & ! Use given number of terms
        Variable        = 4,            & ! Variable number of terms
        Available       = 5,            & ! Alg. according to storage available
        Dynamic         = 6,            & ! Use dynamic strategy based on time
        QN              = 7               ! Use QN update matrix

    !------------------------------------------------------------------------
    !Str_DoInterp

    Integer(short), PARAMETER, PUBLIC   ::      & ! Interpolation control

        Every           = 0,   & ! on every step, force quad. interpolation
        On1             = 1,   & ! just on d[m+1] and later, force quad. int.
        On2             = 2,   & ! just on d[m+2] and later, force quad. int.
        On3             = 3,   & ! just on d[m+3] and later, force quad. int.
        Never           = 4      ! never force quadratic interpolation

    !------------------------------------------------------------------------
    !Str_StartAlpha

    Integer(short), PARAMETER, PUBLIC   ::      & ! Initial alpha strategy

        NeverQN      = 0,   & ! never use alpha=1 strategy
        Before1QN    = 1,   & ! start with alpha=1 BEFORE pt x[m+1] found
        Before2QN    = 2,   & ! start with alpha=1 BEFORE pt x[m+2] found
        Before3QN    = 3,   & ! start with alpha=1 BEFORE pt x[m+3] found
        AlwaysQN     = 4      ! always start with alpha=1

    !------------------------------------------------------------------------
    !Str_StartStep

    Integer(short), PARAMETER, PUBLIC   ::  & ! When initial alpha size /= 1

        Fletcher  = 0,  & ! Fletcher's choice for CG step
        Powell    = 1     ! Powell's choice for CG step

    !------------------------------------------------------------------------
    !Str_UpdateForm

    Integer(short), PARAMETER, PUBLIC   ::      & ! Form of maintaining H

        SumForm         = 0,    & ! Buckley LeNir method
        ProductForm     = 1,    & ! Nocedal's approach
        FactoredForm    = 2       ! Powell's factored ZZ^T

    !------------------------------------------------------------------------
    !Str_ScaleGamma

    Integer(short), PARAMETER, PUBLIC   ::      & ! Use gamma for step scaling

        NoGammaScale    = 0,    & ! don't use this strategy
        GammaFirst      = 1,    & ! use it on first QN step only
        GammaAll        = 2       ! use it on all QN steps

    !------------------------------------------------------------------------
    !Str_HTest

    Integer(short), PARAMETER, PUBLIC   ::      & ! Restart test

        NoRestart       = 0,  & ! No restarts implemented
        UseI            = 1,  & ! Use the original Powell test
        UseH            = 2     ! Use the test with metric H

    !------------------------------------------------------------------------
    !Str_SetH0

    Integer(short), PARAMETER, PUBLIC   ::      & ! Form of setting H

        Ident           = 0,    & ! Identity matrix
        Diagonal        = 1,    & ! Diagonal matrix
        Computed1       = 2,    & ! First computed matrix    See H0v_Multiply
        Computed2       = 3,    & ! Second computed matrix   See H0v_Multiply
        Computed3       = 4       ! Third computed matrix    See H0v_Multiply

    !------------------------------------------------------------------------

    Integer(short), PARAMETER, PUBLIC   ::      & ! Form of allocating space

        AllocNext       = 1,    & ! Allocate a term of H
        AllocHi         = 2,    & ! Allocate Hi
        AllocH0         = 3,    & ! Allocate H0
        AllocTemp       = 4,    & ! Allocate Temp
        AllocU          = 5       ! Allocate u

    !------------------------------------------------------------------------


CONTAINS


FUNCTION Str_EntryState(i)

! ARGUMENTS:
            Integer(short) :: i

! LOCAL DECLARATIONS:

    Character*14, PARAMETER       :: str(Normal:Resume) = (/   &
                                         'Normal        ',     &
                                         'NormalWithFG  ',     &
                                         'RevCommStart  ',     &
                                         'RevCommRestart',     &
                                         'RevCommNoF    ',     &
                                         'RevCommNoG    ',     &
                                         'RevCommNoForG ',     &
                                         'Resume        ' /)

    Character(len_trim(str(i)))   :: Str_EntryState

! DESCRIPTION: This function returns the specified value of the entry state.

! EXECUTION:
            Str_EntryState = str(i)
            return

end Function Str_EntryState

FUNCTION Str_ExitState(i)

! ARGUMENTS:
            Integer(short) :: i

! LOCAL DECLARATIONS:

    Character*13, PARAMETER       :: str(Done:AbortMin) = (/   &
                                         'Done         ',     &
                                         'RevCommF     ',     &
                                         'RevCommG     ',     &
                                         'RevCommFandG ',     &
                                         'StorageError ',     &
                                         'InitialMin   ',     &
                                         'Initialundefd',     &
                                         'BadInput     ',     &
                                         'LSFail       ',     &
                                         'NoDescent    ',     &
                                         'ExcessFEvals ',     &
                                         'InvalidM     ',     &
                                         'AbortMin     '  /)

    Character(len_trim(str(i)))   :: Str_ExitState

! DESCRIPTION: This function returns the specified value of the exit state.

! EXECUTION:
            Str_ExitState = str(i)
            return

end Function Str_ExitState


FUNCTION Str_ErrorCodes(i)

! ARGUMENTS:
            Integer(short) :: i

! LOCAL DECLARATIONS:

    Character*14, PARAMETER       :: str(BadN:BadSetH0) = (/   &
                                         'BadN          ',     &
                                         'BadAcc        ',     &
                                         'BadState      ',     &
                                         'BadMemory     ',     &
                                         'BadEvalLim    ',     &
                                         'BadFreq       ',     &
                                         'BadCheckPoint ',     &
                                         'BadCheckOpen  ',     &
                                         'BadCheckUnit  ',     &
                                         'BadMethod     ',     &
                                         'BadCombination',     &
                                         'BadTerms      ',     &
                                         'BadDeriv      ',     &
                                         'BadSysMemory  ',     &
                                         'BadScaleF     ',     &
                                         'BadExpense    ',     &
                                         'BadEvalUnit   ',     &
                                         'BadPrintUnit  ',     &
                                         'BadNorm       ',     &
                                         'BadTermUnit   ',     &
                                         'BadInterp     ',     &
                                         'BadAlpha      ',     &
                                         'BadGamma      ',     &
                                         'BadHTest      ',     &
                                         'BadUpdate     ',     &
                                         'BadStep       ',     &
                                         'BadRho        ',     &
                                         'BadBeta       ',     &
                                         'BadSetH0      '  /)

    Character(len_trim(str(i)))   :: Str_ErrorCodes

! DESCRIPTION: This function returns the specified value of the error code.

! EXECUTION:
            Str_ErrorCodes = str(i)
            return

end Function Str_ErrorCodes


FUNCTION Str_Method(i)

! ARGUMENTS:
            Integer(short) :: i

! LOCAL DECLARATIONS:

    Character*9,  PARAMETER       :: str(SD:QN) =    (/   &
                                         'SD       ',     &
                                         'CG       ',     &
                                         'ConMin   ',     &
                                         'FixTerms ',     &
                                         'Variable ',     &
                                         'Available',     &
                                         'Dynamic  ',     &
                                         'QN       ' /)

    Character(len_trim(str(i)))   :: Str_Method

! DESCRIPTION: This function returns the specified value of Us%Method.

! EXECUTION:
            Str_Method = str(i)
            return

end Function Str_Method


FUNCTION Str_DoInterp(i)

! ARGUMENTS:
            Integer(short) :: i

! LOCAL DECLARATIONS:

    Character*5,  PARAMETER       :: str(Every:Never) = (/   &
                                         'Every',            &
                                         'On1  ',            &
                                         'On2  ',            &
                                         'On3  ',            &
                                         'Never'        /)

    Character(len_trim(str(i)))   :: Str_DoInterp

! DESCRIPTION: This function returns the specified value of Us%DoInterpolation.

! EXECUTION:
            Str_DoInterp = str(i)
            return

end Function Str_DoInterp


FUNCTION Str_StartAlpha(i)

! ARGUMENTS:
            Integer(short) :: i

! LOCAL DECLARATIONS:

    Character*9,  PARAMETER       :: str(NeverQN:AlwaysQN) = (/   &
                                         'NeverQN  ',             &
                                         'Before1QN',             &
                                         'Before2QN',             &
                                         'Before3QN',             &
                                         'AlwaysQN '         /)

    Character(len_trim(str(i)))   :: Str_StartAlpha

! DESCRIPTION: This function returns the specified value of Us%StartAlpha.

! EXECUTION:
            Str_StartAlpha = str(i)
            return

end Function Str_StartAlpha


FUNCTION Str_StartStep(i)

! ARGUMENTS:
            Integer(short) :: i

! LOCAL DECLARATIONS:

    Character*8,  PARAMETER       :: str(Fletcher:Powell) = (/   &
                                         'Fletcher',             &
                                         'Powell  '         /)

    Character(len_trim(str(i)))   :: Str_StartStep

! DESCRIPTION: This function returns the specified value of Us%StartStep.

! EXECUTION:
            Str_StartStep = str(i)
            return

end Function Str_StartStep


FUNCTION Str_UpdateForm(i)

! ARGUMENTS:
            Integer(short) :: i

! LOCAL DECLARATIONS:

    Character*12, PARAMETER       :: str(SumForm:FactoredForm) = (/   &
                                         'SumForm     ',              &
                                         'ProductForm ',              &
                                         'FactoredForm'          /)

    Character(len_trim(str(i)))   :: Str_UpdateForm

! DESCRIPTION: This function returns the specified value of Us%UpdateForm.

! EXECUTION:
            Str_UpdateForm = str(i)
            return

end Function Str_UpdateForm


FUNCTION Str_ScaleGamma(i)

! ARGUMENTS:
            Integer(short) :: i

! LOCAL DECLARATIONS:

    Character*12, PARAMETER       :: str(NoGammaScale:GammaAll) = (/   &
                                         'NoGammaScale',               &
                                         'GammaFirst  ',               &
                                         'GammaAll    '           /)

    Character(len_trim(str(i)))   :: Str_ScaleGamma

! DESCRIPTION: This function returns the specified value of Us%ScaleGamma.

! EXECUTION:
            Str_ScaleGamma = str(i)
            return

end Function Str_ScaleGamma


FUNCTION Str_HTest(i)

! ARGUMENTS:
            Integer(short) :: i

! LOCAL DECLARATIONS:

    Character*9,  PARAMETER       :: str(NoRestart:UseH) = (/   &
                                         'NoRestart',           &
                                         'UseI     ',           &
                                         'UseH     '       /)

    Character(len_trim(str(i)))   :: Str_HTest

! DESCRIPTION: This function returns the specified value of Us%HTest.

! EXECUTION:
            Str_HTest = str(i)
            return

end Function Str_HTest


FUNCTION Str_SetH0(i)

! ARGUMENTS:
            Integer(short) :: i

! LOCAL DECLARATIONS:

    Character*9,  PARAMETER       :: str(Ident:Computed3) = (/   &
                                         'Ident    ',            &
                                         'Diagonal ',            &
                                         'Computed1',            &
                                         'Computed2',            &
                                         'Computed3'        /)

    Character(len_trim(str(i)))   :: Str_SetH0

! DESCRIPTION: This function returns the specified value of Us%SetH0.

! EXECUTION:
            Str_SetH0 = str(i)
            return

end Function Str_SetH0


end Module Min_Codes
! <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> min_states.f90
MODULE Min_States   ! the type definitions for control information.

    USE Precision, only  : long, short, stnd

                         Implicit NONE
    PRIVATE
    !-----               -------------!

    PUBLIC HTerm,       &
           HMatrix,     &
           UserDefined, &
           SharedVars,  &
           TraceList,   &
           SearchVals,  &
           MinLocal,    &
           NumErrs

    Integer(long), PARAMETER    :: NumErrs = 10

    TYPE HTerm
        Real (stnd),   POINTER  :: Data(:)
        Type (HTerm),  POINTER  :: next,        &
                                   prev
    end type

    TYPE HMatrix                ! structure of the QN matrix

        Type (HTerm),  POINTER  :: FirstTerm,   &
                                   LastTerm,    &
                                   NextTerm
        Real (stnd),   POINTER  :: H0(:),       &
                                   Hi(:),       &
                                   Temp(:),     & ! used in product and updateh
                                   u(:)           ! used in factored module
        Integer (long)             nTerms,      &
                                   mTerms

        ! Note that the matrix H may be:
        !  o  a symmetric n x n matrix, stored as a vector of its upper half
        !     in row order, and pointed to by Hi;
        !  o  a linked list of terms which define H as an update of H0.  Then
        !     H0 is stored as a vector which defines a diagonal matrix; it is
        !     given as a pointer.  FirstTerm points at the first term of the
        !     list, once it has been allocated.  NextTerm points at the space
        !     allocated for the next term in the list until it is linked into
        !     the list.  LastTerm always points to the last term in the
        !     sequence.  Each term of the list contains a one-dimensional array
        !     pointed at by Data.

    end type

    TYPE UserDefined

        Integer(short)  ::              &
                Method,                 &
                DoInterpolation,        &
                StartAlpha,             &
                ScaleGamma,             &
                HTest,                  &
                UpdateForm,             &
                StartStep,              &
                SetH0

        Integer(long)   ::              &
                CheckPoint,             &
                SystemMemory

        Real(stnd) ::                   &
                DecreaseInF,            &
                rho,                    &
                beta,                   &
                ParH0

        Logical ::                      &
                ScaleColumns,           &
                RelativeToF0,           &
                RelativeToG0,           &
                QuadInterpolation,      &
                IgnoreInterval,         &
                CountFromRestart
    end type

    TYPE SharedVars
        Integer (short) ::              &
                MethodInUse,            &
                error(0:NumErrs)
        Integer (long)  ::              &
                Memory,                 &
                MemoryUsed,             &
                RestartCt,              &
                RestartPt,              &
                ForceCt,                &
                ncalls,                 &
                ct,                     &
                it,                     &
                ixstart,                &
                ixnu,                   &
                ixeta,                  &
                ixs,                    &
                ixu,                    &
                ixy,                    &
                ixc,                    &
                ixend,                  &
                ixleng
        Logical         ::              &
                QNpart,                 &
                DoRestart,              &
                DoForceRestart,         &
                SteepDStep,             &
                LimMemory,              &
                DoneInterpolation,      &
                LSFinished,             &
                ValidF
        Real (stnd)     ::              &
                Accuracy,               &
                eta,                    &
                IterationTime
    end type

    TYPE TraceList  ! for trace control. Any change: see also internal
                    ! subroutine in Minimize_f.

        Integer (short) ::              &
                u,                      & ! unit
                level
        Logical         ::              &
                input,                  &
                flow,                   &
                steptypes,              &
                lsalpha,                &
                lsreal,                 &
                lsflow,                 &
                update,                 &
                values,                 &
                vectors,                &
                XandD,                  &
                cubic
    end type

    TYPE SearchVals  ! for Line_Search

        Logical ::                      &
                GoodPt,                 &
                AlphaLBdd,              &
                AlphaUBdd

        Real(stnd) ::                   &
                Currmg,                 &
                LwBd,                   &
                fLbd,                   &
                dTgLBd,                 &
                UpBd
    end type

    TYPE MinLocal

        Integer(long)   ::              &
                CheckNext,              &
                MemoryNeeded,           &
                n

        Real(stnd) ::                   &
                eps,                    &
                nrmg,                   &
                nrmd,                   &
                alpha,                  &
                fp,                     &
                dgp,                    &
                ap,                     &
                fmin,                   &
                flast,                  &
                glast,                  &
                dglast,                 &
                dg0,                    &
                nrmx

        Logical ::                      &
                FirstEval,              &
                cold,                   &
                CheckFlag,              &
                UnknownM,               &
                All_Allocated,          &
                NoPrint
    end type

end Module Min_States
! <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> min_defaults.f90
MODULE  Min_Defaults

    USE Precision,  only  : long, short, stnd
    USE Reals,      only  : fifth, one, zero
    USE Min_Codes,  only  : SumForm,     Dynamic,     Never,   AlwaysQN, &
                            GammaFirst,  UseI,        Powell,  Ident
    USE Min_States, only  : UserDefined, TraceList
    USE True_False

                         Implicit NONE
    PRIVATE
    !------              -------------!

    PUBLIC  :: DefaultUserDefined, DefaultTraces,  &
               CheckFile, CheckFileLen, CheckUnit, &
               MaxUpdates

    Character*(*)   , PARAMETER          :: CheckFile     = 'ChkPt'

    Integer (short) , PARAMETER          :: CheckFileLen  = 100, &
                                            CheckUnit     = 9

    Integer (long)  , PARAMETER          :: MaxUpdates    = 7

    Integer (short) , PARAMETER ::      &

        Method          = Dynamic,      &
        DoInterpolation = Never,        &
        StartAlpha      = AlwaysQN,     &
        ScaleGamma      = GammaFirst,   &
        HTest           = UseI,         &
        UpdateForm      = SumForm,      &
        StartStep       = Powell,       &
        SetH0           = Ident

    Integer (long) , PARAMETER ::       &

        CheckPoint      = 0,            &
        SystemMemory    = 0

    Real(stnd), PARAMETER ::            &

        DecreaseInF     = -ONE,         &
        rho             = FIFTH,        &
        beta            = ONE,          &
        ParH0           = ZERO

    Logical, PARAMETER ::               &

        ScaleColumns      =  false ,    &
        RelativeToF0      =  false ,    &
        RelativeToG0      =  false ,    &
        QuadInterpolation =  true,      &
        IgnoreInterval    =  false ,    &
        CountFromRestart  =  false

    Type (UserDefined)  ::  DefaultUserDefined = &

        UserDefined (                       &
                        Method,             &
                        DoInterpolation,    &
                        StartAlpha,         &
                        ScaleGamma,         &
                        HTest,              &
                        UpdateForm,         &
                        StartStep,          &
                        SetH0,              &
                        CheckPoint,         &
                        SystemMemory,       &
                        DecreaseInF,        &
                        rho,                &
                        beta,               &
                        ParH0,              &
                        ScaleColumns,       &
                        RelativeToF0,       &
                        RelativeToG0,       &
                        QuadInterpolation,  &
                        IgnoreInterval,     &
                        CountFromRestart    &
                  )

    Integer(short), PARAMETER ::            &

        TRunit  = 6,                        &
        TRlevel = 0

    Logical, PARAMETER ::               &

        TRinput         = false,        &
        TRflow          = false,        &
        TRsteptypes     = false,        &
        TRlsalpha       = false,        &
        TRlsreal        = false,        &
        TRlsflow        = false,        &
        TRupdate        = false,        &
        TRvalues        = false,        &
        TRvectors       = false,        &
        TRXandD         = false,        &
        TRcubic         = false


    Type (TraceList)    :: DefaultTraces =      &  ! for trace control
          TraceList (   TRunit,         &
                        TRlevel,        &
                        TRinput,        &
                        TRflow,         &
                        TRsteptypes,    &
                        TRlsalpha,      &
                        TRlsreal,       &
                        TRlsflow,       &
                        TRupdate,       &
                        TRvalues,       &
                        TRvectors,      &
                        TRXandD,        &
                        TRcubic         &
                   )

end Module  Min_Defaults
! <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> systemstate.f90
MODULE SystemState     ! 'USE'ed in modules Minimize, MinimizeF, CheckPoint,
                       !                    and Restart.

    USE Precision, only  :  stnd
    USE Min_States
    USE Supp_States

                         Implicit NONE
    PRIVATE
    !-----               -------------!

    PUBLIC MinimizeState

    TYPE MinimizeState

        Type(UserDefined)       :: User
        Type(SharedVars)        :: Shared
        Type(SearchVals)        :: LSSave
        Type(MinLocal)          :: Local

        Type(EvalState)         :: Eval
        Type(EvalCounts)        :: EvalCts
        Type(EvalErrors)        :: EvalErs
        Type(PrintState)        :: Print
        Type(PrintValues)       :: PrVals
        Type(TermState)         :: Term
        Type(TermValues)        :: TermVals

        Type(TraceList)         :: Trace

        Real(stnd), POINTER     :: d   (:),     &
                                   xx  (:),     &
                                   gg  (:)
        Type(HMatrix)           :: H

    end type

end Module SystemState
! <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> checkpoint.f90
MODULE CheckPoint     ! 'USE'ed in module MinimizeF

    USE Precision,        only  : stnd, long, short
    USE SystemState,      only  : MinimizeState
    USE General,          only  : Entering, Leaving
    USE Min_States,       only  : HTerm
    USE Min_Defaults,     only  : CheckFile, CheckFileLen, CheckUnit
    USE True_False

                         Implicit NONE
    PRIVATE
    !------              -------------!

    PUBLIC  ::  Check_Point

CONTAINS

SUBROUTINE Check_Point (  x, fx, g, State, C, iteration, &

                                              File,      & ! Optional arguments
                                              OutUnit )

! ARGUMENTS:

    Real (stnd),          intent(IN)             :: x(:),        &
                                                    fx,          &
                                                    g(size(x))
    Integer (short),      intent(IN)             :: State
    Integer (long),       intent(IN)             :: iteration
    Type (MinimizeState), intent(INOUT)          :: C

    Character *(*),       intent(IN), OPTIONAL   :: File
    Integer (short),      intent(IN), OPTIONAL   :: OutUnit

! DESCRIPTION:
!
!     Given the arguments and state vector for routine Minimize_f
!     (except FName), this routine writes these values to a file to guard
!     against losing information in the event of a system crash.  Note that
!     part of the output consists of the data in a linked list.
!
!     It accepts as optional arguments a file name and a unit number.
!
!     In order to avoid the possibility of a crash during checkpointing, it
!     uses two output files, and writes to them alternately. The first is
!     indicated by 'a' being appended to the file name, which is done when
!     C%Local%CheckFlag is true, and the second by an appended 'b', when
!     C%Local%CheckFlag is false.  Note that the routine automatically appends
!     the letters 'a' or 'b', and so the user should not include them in the
!     file name if it is specified.

! PARAMETERS:

    Character *(*), PARAMETER               :: id     = 'ChkPt'

! LOCAL DECLARATIONS:

    Integer (short)                         :: unit
    Integer (long)                          :: lent

    Character (Len=len(id)+2+C%Trace%level) :: pre

    Type (HTerm),      POINTER              :: term

    Character * (CheckFileLen)              :: Outfile

    Character * 1                           :: suffix

! EXECUTION:

    pre =  Entering ( id, C%Trace%flow, C%Trace%u, C%Trace%level )

    IF ( iteration == C%Local%CheckNext ) then   ! Checkpoint this iteration.

        ! Open appropriate file for output.

        IF ( PRESENT(OutUnit) ) then
            unit = OutUnit
        else
            unit = CheckUnit
        end if

        IF ( C%Local%CheckFlag ) then
           suffix = 'a'
        else
           suffix = 'b'
        end if

        IF ( PRESENT(File) ) then
           lent = len_trim(File)
           Outfile = File(1:lent) // suffix        ! User-supplied file name
        else
           lent = len_trim(CheckFile)
           Outfile = CheckFile(1:lent) // suffix   ! Default file name
        end if

        open ( unit, file    =  Outfile,      & ! access appropriate file
                     form    = 'unformatted', &
                     status  = 'unknown',     &
                     position= 'rewind'       )

        ! Write values.

        write ( unit ) x, fx
        write ( unit ) g, State

        write ( unit ) C%Trace
        write ( unit ) C%User
        write ( unit ) C%Shared
        write ( unit ) C%LSSave
        write ( unit ) C%Local
        write ( unit ) C%Eval
        write ( unit ) C%EvalCts
        write ( unit ) C%EvalErs
        write ( unit ) C%Print
        write ( unit ) C%PrVals
        write ( unit ) C%Term
        write ( unit ) C%TermVals
        write ( unit ) C%d
        write ( unit ) C%xx
        write ( unit ) C%gg

        write ( unit ) C%H%nTerms
        write ( unit ) C%H%mTerms

        IF ( Associated(C%H%H0) ) then
            write ( unit ) true
            write ( unit ) C%H%H0
        else
            write ( unit ) false
        end if

        IF ( Associated(C%H%Hi) ) then
            write ( unit ) true
            write ( unit ) C%H%Hi
        else
            write ( unit ) false
        end if

        IF ( Associated(C%H%Temp) ) then
            write ( unit ) true
            write ( unit ) C%H%Temp
        else
            write ( unit ) false
        end if

        IF ( Associated(C%H%u) ) then
            write ( unit ) true
            write ( unit ) C%H%u
        else
            write ( unit ) false
        end if

        IF ( Associated(C%H%FirstTerm) ) then

            term => C%H%FirstTerm
            write ( unit ) term%Data
            term => term%next

            DO while (       Associated(term)  .and.           & ! linear list
                       .not. Associated(term,C%H%FirstTerm) )    ! circular list
                write ( unit ) term%Data
                term => term%next
            end do

        end if

        close ( unit )

    ! Prepare variables for the next checkpoint.

        C%Local%CheckFlag = .not. C%Local%CheckFlag

        C%Local%CheckNext = C%Local%CheckNext + C%User%CheckPoint

    end if

900 call Leaving( id, C%Trace%flow, C%Trace%u, C%Trace%level )

! FORMATS:  none.

! EXIT

    return

end Subroutine Check_Point

end Module CheckPoint
! <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> myallocate.f90
MODULE MyAllocate    ! 'USE'ed in modules MinimizeF, Initialize

    USE Precision,        only  : long, short, stnd
    USE Min_States,       only  : HMatrix, UserDefined, SharedVars, TraceList
    USE Min_Codes,        only  : AllocNext, AllocHi, AllocH0, AllocTemp, &
                                  AllocU, Diagonal
    USE General,          only  : Entering, Leaving

                         Implicit NONE
    PRIVATE
    !------              -------------!

    PUBLIC  ::  My_Allocate,   &
                My_Deallocate

CONTAINS

SUBROUTINE My_Allocate( size, type, enough, Us, Sh, Tr, H )

!   ARGUMENTS:

    Integer(long),     intent(IN)     :: size
    Integer(short),    intent(IN)     :: type
    Integer(short),    intent(INOUT)  :: enough
    Type(UserDefined), intent(IN)     :: Us
    Type(SharedVars),  intent(INOUT)  :: Sh
    Type(TraceList),   intent(INOUT)  :: Tr
    Type(HMatrix),     intent(INOUT)  :: H

!   DESCRIPTION:
!
!       This routine explicitly allocates required space for the
!       matrix H.  The specific allocation depends on the value of 'type'.
!       The amount to be allocated is specified by either the argument 'size'
!       or by the shared variables ixstart and ixend.
!
!       The variable SystemMemory provides a way for the user to set a limit
!       on the amount of memory to be used.  If SystemMemory is 0 (the default),
!       then the allocation will automatically be attempted and will succeed or
!       fail depending on how much memory the system has available.
!       If SystemMemory is positive, allocation will only be done if the
!       total memory used (including that needed for the current allocation)
!       is within the value specified by SystemMemory.  This is true even if
!       the available memory exceeds the value of SystemMemory.
!       The variable MemoryUsed keeps track of the amount of memory allocated.

! PARAMETERS:

    Character *(*), PARAMETER           :: id     = 'MyAlloc'

! LOCAL DECLARATIONS:

    Character (Len=len(id)+2+Tr%level)  :: pre

!   EXECUTION:

    pre =  Entering ( id, Tr%flow, Tr%u, Tr%level )

    IF ( Us%SystemMemory /= 0 ) Sh%MemoryUsed = Sh%MemoryUsed + size

    IF ( Us%SystemMemory == 0  .or.  Sh%MemoryUsed <= Us%SystemMemory ) then
        Select CASE( type )
            Case( AllocNext )    ! Allocate update term
                Allocate( H%NextTerm )
                Allocate( H%NextTerm%Data(Sh%ixstart:Sh%ixend), STAT=enough )
            Case( AllocHi )      ! Allocate QN matrix
                Allocate( H%Hi(1:size), STAT=enough )
            Case( AllocH0 )      ! Allocate diagonal scaling matrix
                Allocate( H%H0(1:size), STAT=enough )
            Case( AllocTemp )    ! Allocate temporary vector
                Allocate( H%Temp(1:size), STAT=enough )
            Case( AllocU )       ! Allocate vector u for factored updates
                Allocate( H%u(1:size), STAT=enough )
        end select
    else
        Sh%MemoryUsed = Sh%MemoryUsed - size
        enough = 1
    end if

! EXIT:
    call Leaving ( id, Tr%flow, Tr%u, Tr%level )
    return

end Subroutine My_Allocate

SUBROUTINE My_Deallocate( Sh, Tr, H )

!   ARGUMENTS:

    Type(SharedVars),  intent(INOUT) :: Sh
    Type(TraceList),   intent(INOUT) :: Tr
    Type(HMatrix),     intent(INOUT) :: H

!   DESCRIPTION:
!
!       This routine explicitly deallocates space for the matrix H.
!

! PARAMETERS:

    Character *(*), PARAMETER           :: id     = 'MyDealloc'

! LOCAL DECLARATIONS:

    Integer(long)                       :: i
    Character (Len=len(id)+2+Tr%level)  :: pre

!   EXECUTION:

    pre =  Entering ( id, Tr%flow, Tr%u, Tr%level )

    Sh%MemoryUsed = 0

    IF ( Sh%LimMemory ) then
        DO i = 1, H%nTerms
            IF ( Associated( H%FirstTerm ) ) then
                H%NextTerm => H%FirstTerm%next
                Deallocate( H%FirstTerm%Data )
                Deallocate( H%FirstTerm )
                H%FirstTerm => H%NextTerm
            end if
        end do

        IF ( Associated( H%H0 ) ) Deallocate( H%H0 )

    else   ! QN case
        IF ( Associated( H%Hi ) ) Deallocate( H%Hi )
    end if

    IF ( Associated( H%Temp ) )  Deallocate( H%Temp )
    IF ( Associated( H%u ) )     Deallocate( H%u )

! EXIT:
    call Leaving ( id, Tr%flow, Tr%u, Tr%level )
    return

end Subroutine My_Deallocate

end Module MyAllocate
! <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> control.f90
MODULE Control     !  'USE'ed in module MinimizeF

    USE Precision,        only  : short
    USE Min_States,       only  : UserDefined, TraceList
    USE Min_Codes

                         Implicit NONE
    PRIVATE
    !------              -------------!

    PUBLIC  ::  Control_Codes

CONTAINS

SUBROUTINE Control_Codes( EntryState, Us, Tr )

! ARGUMENTS:

    Integer (short),      intent(IN)            :: EntryState
    Type (UserDefined),   intent(IN)            :: Us
    Type (TraceList),     intent(IN)            :: Tr

! DESCRIPTION:
!
!     This routine will write out the meanings of the variable EntryState
!     and the integer control codes of Us.

! EXECUTION:

    write(Tr%u,800) ' Status on entry is ' // Str_EntryState( EntryState )

    write(Tr%u,800) ' Integer control values:'

    write(Tr%u,800) ' Method          = ' // Str_Method( Us%Method )
    write(Tr%u,800) ' DoInterpolation = ' // Str_DoInterp( Us%DoInterpolation )
    write(Tr%u,800) ' StartAlpha      = ' // Str_StartAlpha( Us%StartAlpha )
    write(Tr%u,800) ' StartStep       = ' // Str_StartStep( Us%StartStep )
    write(Tr%u,800) ' UpdateForm      = ' // Str_UpdateForm( Us%UpdateForm )
    write(Tr%u,800) ' ScaleGamma      = ' // Str_ScaleGamma( Us%ScaleGamma )
    write(Tr%u,800) ' HTest           = ' // Str_HTest( Us%HTest )
    write(Tr%u,800) ' SetH0           = ' // Str_SetH0( Us%SetH0 )

! FORMATS:

   800 format ( a )

! EXIT:
    return

end Subroutine Control_Codes

end Module Control
! <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> cubic.f90
MODULE Cubic     ! 'USE'ed in module LineSearch

    USE Precision,     only : stnd, extd
    USE Min_States,    only : Tracelist
    USE Reals,         only : zero, one, two, three
    USE Num_Constants, only : MachHuge
    USE General,       only : Entering, Leaving
    USE True_False

                         Implicit NONE
    PRIVATE
    !------              -------------!

    PUBLIC  ::  Cubic_Interpolate

CONTAINS

SUBROUTINE Cubic_Interpolate            &

            ( a, fa, fpa, b, fb, fpb, left, right, &
              x, ExactInt, Tr, IgnoreInterval      )


! ARGUMENTS:

    Real (stnd),     intent(IN)            :: a, fa, fpa,  &
                                              b, fb, fpb,  &
                                              left, right
    Real (stnd),     intent(OUT)           :: x
    Logical,         intent(OUT)           :: ExactInt

    Type(TraceList), intent(INOUT)         :: Tr

    Logical,         intent(IN), OPTIONAL  :: IgnoreInterval

! DESCRIPTION:
!
!        Given the points a and b, along with the function values
!     fa and fb and slopes fpa and fpb at each point, this routine
!     finds the point x  at which the cubic fitted to the data
!     has its minimum.
!        The values left and right define an interval.  If there is no minimum
!     or if it lies outside the interval, x is returned as one of the end
!     points, as appropriate.  ExactInt is returned as true if the value x
!     returned is equal to that obtained from the cubic interpolation.
!        If IgnoreInterval is present and true, the interval [left,right] is
!     ignored; it can be thought of as being from 0 to + infinity, except
!     that if the interpolated value is negative, the left boundary of the
!     interval is used, regardless of the value of IgnoreInterval.  In the
!     one case where ignoring the interval is appropriate, i.e. for a
!     quadratic function, this should never happen.
!        The interpolation is computed following details given by Lemarechal.
!
! PARAMETERS:

    Character *(*), PARAMETER           :: id     = 'Cubic'

! LOCAL DECLARATIONS:

    Character (Len=len(id)+2+Tr%level)  :: pre

    Logical     :: extreme, order, bbigger, pbigger, ignore

    Real (stnd) :: p, disc, aleft, aright
    Real (stnd) :: sgn, apr, bpr, num, xc, biggest

! EXECUTION:

    pre =  Entering ( id, Tr%flow, Tr%u, Tr%level )

    IF ( PRESENT(IgnoreInterval) ) then
        ignore = IgnoreInterval
    else
        ignore = false
    end if

    aleft  = min(left, right)
    aright = max(left, right)

    IF ( Tr%cubic ) then
       write (Tr%u,801) pre//' a= ', a, '  fa= ', fa, '  fpa= ', fpa
       write (Tr%u,801) pre//' b= ', b, '  fb= ', fb, '  fpb= ', fpb
       write (Tr%u,802) pre//' interval [',aleft,',',aright,']'
    end if

    extreme = false
    order   = left <= right  .eqv.   a <= b
    sgn     = sign(ONE,b-a)

    IF (Tr%cubic) write(Tr%u,803) pre//' order=',order,'  sgn=',sgn

    EQUAL: &
    IF ( a == b ) then
        IF (Tr%cubic) write(Tr%u,800) pre//' points equal.'
        x        = a
        ExactInt = false
    else

        p  = real(fpa,extd) + real(fpb,extd) &
           - real(THREE,extd)*real(fb-fa,extd)/real(b-a,extd)

        IF ( sign(ONE,fpb) /= sign(ONE,fpa) ) then
            IF ( p /= ZERO ) then
                disc = real(ONE,extd) - (real(fpa,extd)/p)*(real(fpb/p,extd))
                disc = abs(p)*sqrt(disc)
            else
                disc = sqrt(abs(real(fpa,extd)))*sqrt(abs(real(fpb,extd)))
            end if
        else
            IF (Tr%cubic) write(Tr%u,800) pre//' sign(fpa)=sign(fpb).'
            biggest = max(abs(fpa),abs(fpb),abs(p))
            bbigger = biggest == abs(fpb)
            pbigger = biggest == abs( p )
            IF(Tr%cubic)write(Tr%u,802) pre//' p= ', p, '  biggest= ', biggest
            IF(Tr%cubic)write(Tr%u,804) pre//' MachRtHuge= ', sqrt(MachHuge)
            IF (biggest <= sqrt(MachHuge)) then
                disc = real(p**2,extd) - real(fpa,extd)*real(fpb,extd)
                IF (Tr%cubic) write(Tr%u,802) pre//' p = ', p, '  disc=', disc
            else if ( pbigger ) then
                disc = real(p,extd)-(real(fpb,extd)/real(p,extd))*real(fpa,extd)
            else if ( bbigger ) then
                disc = (real(p,extd)/real(fpb,extd))*real(p,extd)-real(fpa,extd)
            else
                disc = (real(p,extd)/real(fpa,extd))*real(p,extd)-real(fpb,extd)
            end if
            IF (Tr%cubic) write(Tr%u,804) pre//' disc=', disc
            IF ( disc >= ZERO ) then
                IF (biggest <= sqrt(MachHuge)) then
                    disc = sqrt(disc)
                else
                    disc = sqrt(disc)*sqrt(biggest)
                end if
                IF (Tr%cubic) write(Tr%u,804) pre//' disc=', disc
            else
                ExactInt = false
                IF ( fpa < ZERO ) then
                    x = aright
                else
                    x = aleft
                end if
                IF (Tr%cubic) write(Tr%u,800) pre//' no minimum!'
                goto 900
            end if

        end if

        disc = sgn*disc
        IF (Tr%cubic) write(Tr%u,804) pre//' disc=',disc

        apr = real(fpa,extd) + real(fpb,extd) + real(TWO*p,extd)
        bpr = real(fpa,extd) + real(p,extd)
        IF (Tr%cubic) write(Tr%u,802) pre//' apr= ', apr, '  bpr= ',bpr

        IF ( sgn*bpr < ZERO ) then
            IF (Tr%cubic) write(Tr%u,800) pre//' using regular form.'
            x = a + fpa*(b-a)/(bpr-disc)
            IF (Tr%cubic) write(Tr%u,804) pre//' predict x=',x
        else
            num = disc + bpr
            IF (Tr%cubic) write(Tr%u,800) pre//' using alternate form.'
            IF (Tr%cubic) write(Tr%u,804) pre//' num=',num
            IF ( abs((a-b)*num) >= (aright-aleft)*abs(apr) ) then
                x       = aright
                extreme = true
                IF (Tr%cubic) write(Tr%u,804) pre//' cut off to x=',x
            else
                x = a + num*(b-a)/apr
                IF (Tr%cubic) write(Tr%u,804) pre//' predict x=',x
            end if
        end if

        xc = x
        IF ( x < ZERO ) then
            x = aleft   ! use left bound if interpolated value negative
        else if ( .not. ignore ) then
            x  = max(x,aleft )
            x  = min(x,aright)
        end if
        ExactInt = .not. extreme .and. xc == x

        IF (Tr%cubic) write(Tr%u,805) &
                pre//' x= ', x, '  xc= ', xc, '  ExactInt= ', ExactInt,  &
                                              '  extreme= ', extreme
    end if  EQUAL

900 continue
    call Leaving ( id, Tr%flow, Tr%u, Tr%level )
    return

! FORMATS:

800   format ( a )
801   format ( 3(a, g15.7) )
802   format ( 2(a, g15.7), a )
803   format ( a, l2, a, g15.7 )
804   format ( a, g15.7 )
805   format ( 2(a, g15.7), 2(a,l1) )

end Subroutine Cubic_Interpolate

end Module Cubic
! <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> errorcodes.f90
MODULE ErrorCodes     !  'USE'ed in module MinimizeF

    USE Precision,        only  : short, long
    USE Min_States,       only  : SharedVars, TraceList
    USE Min_Codes

                         Implicit NONE
    PRIVATE
    !------              -------------!

    PUBLIC  ::  Error_Codes

CONTAINS

SUBROUTINE Error_Codes( FinalState, Sh, Tr )

! ARGUMENTS:

    Integer (short),      intent(IN)            :: FinalState
    Type (SharedVars),    intent(IN)            :: Sh
    Type (TraceList),     intent(IN)            :: Tr

! DESCRIPTION:
!
!   This routine will write out the meaning of the code FinalState.

! LOCAL DECLARATIONS:

    Integer (long)  :: i

! EXECUTION:

    Select CASE( FinalState )  ! write out the specific error condition
        Case (StorageError)
            write(Tr%u,800) 'Insufficient storage for attempted allocation'
        Case (InitialMin)
            write(Tr%u,800) 'Initial point is a critical point'
        Case (InitialUndefd)
            write(Tr%u,800) 'Function, gradient, or both are undefined at '    &
                         // 'the initial point'
        Case (BadInput)
            write(Tr%u,800) 'Unacceptable values supplied for the following '  &
                         // 'arguments to Minimize_f:'
        Case (LSFail)
            write(Tr%u,800) 'Failure in line search: abnormally small '        &
                         // 'steepest descent step from a cold start'
        Case (NoDescent)
            write(Tr%u,800) 'Current direction is a non-descent direction'
        Case (ExcessFEvals)
            write(Tr%u,800) 'The preset limit on the allowed number of '       &
                         // 'function evaluations has been exceeded'
        Case (InvalidM)
            write(Tr%u,801) 'No update terms have been stored: this is',       &
                            'invalid for the ProductForm (Nocedal) method'
        Case (AbortMin)
            write(Tr%u,801) 'Evaluate_f has detected an abort request',        &
                            'from the function evaluation routine'
    end select

    IF ( FinalState == BadInput ) then

        DO i = 1, Sh%Error(0)
            Select CASE( Sh%Error(i) )
                Case( BadN )
                    write(Tr%u,800) '  N: must be >= 2'
                Case( BadAcc )
                    write(Tr%u,800) '  Accuracy: must be > 0'
                Case( BadState )
                    write(Tr%u,800) '  State: value undefined'
                Case( BadMemory )
                    write(Tr%u,800) '  Memory: must be >= 0'
                Case( BadFreq )
                    write(Tr%u,800) '  Frequency: must be >= 0'
                Case( BadCheckPoint )
                    write(Tr%u,800) '  CheckPoint: must be >= 0'
                Case( BadCheckOpen )
                    write(Tr%u,800) '  CheckFile: cannot be opened or read'
                Case( BadCheckUnit )
                    write(Tr%u,800) '  CheckUnit: must be non-negative integer'
                Case( BadMethod )
                    write(Tr%u,800) '  Method: value undefined'
                Case( BadCombination )
                    write(Tr%u,800) '  Cannot use ProductForm with SD or CG'
                Case( BadTerms )
                    write(Tr%u,800) '  Terms: must be non-negative integer'
                Case( BadDeriv )
                    write(Tr%u,800) '  Derivatives: value undefined'
                Case( BadSysMemory )
                    write(Tr%u,800) '  SystemMemory: must be >= 0'
                Case( BadScaleF )
                    write(Tr%u,800) '  ScaleF: must be positive integer'
                Case( BadExpense )
                    write(Tr%u,800) '  Expense: must be positive integer'
                Case( BadEvalUnit )
                    write(Tr%u,800) '  EvalTraceUnit: must be integer >= 0'
                Case( BadPrintUnit )
                    write(Tr%u,800) '  PrintUnit: must be integer >= 0'
                Case( BadNorm )
                    write(Tr%u,800) '  TheNorm: value undefined'
                Case( BadTermUnit )
                    write(Tr%u,800) '  TermTraceUnit: must be integer >= 0'
                Case( BadInterp )
                    write(Tr%u,800) '  DoInterpolation: value undefined'
                Case( BadAlpha )
                    write(Tr%u,800) '  StartAlpha: value undefined'
                Case( BadGamma )
                    write(Tr%u,800) '  ScaleGamma: value undefined'
                Case( BadHTest )
                    write(Tr%u,800) '  HTest: value undefined'
                Case( BadUpdate )
                    write(Tr%u,800) '  UpdateForm: value undefined'
                Case( BadStep )
                    write(Tr%u,800) '  StartStep: value undefined'
                Case( BadRho )
                    write(Tr%u,800) '  rho: must be > 0'
                Case( BadBeta )
                    write(Tr%u,800) '  beta: must be between 0 and 1 inclusive'
                Case( BadSetH0 )
                    write(Tr%u,800) '  SetH0: value undefined'
            end select
        end do
    end if

! FORMATS:

   800 format ( a )
   801 format ( a, / a )

! EXIT:
    return

end Subroutine Error_Codes

end Module ErrorCodes
! <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> h0v.f90
MODULE H0v     ! 'USE'ed in modules MinimizeF, Sum, Product, Factored

    USE Precision,     only    : stnd, long, short
    USE Min_States,    only    : HMatrix, UserDefined, TraceList
    USE Min_Codes,     only    : Ident, Diagonal, Computed1, Computed2,    &
                                 Computed3
    USE Reals,         only    : zero, one, two
    USE General,       only    : Entering, Leaving
    USE True_False

                         Implicit NONE
    PRIVATE
    !------              -------------!

    PUBLIC  ::  H0v_Multiply

CONTAINS

 SUBROUTINE H0v_Multiply ( H, v, H0v, Us, Tr, u, ka )


! ARGUMENTS:

    Type (HMatrix),      intent(INOUT), TARGET    :: H

    Real (stnd),         intent(IN)               :: v(:)
    Real (stnd),         intent(OUT)              :: H0v(size(v))

    Type (UserDefined),  intent(IN)               :: Us

    Type (TraceList),    intent(INOUT)            :: Tr

    Real (stnd),         intent(INOUT), OPTIONAL  :: u(size(v))

    Integer (long),      intent(IN),    OPTIONAL  :: ka

! DESCRIPTION:
!
!     The basic purpose of this routine is to compute the value of the product
!     of the matrix  H0  and the vector  v.  Note that H0 may be defined
!     as Z0 * Z0^T, where Z0 is given.
!
!     On entry the following values are required:
!
!       H%H0    Vector of length n that stores a matrix, where n = size(v).
!               H0 is only required on entry if SetH0 = Diagonal (see below).
!       v       Vector of length  n  that is multiplied by  H0.
!       u       Vector of length  n.  See ka below.
!       k=ka    If k=0,  compute H0 * v  (the default if ka not present).
!               If k=-1, compute H0 * v as for k=0.  Also return u = Z0^T * v.
!               If k=-2, compute Z0*Z0^T and return it in the array H%Hi.
!                  Note that H0v is not altered in this case. Also, Hi should
!                  be returned in symmetric, upper half form, stored by row.
!                  Hi must be of an appropriate size and must have been
!                  allocated.
!               If k=1,...,n,  compute Z0[k] - (v^T * Z0[k])*u, where Z0[k] is
!                  the kth column of Z0, and return it in H0v. U must be passed
!                  in.
!               It is required that -2 <= k <= n; otherwise the routine will
!               exit with no calculations done.
!
!      Codes (found in Us):
!
!       SetH0   Flag to indicate the form that H0 takes:
!               Ident:     H0 identity ( Z0 = I ).
!               Diagonal:  H0 diagonal ( Z0 = SQRT(H0) ) (for upwards
!                             compatability).
!               Computed1: H0 computed in this routine according to the formula:
!                             H0 = Z0 * Z0^T where Z0(I,J) = (I-J)**2
!               Computed2: H0 computed in this routine according to the formula:
!                             H0 = Z0 * Z0^T where Z0(I,J) = 1 for I >= J
!                                                          = 2 for I <  J
!               Computed3: H0 computed in this routine according to the formula:
!                             H0 = Z0 * Z0^T where Z0(I,J) = 1/(I+J+ParH0)
!
!       ParH0   Used in the specification of H0 if SetH0 = Computed3.
!
!     On exit from the routine the following values are returned:
!       H0v    Specified product, for k >= -1.
!       u      Also contains Z0^T*v if k = -1.
!       Hi     Contains Z0*Z0^T if k = -2.
!
!
! PARAMETERS:

    Character *(*), PARAMETER           :: id     = 'H0v'

! LOCAL DECLARATIONS:

    Character (Len=len(id)+2+Tr%level)  :: pre

    Integer (long)                      :: i, j, jj, m, n, k

    Real (stnd)                         :: zv, t1, t2

    Real (stnd), POINTER                :: H0(:),    &
                                           Hi(:)

! EXECUTION

    pre = Entering( id, Tr%flow, Tr%u, Tr%level )

    n   = size( v )

    H0 => H%H0
    Hi => H%Hi

    IF ( PRESENT(ka) ) then
        k = ka
    else
        k = 0
    end if

    IF ( k > n  .or.  k < -2 ) return   ! Must have k between -2 and n.

    IF ( Us%SetH0 == Ident  .or.   &
         Us%SetH0 == Diagonal .and. .not. Associated(H0) ) then

        ! H0 is the identity matrix.  Z0 = I.

        Select CASE( k )
            Case ( 0, -1 ) !    Compute H0 * v.

                H0v = v
                IF ( k == -1 ) u = v

            Case ( -2 )    !    Compute Hi and store upper half of it by row.

                Hi = ZERO
                j  = 1
                DO i = 1, n
                    Hi(j) = ONE
                    j     = j + n - i + 1
                end do

            Case (1:)     !    Compute Z0[k] - (v^T*Z0[k])u.

                H0v    = -v(k) * u
                H0v(k) = H0v(k) + ONE
        end select

    else if ( Us%SetH0 == Diagonal ) then

        ! H0 is a diagonal matrix stored in vector H%H0.  Z0 = SQRT( H0 ).

        Select CASE( k )
            Case ( 0, -1 ) !   Compute H0 * v.
                H0v = H0 * v

                IF ( k == -1 ) u = SQRT( H0 ) * v

            Case ( -2 )    !   Compute H0 and store upper half of it by row.
                Hi = ZERO
                j  = 1
                DO i = 1, n
                    Hi(j) = H0(i)
                    j     = j + n - i + 1
                end do

            Case (1:)     !   Compute Z0[k] - (v^T*Z0[k])u.
                H0v    = (-v(k) * SQRT( H0(k) ) ) * u
                H0v(k) = H0v(k) + SQRT( H0(k) )
        end select

    else if ( Us%SetH0 == Computed1 ) then

        ! Z0(i,j) = (i-j)**2.  Note that Z0 = Z0^T.

        Select CASE( k )
            Case ( 0, -1 ) !    Compute H0 * v.

                H0v = ZERO
                DO j = 1, n     ! zv = Z0(I,J)^T * v(I)
                    zv = ZERO
                    DO i = 1, n
                        zv = zv + (i-j)**2*v(i)
                    end do

                    IF ( k == -1 ) u(j) = zv

                    ! Z0(I,J) * zv
                    DO i = 1, n
                        H0v(i) = H0v(i) + (i-j)**2*zv
                    end do
                end do

            Case ( -2 )    !    Compute H0 and store upper half of it by row.

                m  = 0
                Hi = ZERO
                DO i = 1, n
                    DO j = i, n
                        m = m + 1
                        DO jj = 1, n
                            Hi(m) = Hi(m)  +  (i-jj)**2 * (jj-j)**2
                        end do
                    end do
                end do

            Case (1:)     !    Compute Z0[k] - (v^T*Z0[k])u.

                zv = ZERO
                DO i = 1, n
                    zv   = zv + (i-k)**2*v(i)   ! v^T*Z0[k]
                end do

                DO i = 1, n
                    H0v(i) =  (i-k)**2 - zv*u(i)
                end do

        end select

    else if ( Us%SetH0 == Computed2 ) THEN

        ! Z0(i,j) is 1 for i >= j and 2 for i < j.

        Select CASE( k )
            Case ( 0, -1 ) !       Compute H0 * v.

                H0v = ZERO
                DO j = 1, n
                    zv = ZERO
                    DO i = 1, j-1
                        zv = zv + TWO*v(i)
                    end do
                    DO i = j, n
                        zv = zv +     v(i)
                    end do

                    IF ( k == -1 ) u(j) = zv

                    DO i = 1, j-1
                        H0v(i) = H0v(i) + TWO*zv
                    end do
                    DO i = j, n
                        H0v(i) = H0v(i) +     zv
                    end do
                end do

            Case ( -2 )    !    Compute H0 and store upper half of it by row.

                m = 0
                DO i = 1, n
                    DO j = i, n
                        m = m + 1
                        Hi(m) = ZERO
                        DO jj = 1, n
                            IF ( i >= jj ) then; t1 = ONE
                            else;                t1 = TWO
                            end if

                            IF ( jj <= j ) then; t2 = ONE
                            else;                t2 = TWO
                            end if

                            Hi(m) = Hi(m) + t1*t2
                        end do
                    end do
                end do

            Case (1:)    !     Compute Z0[k] - (v^T*Z0[k])u.

                zv = ZERO
                DO i = 1, k-1
                    zv = zv + TWO*v(i)
                end do
                DO i = k, n
                    zv = zv +     v(i)
                end do

                DO i = 1, k-1
                    H0v(i) = TWO - zv*u(i)
                end do
                DO i = k, n
                    H0v(i) = ONE - zv*u(i)
                end do

         end select

    else if ( Us%SetH0 == Computed3 ) then

        ! Z0(i,j) = 1/(i+j+ParH0).  Note that Z0 = Z0^T.

        Select CASE( k )
            Case ( 0, -1 ) !    Compute H0 * v.

                H0v = ZERO
                DO j = 1, n
                    zv = ZERO
                    DO i = 1, n
                        zv = zv + v(i)/(i+j+Us%ParH0)
                    end do

                    IF ( k == -1 ) u(j) = zv

                    DO i = 1, n
                        H0v(i) = H0v(i) + zv/(i+j+Us%ParH0)
                    end do
                end do

            Case ( -2 )    !    Compute H0 and store upper half of it by row.

                m = 0
                DO i = 1, n
                    DO j = i, n
                        m = m + 1
                        Hi(m) = ZERO
                        DO jj = 1, n
                            Hi(m) = Hi(m) &
                                    +  ONE/( (i+jj+Us%ParH0) * (jj+j+Us%ParH0) )
                        end do
                    end do
                end do

            Case (1:)     !    Compute Z0[k] - (v^T*Z0[k])u.

                zv = ZERO
                DO i = 1, n
                    zv   = zv + v(i)/(i+k+Us%ParH0)
                end do

                DO i = 1, n
                    H0v(i) = ONE/(i+k+Us%ParH0) - zv*u(i)
                end do

        end select

    end if

! EXIT:

900 call Leaving( id, Tr%flow, Tr%u, Tr%level )
    return

! FORMATS:  None.

end Subroutine H0v_Multiply

end Module H0v
! <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> factored.f90
MODULE Factored     ! 'USE'ed in module MinimizeF

    USE Precision,        only  : stnd, long, short
    USE Min_States,       only  : HTerm, HMatrix, UserDefined, SharedVars, &
                                  TraceList
    USE Min_Codes,        only  : Diagonal
    USE Inner_Product,    only  : OPERATOR(.GIP.)
    USE Reals,            only  : zero, one
    USE General,          only  : Entering, Leaving, WriteVec

    USE H0v

                         Implicit NONE
    PRIVATE
    !------              -------------!

    PUBLIC  ::  Factored_Multiply

CONTAINS

SUBROUTINE Factored_Multiply ( H, g, hg, u, &
                               ! ndelta, scalmu, deltai, gammai, etai,&
                               Us, Sh, Tr )

! ARGUMENTS:

    Type (HMatrix),       intent(INOUT), TARGET :: H
    Real (stnd),          intent(IN)            :: g(:)
    Real (stnd),          intent(INOUT)         :: u(size(g))
!   Real (stnd),          intent(INOUT)         :: g(:), u(size(g))!, scalmu
!   Real (stnd),          intent(IN)            :: deltai(size(g)), &
!                                                  gammai(size(g)), &
!                                                  ndelta,          &
!                                                  etai
    Real (stnd),          intent(OUT)           :: hg ( size(g) )
    Type (UserDefined),   intent(IN)            :: Us
    Type (SharedVars),    intent(INOUT)         :: Sh
    Type (TraceList),     intent(INOUT)         :: Tr

! DESCRIPTION:
!
!     Given the quasi-Newton update matrix  H (in ZZ' form) and
!     given the vector g, this routine computes
!
!               hg = H * g  .
!
!     It also returns the intermediate value u = Z' * g.
!
!     It assumes here that Z represents the matrix Z[i] at the point x[i].
!
!     Each iteration defines a "term" of the update, where each
!     term requires 3n or 4n entries of H, namely for
!
!                   u[i], sh[i] and yh[i], and, optionally, scale[i].
!
!     Here    s = x[i] - x[i-1] = alpha * d[i+1]
!             y = g[i] - g[i-1]
!             r = sqrt (s' * y)
!
!       and this defines the values
!
!             sh = s / r
!             yh = y / r
!
!       The vector u defines the orthogonal rotations.
!
!       If  ScaleColumns  is true, then the scaling vector scale[i] is also
!       stored for each i.  Let Z[i]*k denote the kth column of Z[i].  Then,
!       by definition, scale[i]_1 contains the current value of
!                                 sigma = ||Z[i]_1||,
!                      scale[i]_k, k > 1, contains the value by which Z[i]*k
!                                 should be multiplied.
!       Note that scale[i]_1 = ||Z[i]*1|| = sigma  and
!                 scale[i]_k * Z[i]*k >= sigma.
!       Columns Z[i]*k of length exceeding sigma are left unchanged.
!
!       On entry, scale[j], j < i, must be defined, along with scale[i]_1.
!       The values for scale[i]_k, k > 1, are determined and stored when the
!       columns of Z[i] are found.
!
!       If i > m, the following are also required:
!          deltai - step[i]
!          gammai - dgrad[i]
!          ndelt  - norm of delt at step i
!          etai   - deltai' * gammai
!
!       mu is used for recording the current scaling factor ndelt.
!
!       Note that at most m values are stored for step and dgrad,
!       but that there is always one more value of s stored, so the
!       maximum may be m+1. Also note, and this is related, that
!       deltai, gammai and etai are only used when i > m. Otherwise,
!       they are ignored.
!
!       Calculation of Hg also requires use of several temporary
!       areas, namely
!               v       an n by m+1 matrix
!               w       an n   vector
!               z       an n   vector
!               phi     an m+1 vector
!
!      NDELTA - norm of delta-hat at level i.
!
!     The tracing vector Tr is accessed.
!
! PARAMETERS:

    Character *(*), PARAMETER   :: id     = 'FacMult'

! LOCAL DECLARATIONS:

    Character (Len=len(id)+2+Tr%level)  :: pre

    Integer (long)              :: k, j, lowrow, hirow, n, i
    Integer (long),     POINTER :: m

    Real (stnd)                 :: w(1:size(g)), z(1:size(g)),  & ! AUTOMATIC
                                   phi(0:H%mTerms), v(1:size(g),0:H%mTerms)
    Real (stnd),        POINTER :: uj(:), shj(:), yhj(:), sh1mk(:)

    Type (HTerm),       POINTER :: Term, StartTerm

! EXECUTION:

    pre =  Entering ( id, Tr%flow, Tr%u, Tr%level )

    m  => H%mTerms
    i  = Sh%ct
    n  =  size(g)

    if (tr%vectors) then
        call WriteVec(g, f='g', unit=Tr%u, name=pre//' g=',indent=-Tr%level)
        call WriteVec(u, f='g', unit=Tr%u, name=pre//' u=',indent=-Tr%level)
    endif
    IF (tr%values ) write(Tr%u,801) pre//' i = ', i, ' m =', m

    IF ( Us%ScaleColumns .and. Us%SetH0 == Diagonal ) then
        IF ( i == 1 ) then; ! appscl = ndelta
        else;                   ! appscl = min( scalmu, ndelta )
        end if
    else
        !appscl = ONE
    end if

    ! IF ( i <= m ) scalmu = appscl

    IF ( i == 0 ) then
        call H0v_Multiply( H, g, hg, Us, Tr, U=u, Ka=-1)
    else

        hg = ZERO

        StartTerm => H%FirstTerm  ! to initialize sh1mk to something

        PICKDIAGONAL: &
        DO k = n+1, 2-i, -1
            ! k >= 2: k-1 is starting column along bottom row of table
            ! k <= 1: 2-k is starting row along left hand side of table

            lowrow = max(0,2-k)
            hirow  = min(n-k, i-1)   ! old: , m)

            Term => StartTerm
            Call GetNextTerm(0)
            if ( k <= 1 ) then
                sh1mk => shj
                Call GetNextTerm(1)
                StartTerm => Term
            end if

            EACHROW: &
            DO J = lowrow, hirow        ! Do rows up one diagonal...

                if (tr%flow) write(Tr%u,*) pre//'k, j = ', k, j

                ! j     is current row in table, so that
                ! j+k-1 is current column and
                ! j+k   is next column to right
                ! we are computing z for row j+1, column j+k

                IF  ( j == 0 ) then   ! starting from row 0.

                    call H0v_Multiply( H, yhj, w, Us, Tr, U=shj, Ka=k-1)

                else if  ( j+k == 2 ) then   ! in column 1 since j+k-1=1

                    if (tr%vectors) call WriteVec( &
                        sh1mk, f='g', unit=Tr%u, name=pre//' j+k=2: sh1mk = ', &
                        indent=-Tr%level)
                    if (tr%vectors) call WriteVec( &
                        shj,f='g',unit=Tr%u, name=pre//' shj=',indent=-Tr%level)
                    w   = sh1mk - (yhj .GIP. sh1mk) *shj

                else !   if ( j <= m-1 ) then

                    w   = z - (yhj .GIP. z)*shj

                !else    ! must be past row m.

                    !tmp = gammai .GIP. z
                    !w   = z - tmp/etai*deltai

                end if

                if (tr%vectors) call WriteVec( &
                    w, f='g', unit=Tr%u, name=pre//' w=',indent=-Tr%level)
                if(Tr%flow)write(Tr%u,*)pre//&
                        'Computing z for col j+k=',j+k,' row j+1=',j+1

                z = (- w  +  uj(j+k-1)/phi(j) * v(:,j)) * &
                       sqrt( phi(j) / (phi(j)+uj(j+k-1)**2) )
                call WriteVec(z,f='g',unit=Tr%u,name=pre//'z=',indent=-Tr%level)

                !IF ( Us%ScaleColumns ) z = z * scalej(j+k-1)

                IF ( j+k > 2 ) then  ! not column number 1
                    if(tr%flow) write(tr%u,*) pre//'Updating v, phi',j, &
                                      ' with u at col j+k-1=',j+k-1
                    v(:,j) = v(:,j) + uj(j+k-1) * w
                    phi(j) = phi(j) + uj(j+k-1)**2
                    if (tr%vectors) call WriteVec(v(:,j),&
                        f='g', unit=Tr%u, name=pre//' v=',indent=-Tr%level)
                    if (tr%values) write(Tr%u,*) pre//' phi[',j,']=', phi(j)
                end if

                IF ( j < hirow ) then
                    call GetNextTerm(1)
                end if

            end do EACHROW

            ! Have z for top row i, col k+i-1,
            !     or for rhs col n, row n-k+1

            j = hirow + 1
!            IF ( Us%ScaleColumns .and.  j <= m ) cscale(k+j-1,j) = appscl

            OnRHS: &
            IF ( k > n-i+1 ) then   ! j = n-k+1
                if(tr%flow) write(tr%u,*) pre//'Initializing v, phi ',j

                IF ( k == n+1 ) then
                    call H0v_Multiply( H, yhj, v(:,j), Us, Tr, U=shj, Ka=n)
                    v(:,j) = uj(n) * v(:,j)
                else
                    v(:,j) = uj(n) * (z - (yhj .GIP. z) * shj)
                end if
                if (tr%vectors) call WriteVec(v(:,j),&
                    f='g', unit=Tr%u, name=pre//' v=',indent=-Tr%level)
                phi(j)  = uj(n)**2
                if (tr%vectors) write(Tr%u,*) pre//'phi[',j,']=', phi(j)
            else OnRHS             ! Along top, j = i
                if(tr%flow) write(tr%u,*) pre//'Top Row'

                IF ( Us%ScaleColumns ) then
                    !scalej(k+j-1) = max( ONE, scalej(1)/.NORM. z )
                    !z = scalej(k+j-1) * z
                end if

                if ( k+j == 2) then
                    u(1) = sh1mk .GIP. g
                else
                    u(k+j-1) = z .GIP. g
                endif
                hg = hg  +  u(k+j-1) * z
                if (tr%values) write(Tr%u,*)pre//'u[',k+j-1,']=',u(k+j-1)
                if (tr%vectors) call WriteVec(hg, &
                    f='g', unit=Tr%u, name=pre//' hg=',indent=-Tr%level)

!               if(tr) then
!                  if ( trv ) then
!                      call zzwmat(0,' z',one,z,zero,z,n,1,n,1,1,
!    -                    'f',9,4,1,80,tru)
!                      if ( k-1+j .le. i .and. k-1+j .ge. 2) then
!                          if (tr%vectors) write(tru,*) pre//'  checking...j,k,k-1+j,'
!    -                                   ,'1-k=' ,j,k,k-1+j,1-k
!                          tmp = z(1)/shj(1,1-k)
!                          call zzwmat(0,'z-delt1-k',one,z,-tmp,
!    -                      shj(1,1-k), n,1,n,1,1,'f',9,4,1,80,tru)
!                      end if
!                  end if
!                  TMP = INNER(N, yhj(1,J), Z, NONORM,IW,RW,DW)
!                  if (tr%vectors) write(tru,*) pre//' zT*yhj[',j,']=',TMP
!               end if

            end if OnRHS
            !if (tr%vectors) write(Tr%u,*) pre//'hg = ', hg
            !if (tr%vectors) write(Tr%u,*) pre//'phi(j)   = ', phi(j)

        end do  PICKDIAGONAL

        if(tr%flow) write(tr%u,*) pre//'Top Row: computing u[1]', &
                                       ' with s hat ',i-1
!       IF ( i <= m ) then
!           sh1mk => shj   ! help - test
!    if (tr%vectors) call WriteVec( sh1mk, &
!       f='g', unit=Tr%u, name=pre//' j+k=2: sh1mk = ',indent=-Tr%level)
!    u(1) = sh1mk .GIP. g
!           if (tr%vectors) write(Tr%u,*) pre//'u(1)  = ', u(1)    ! help
!           hg   = hg  +  u(1) * sh1mk
!       else
!           u(1) = ( deltai .GIP. v ) / sqrt(etai)
!            hg   = hg  +  u(1)/sqrt(etai) * deltai
!       end if

    end if

    if (tr%vectors) call WriteVec(u, &
        f='g', unit=Tr%u, name=pre//' u=',indent=-Tr%level)
    call Leaving ( id, Tr%flow, Tr%u, Tr%level )
    return

! FORMATS:

   801 format ( 2(a,i5) )

CONTAINS

    SUBROUTINE GetNextTerm (nterms)

        Integer, intent(IN) :: nterms

        Integer i

        DO i = 1,nterms
            if ( associated(Term%Next)) Term =>Term%Next
        end do

        uj   => Term%Data(Sh%ixu+1 : Sh%ixu+n )
        shj  => Term%Data(Sh%ixs+1 : Sh%ixs+n )
        yhj  => Term%Data(Sh%ixy+1 : Sh%ixy+n )
        !IF ( Us%ScaleColumns ) scalej  => Term%Data(Sh%ixc+1 : Sh%ixc+n )

        IF ( Tr%vectors .and. Tr%values ) then
            call WriteVec(uj, f='g', unit=Tr%u, name=pre//' uj->', &
                          indent=-Tr%level)
            call WriteVec(shj, f='g', unit=Tr%u, name=pre//' shj->', &
                          indent=-Tr%level)
            call WriteVec(yhj, f='g', unit=Tr%u, name=pre//' yhj->', &
                          indent=-Tr%level)
            !call WriteVec(scalej, f='g', unit=Tr%u, name=pre//' scalej->', &
                          !indent=-Tr%level)
        end if

    end Subroutine GetNextTerm

end Subroutine Factored_Multiply

end Module Factored
! <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> initialize.f90
MODULE Initialize     ! 'USE'ed in module MinimizeF

    USE Precision,        only  : stnd, long, short
    USE Min_States,       only  : HMatrix, SharedVars, UserDefined, TraceList
    USE Min_Codes,        only  : FactoredForm, AllocH0, StorageError, Diagonal
    USE Reals,            only  : zero, one
    USE General,          only  : Entering, Leaving

    USE MyAllocate,       only  : My_Allocate

                         Implicit NONE
    PRIVATE
    !------              -------------!

    PUBLIC  ::  Initialize_H

CONTAINS

SUBROUTINE Initialize_H ( x, g, H, FinalState, Sh, Us, Tr )


! ARGUMENTS:

    Real (stnd),          intent(IN)    :: x(:)
    Real (stnd),          intent(IN)    :: g(size(x))

    Integer(short),       intent(INOUT) :: FinalState

    Type (HMatrix),       intent(INOUT) :: H
    Type (SharedVars),    intent(INOUT) :: Sh
    Type (UserDefined),   intent(IN)    :: Us
    Type (TraceList),     intent(INOUT) :: Tr

! DESCRIPTION:
!
!     The purpose of this routine is to define the initial
!     matrix H0 = H[0].  This is stored in n locations of one
!     of the fields of H and defines a diagonal or identity matrix.
!
!     To be more specific, a diagonal matrix  H is defined with
!     elements  H(1,1), H(2,2), ... , H(n,n), but for storage
!     convenience, H is actually defined as a vector of n elements
!     and these n values are stored in H%H0(1),...,H%H0(n).
!
!     Note that, if Us%SetH0 is  Ident  on entry, then
!     H is by default the identity. No storage is allocated for H%H0.
!
!     On entry, the current point  x  and the gradient  g  at  x
!     must be defined.
!
!     Both  x  and  g  are used to compute the diagonal scaling
!     entries of  H.  The scaling used is quite primitive and not
!     particularly to be recommended.  The main point is that the
!     facility is available, and anyone so desiring can easily implement
!     their own scaling.
!
! PARAMETERS:

    Character *(*), PARAMETER   :: id = 'InitH'

! LOCAL DECLARATIONS:

    Character (Len=len(id)+2+Tr%level)  :: pre
    Integer(long)                       :: k, j, n
    Integer(short)                      :: enough


! EXECUTION:

    pre =  Entering ( id, Tr%flow, Tr%u, Tr%level )

    IF ( Sh%LimMemory .and. Us%SetH0 == Diagonal ) then

        call My_Allocate( size(x), AllocH0, enough, Us, Sh, Tr, H )
                                                               ! Define diagonal
                                                               ! scaling matrix
        IF ( enough /= 0_short ) then
            FinalState = StorageError
            goto 900
        end if

        Where ( g /= ZERO )
            H%H0 = abs (x/g)
        elsewhere
            H%H0 = abs (x)
        end where

        IF ( Us%UpdateForm == FactoredForm ) H%H0 = sqrt (H%H0)

    else if ( .not.  Sh%LimMemory ) then
        n  = size(x)
        j  = 1

        H%Hi = ZERO

        DO k=1,n
            H%Hi(j) = ONE ! Note: only half of H.
            j = j + n - k + 1
        end do

    end if

900 call Leaving ( id, Tr%flow, Tr%u, Tr%level )

! FORMATS:  none.

end Subroutine Initialize_H

end Module Initialize
! <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> linesearch.f90
MODULE LineSearch     ! 'USE'ed in module MinimizeF

    USE Precision,        only  : stnd, long
    USE Min_States,       only  : HMatrix, SearchVals, UserDefined, &
                                  SharedVars, TraceList
    USE Min_Codes,        only  : Never, On1, On2, On3
    USE General,          only  : Entering, Leaving
    USE Reals,            only  : zero, one,  three, ten, tenth,    &
                                  c0_3, c0_9, c1_m2, c1_m4
    USE True_False

    USE Cubic

                         Implicit NONE
    PRIVATE
    !------              -------------!

    PUBLIC  ::  Line_Search

CONTAINS

SUBROUTINE Line_Search (alpha, f, dg, f0, dg0, ap, fp, dgp, width,     &
                        LS, Us, Sh, H, Tr )


! ARGUMENTS:

    Real (stnd), intent(IN)       :: f, dg, f0, dg0
    Real (stnd), intent(OUT)      :: dgp, width
    Real (stnd), intent(INOUT)    :: alpha, fp, ap

    Type (SearchVals),  intent(INOUT), TARGET   :: LS
    Type (UserDefined), intent(IN)              :: Us
    Type (SharedVars),  intent(INOUT)           :: Sh
    Type (HMatrix),     intent(IN),    TARGET   :: H
    Type (TraceList),   intent(INOUT)           :: Tr

! DESCRIPTION:
!
!     This routine performs one internal iteration of the line search.
!
!     First, note that the execution of this routine is very much influenced
!     by a number of variables which appear in the calling routine Minimize_f.
!     These variables are obtained from the record Sh of shared variables,
!     and from the record Us of user-defined values.
!
!     Assume that the current search is along a direction  d  from a starting
!     point x-beg, and that the current point along that line is  x.  Assume
!     that the previous point considered along this line was  x-prev; thus,
!     on the first call for a line search along a given direction  d  from a
!     point x-beg, x-prev is just x-beg.  Then, on entry to line_search:
!
!        alpha  is the step length to x (so x  is x-beg + alpha*d).
!        f      is the function value at x.
!        dg     is the inner product of d and the gradient at  x.
!
!        f0     is the function value at  x-beg.
!        dg0    is the inner product of d and the gradient at x-beg.
!
!        ap     is alpha at x-prev.
!        fp     is the function value at the previous point x-prev.
!        dgp    is the inner product of d and the gradient at x-prev.
!
!       The following are obtained from the record Sh:
!
!        Validf is true if f and dg are defined at alpha.
!
!        ncalls is a count of how many times the function has been evaluated
!               along this direction  d, including the evaluation at  x, but
!               not including the evaluation at  x-beg.
!
!        DoneInterpolation is initially false, but it is set to true when a
!               point is computed via interpolation and accepted as the next
!               trial point. This is used to prevent termination without having
!               done an interpolation.
!
!        ct     is the iteration number of the current direction  d
!               and of the point to be reached, namely  x.
!
!---on exit from Line_Search:
!
!    LSFinished will be returned as true if the value alpha input to Line_Search
!               defines a point at which the line search can be terminated.
!               Otherwise it should be returned as false and a new trial value
!               for alpha determined.
!
!        width  is the width of the interval bounding an acceptable value of
!               alpha.  If no upper bound is known, width is the distance
!               between the current alpha and the lower bound.
!
!        alpha  if LSFinished is false, this contains the next value of alpha to
!               be considered. In this case, the values for  ap, dgp and fp
!               will have been updated.
!
!     ap, dgp, fp  if LSFinished is false, and a new value is defined in alpha,
!              then the "previous" point becomes the point just calculated, so
!              fp, dgp and ap should be redefined as the values  f, dg and alpha
!              input to this routine.
!
!              Note that these values are *not* updated if there were no valid
!              function or gradient values at the previous point.
!
!       The following are obtained from the record Us:
!
!        DoInterpolation, QuadInterpolation, IgnoreInterval
!
!       See file min.doc for an explanation of these values.
!
!
! SUBROUTINES:   Cubic_Interpolation
!
! PARAMETERS:

    Real (stnd), PARAMETER      :: nearly1     = c0_9,      &
                                   bitsmall    = tenth,     &
                                   small       = c1_M4,     &
                                   extrapolate = ten,       &
                                   initMargin  = c1_M2,     &
                                   xpndMargin  = three,     &
                                   maxMargin   = c0_3

    Character *(*), PARAMETER           :: id     = 'LS'

! LOCAL DECLARATIONS:

    Character (Len=len(id)+2+Tr%level)  :: pre

    Logical     :: accept, ForceInterp, NoInterpNeeded, InterpDone, intpt, &
                   test1,  first,  InterPt, test2

    Real (stnd) :: tp0, at, left, right, slice

    Integer(long),  POINTER :: m
    Real (stnd),    POINTER :: LwBd, fLBd, dTgLBd, UpBd, currMargin
    Logical,        POINTER :: GoodPt, AlphaLBdd, AlphaUBdd


! EXECUTION:

    m          => H%mTerms
    currMargin => Ls%Currmg
    GoodPt     => Ls%GoodPt
    LwBd       => Ls%LwBd
    fLBd       => Ls%fLBd
    dTgLBd     => Ls%dTgLBd
    AlphaLBdd  => Ls%AlphaLBdd
    UpBd       => Ls%UpBd
    AlphaUBdd  => Ls%AlphaUBdd

    pre =  Entering ( id, Tr%flow, Tr%u, Tr%level )

    IF ( Tr%lsflow ) then
        write(Tr%u,802)pre//' m = 0    LSFinished DoneInterpolation ct ncalls',&
                  m == 0  ,Sh%LSFinished,Sh%DoneInterpolation,Sh%ct,Sh%ncalls
        write (Tr%u,803) pre//' values:'                  &
          //' m  DoInterpolation LimMemory  IgnoreInterval&
              & QuadInterpolation',                       &
            H%mTerms,Us%DoInterpolation,Sh%LimMemory,Us%IgnoreInterval,  &
                     Us%QuadInterpolation
        write (Tr%u,999) Sh%ValidF, 0.0, f0, dg0, ap, fp, dgp, alpha, f, dg
    end if

    first = Sh%ncalls == 1

    IF ( first ) then

        AlphaLBdd  = false
        LwBd       = ZERO
        fLBd       = f0
        dTgLBd     = dg0

        AlphaUBdd  = false
        UpBd       = ZERO

        GoodPt     = true
        currMargin = initMargin
    end if

    ! Test whether the steplength criteria have been met.

    tp0   = f0 + small*alpha*dg0
    test1 = f  < tp0
    test2 = dg >= Nearly1*dg0

    IF ( Tr%lsreal ) write (Tr%u,801) pre//' tp0 = ',tp0

    IF ( Sh%ValidF ) then
        accept = test1 .and. test2
    else
        accept = false
    end if

    ACCEPTABLE:&
    IF ( accept ) then

        IF ( Tr%lsflow ) write(Tr%u,800) pre//' acceptable.'

        ! The basic acceptance test has been passed.  We must test whether the
        ! point may be immediately accepted, or if it is necessary to force
        ! another step because a required interpolation step has not yet
        ! been done.

        ! See if quadratic interpolation to be forced.

        NoInterpNeeded = Us%DoInterpolation == Never  .or.                 &
                        (Us%DoInterpolation == On1 .and. Sh%ct < m+1) .or. &
                        (Us%DoInterpolation == On2 .and. Sh%ct < m+2) .or. &
                        (Us%DoInterpolation == On3 .and. Sh%ct < m+3)

        ForceInterp = .not. NoInterpNeeded .and. Us%DoInterpolation /= Never

        ! See if line search is done. First test if an interpolation has been
        ! done. Use the appropriate meaning of an "interpolation", i.e.
        ! according to Us%QuadInterpolation, either actually check for a formal
        ! interpolation, or else just do as Shanno and make sure at least
        ! 2 points have been considered.

        InterpDone = (       Us%QuadInterpolation .and. Sh%DoneInterpolation ) &
                .or. ( .not. Us%QuadInterpolation .and. .not. first          )

        Sh%LSFinished =    InterpDone  .or.  .not. ForceInterp  .or.  dg == ZERO

        IF ( .not. Sh%LSFinished ) then
            IF ( dg > ZERO ) then
                UpBd      = alpha
                AlphaUBdd = true
            else
                LwBd      = alpha
                AlphaLBdd = true
                fLBd      = f
                dTgLBd    = dg
            end if
        end if

    else ACCEPTABLE
        IF ( Tr%lsflow .and. Sh%Validf ) then
            write(Tr%u,804) pre//' not accepted; f<f0-abit = ',test1, &
                               ' slope test = ',test2,                 &
                               ' AlphaUBdd = ', AlphaUBdd
            write(Tr%u,998) pre//" req'd reduction, f0-f, slope"   &
                               //' limit = ', f0-tp0,f0-f,Nearly1*dg0
        end if

        Sh%LSFinished = false

        IF ( .not. Sh%ValidF ) then
            UpBd      = alpha
            AlphaUBdd = false
        else if ( f >= tp0 ) then
            UpBd      = alpha
            AlphaUBdd = true
        else
            LwBd      = alpha
            fLBd      = f
            dTgLBd    = dg
            AlphaLBdd = true
        end if

    end if  ACCEPTABLE

    IF ( Tr%lsflow ) write(Tr%u,805) pre//' done? '//      &
           'accept LSFinished ForceInterp InterpDone NoInterpNeeded',    &
            accept,Sh%LSFinished,ForceInterp,InterpDone,NoInterpNeeded

    DONESEARCH:&
    IF ( .not. Sh%LSFinished ) then

        ! Line search not done. A new point must be tried. Use cubic
        ! interpolation to find the trial point  at.

        IF (Tr%lsreal)&
            write(Tr%u,806) pre//' LwBd: ', LwBd, ' AlphaLBdd: ', AlphaLbdd, &
                                 ' UpBd: ', UpBd, ' AlphaUBdd: ', AlphaUBdd
        IF ( UpBd /= ZERO ) then

            IF ( .not. AlphaUBdd .or. .not. GoodPt ) then
                at = LwBd + bitsmall*(UpBd-LwBd)
                IF ( Tr%lsreal ) write(Tr%u,801) pre//' taking midinterval'// &
                         ' alpha->', at
                InterPt = false
            else
                InterPt = true
                IF ( ap > UpBd .and. AlphaLBdd ) then
                    ap  = LwBd
                    fp  = fLBd
                    dgp = dTgLBd
                end if
            end if

        else

            InterPt = false
            left    = alpha * (ONE+initMargin)
            right   = extrapolate * alpha

            call Cubic_Interpolate (alpha,f,dg,ap,fp,dgp,left,right,at,intpt,&
                                    Tr, Us%IgnoreInterval)
            Sh%DoneInterpolation = intpt

            IF ( Tr%lsreal ) write(Tr%u,807) pre//' extrapolated in [',left,  &
                 ',',right,']','          to get alpha->',at,                 &
                 ' with exact interpolate-> ',intpt
        end if

        IF ( InterPt ) then

            IF ( GoodPt ) then

                slice = currMargin * (UpBd-LwBd)
                left  = LwBd + slice
                right = UpBd - slice

                call Cubic_Interpolate( alpha, f, dg, ap, fp, dgp, left,  &
                                        right, at, intpt, Tr, Us%IgnoreInterval)
                Sh%DoneInterpolation = intpt

                IF ( Tr%lsreal ) write(Tr%u,807) pre//&
                              ' interpolating in [',left,  ',',right,']',      &
                              '          to get alpha->',at,                   &
                              ' with exact interpolate-> ', intpt

                IF ( intpt ) then
                    currMargin = initMargin
                else
                    currMargin = min(maxMargin, currMargin * xpndMargin)
                end if

            else
                at = LwBd + bitsmall* (UpBd-LwBd)
                IF ( Tr%lsreal ) write(Tr%u,801) pre//' taking midinterval'// &
                    ' alpha->', alpha
            end if

        end if

        IF ( Sh%ValidF ) then
            ap  = alpha
            fp  = f
            dgp = dg

            alpha  = at
            GoodPt = Sh%ValidF
        else
            alpha  = at
            GoodPt = false
        end if

        IF ( UpBd /= 0 ) then
            width = UpBd - LwBd
        else
            width = alpha - LwBd
        end if

        IF ( Tr%lsreal ) write(Tr%u,801) pre//' exit with alpha->',alpha
        IF ( Tr%lsflow ) &
             write(Tr%u,808) pre//' exit with GoodPt: ', GoodPt, &
                                '  DoneInterpolation: ', Sh%DoneInterpolation
        IF ( Tr%lsreal ) write(Tr%u,801) pre//' exit with width->',width
    end if  DONESEARCH

! EXIT:

    call Leaving ( id, Tr%flow, Tr%u, Tr%level )
    return

! FORMATS:

800   format ( a )
801   format ( a, g15.7 )
802   format ( a, /, 3l11, 10x, 2i4 )
803   format ( a, /, 5x, 2i11, 3l13 )
804   format ( a, l1, a, l1, a, l1 )
805   format ( a, /, 7x, 5l10 )
806   format ( a, g15.7, a, l1, a, g15.7, a, l1 )
807   format ( 2(a, g15.7), a, /, a, g15.7, a, l1 )
808   format ( a, l1, a, l1 )

999   format ( '     (valid data = ', l1,  ')      alpha       ', &
               '        f          dir''l derivative'/            &
               '      first   point ', 3g19.11 /                  &
               '      last    point ', 3g19.11 /                  &
               '      current point ', 3g19.11 )
998   format ( a, 3g11.3 )

end Subroutine Line_Search

end Module LineSearch
! <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> product.f90
MODULE Product     ! 'USE'ed in module MinimizeF

    USE Precision,        only  : stnd, long, short
    USE Min_States,       only  : HMatrix, HTerm, UserDefined, SharedVars, &
                                  TraceList
    USE Min_Codes,        only  : GammaFirst
    USE Supp_Codes,       only  : OK
    USE Inner_Product,    only  : OPERATOR(.GIP.)
    USE General,          only  : Entering, Leaving, WriteVec
    USE True_False

    USE H0v

                         Implicit NONE
    PRIVATE
    !------              -------------!

    PUBLIC  ::  Product_Multiply

CONTAINS

SUBROUTINE Product_Multiply ( H, v, hv, Us, Sh, Tr )


! ARGUMENTS:

    Type (HMatrix),       intent(INOUT), TARGET :: H
    Real (stnd),          intent(IN)            :: v(:)
    Real (stnd),          intent(OUT)           :: hv ( size(v) )
    Type (UserDefined),   intent(IN)            :: Us
    Type (SharedVars),    intent(INOUT)         :: Sh
    Type (TraceList),     intent(INOUT)         :: Tr

! AUTOMATIC ARRAYS:

    Real(stnd)          ::  aro ( H%nTerms )  ! temporary vector

! DESCRIPTION:
!
!     Given the quasi-Newton update matrix  H (in product form) and
!     given the vector v, this routine computes
!
!               hv = H * v  .
!
!     If no terms have been allocated for H, then H is just H%H0.
!     If this is also unallocated, H is just taken as the identity I.
!
!     Each update "term" of H requires 2n+1 memory locations. The order is
!
!                   eta[i],  s[i] and  y[i].
!
!     Here    n    = the dimension of the problem
!             s    = x[i] - x[i-1] = alpha * d
!             y    = g[i] - g[i-1]
!             eta  = s' * y
!
!     These terms are stored in circular, i.e. wraparound, fashion
!     in a linked list.
!
!     The following variables are defined in the control record Us for
!     the minimization process, and are described in detail elsewhere:
!
!       beta          It is the parameter defining the Broyden family of
!                     updates. Beta must be 1.0 for product updates.
!       GammaScaling  The value GammaAll is not allowed with product form
!                     updates, although the value GammaFirst is permitted.
!
!     The tracing vector Tr is accessed as well.
!
! PARAMETERS:

    Character *(*), PARAMETER           :: id     = 'PrMult'

! LOCAL DECLARATIONS:

    Character (Len=len(id)+2+Tr%level)  :: pre

    Integer (long)                      :: k, n

    Real (stnd)                         :: sv

    Real (stnd),       POINTER          :: s(:), y(:), Hi(:)
    Real (stnd),       POINTER          :: eta

    Type (HTerm),      POINTER          :: term

! EXECUTION:

    pre =  Entering ( id, Tr%flow, Tr%u, Tr%level )

    ISEMPTY: &
    IF ( Associated(H%FirstTerm) ) then

        term  => H%FirstTerm%prev  ! First half of Nocedal's recursion.
        n     = size(v)

        call AssignHi ()

        sv     = s .GIP. v
        k      = H%nTerms
        aro(k) = sv / eta
        hv     = v - aro(k) * y

        Reverse: &
        DO while (.not. Associated(term,H%FirstTerm) )  !circular list

            term => term%prev
            call AssignHi ()  ! remaining iterations of the first half.

            sv     = hv .GIP. s
            k      = k - 1
            aro(k) = sv/eta
            hv     = hv - aro(k)*y

        end do Reverse

        ! Set hv = H0 * hv. H0 is the initial positive definite matrix.
        ! Array Temp is used here to store the product of H*hv, which is
        ! then assigned to hv.

        call H0v_Multiply ( H, hv, H%Temp, Us, Tr )
        hv = H%Temp

        IF ( Us%ScaleGamma == GammaFirst ) then
            hv = (eta/(y .GIP. y)) * hv
        end if

        Forward: &
        DO
            call AssignHi ()
            hv    = hv + (aro(k) - (y .GIP. hv)/eta) * s
            k     = k + 1
            term => term%next  ! terms of the second half of the product.
            IF  ( Associated(term,H%FirstTerm) ) EXIT
        end do Forward

    else

        call H0v_Multiply ( H, v, hv, Us, Tr )

    end if  ISEMPTY

    IF ( Tr%vectors .and. Tr%values )   &
        call WriteVec(hv, f='g', unit=Tr%u, name=pre//' H*v->',indent=-Tr%level)

900 call Leaving ( id, Tr%flow, Tr%u, Tr%level )
    return

! FORMATS:  none.

CONTAINS

    Subroutine AssignHi ()      ! 'break up'  term into its parts

        Hi  => term%Data
        eta => Hi(Sh%ixeta)
        s   => Hi(Sh%ixs+1 : Sh%ixs+n)
        y   => Hi(Sh%ixy+1 : Sh%ixy+n)

    end Subroutine

end Subroutine Product_Multiply

end Module Product
! <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> qnewton.f90
MODULE QNewton     ! 'USE'ed in modules MinimizeF, Dynamic, Update

    USE Precision,        only  : stnd, long
    USE Min_States,       only  : HMatrix, TraceList
    USE Inner_Product,    only  : OPERATOR(.IP.)
    USE General,          only  : Entering, Leaving, WriteVec

                         Implicit NONE
    PRIVATE
    !------              -------------!

    PUBLIC  ::  QNewton_Multiply

CONTAINS

SUBROUTINE QNewton_Multiply ( H, v, hv, Tr )


! ARGUMENTS:

    Type (HMatrix),       intent(IN)            :: H
    Real (stnd),          intent(IN)            :: v(:)
    Real (stnd),          intent(OUT)           :: hv ( size(v) )
    Type (TraceList),     intent(INOUT)         :: Tr

! AUTOMATIC ARRAYS:

    Integer(long)       :: p (size(v))

! DESCRIPTION:
!
!     Given the quasi-Newton update matrix  H (stored in row order
!     as the upper half of a symmetric matrix) and given the vector v,
!     this routine computes
!
!               hv = H * v  .
!
!     If no storage has been allocated for H%Hi, then H is just H%H0,
!     and, if this is also unallocated, H is just taken as the identity I.
!
!     The tracing vector Tr is also accessed.
!
! PARAMETERS:

    Character *(*), PARAMETER           :: id     = 'QNMult'

! LOCAL DECLARATIONS:

    Character (Len=len(id)+2+Tr%level)  :: pre

    Integer (long)                      :: i, j, k, n

! EXECUTION:

    pre =  Entering ( id, Tr%flow, Tr%u, Tr%level )

    IF ( Associated(H%Hi) ) then
        n  =  size(v)

        j = 1
        DO k = 1,n
            p(1:k-1) = p(1:k-1) + 1
            p(k:n  ) = (/ ( i, i=j,j+n-k) /)
            hv(k)    = H%Hi(p) .IP. v
            j = j + n - k + 1
        end do
    else if ( Associated(H%H0) ) then
        hv = H%H0 * v
    else
        hv = v
    end if

    IF ( Tr%vectors .and. Tr%values )   &
        call WriteVec(hv, f='g', unit=Tr%u, name=pre//' H*v->', &
                      indent=-Tr%level)

    call Leaving ( id, Tr%flow, Tr%u, Tr%level )
    return

! FORMATS:  none.

end Subroutine QNewton_Multiply

end Module QNewton
! <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> dynamic.f90
MODULE Dynamic     ! 'USE'ed in module MinimizeF

    USE Precision,        only  : stnd, long
    USE Min_States,       only  : HMatrix, UserDefined, SharedVars, TraceList
    USE Min_Codes,        only  : SumForm, ProductForm, FactoredForm
    USE Inner_Product,    only  : OPERATOR(.GIP.)
    USE General,          only  : Entering, Leaving
    USE Reals,            only  : zero, one

    USE QNewton

                         Implicit NONE
    PRIVATE
    !------              -------------!

    PUBLIC  ::  Dynamic_Update_H

CONTAINS

SUBROUTINE Dynamic_Update_H ( s, y, u, H, Us, Sh, Tr )


! ARGUMENTS:

    Real (stnd),         intent(IN)             :: s(:),        &
                                                   y(size(s))

    Real (stnd),         intent(INOUT)          :: u(size(s))

    Type (HMatrix),      intent(INOUT), TARGET  :: H

    Type (UserDefined),  intent(INOUT)          :: Us
    Type (SharedVars),   intent(INOUT)          :: Sh
    Type (TraceList),    intent(INOUT)          :: Tr

! DESCRIPTION:
!
!     The basic purpose of this routine is to compute the value of the
!     update matrix  H  at the latest point when switching to the QN method.
!
! SUBROUTINES:  QNewton_Multiply
!               .GIP.

    Character *(*), PARAMETER           :: id     = 'Dynamic_Update'

! LOCAL DECLARATIONS:

    Character (Len=len(id)+2+Tr%level)  :: pre

    Integer (long)         :: k, j, n
    Real (stnd)            :: nu, eta
    Real (stnd),  POINTER  :: term(:), s1(:), y1(:)

! EXECUTION:

    pre =  Entering ( id, Tr%flow, Tr%u, Tr%level )

    n  =  size(s)

    !   QN   case: symmetric half update stored.

    H%Hi = ZERO       ! Initialize H.
    j  = 1
    DO k=1,n
        H%Hi(j) = ONE ! Note: only half of H.
        j = j + n - k + 1
    end do

    ! *** First iteration ***

    term => H%FirstTerm%Data

    Select CASE (Us%UpdateForm)
        Case( SumForm )
            y1 => term(Sh%ixu+1:Sh%ixu+n)
            s1 => term(Sh%ixs+1:Sh%ixs+n)
            nu = term(Sh%ixnu)
        Case( ProductForm )
            s1 => term(Sh%ixs+1:Sh%ixs+n)
            y1 => term(Sh%ixy+1:Sh%ixy+n)
            nu = y1 .GIP. y1
    end select

    ! Scale initial quasi-Newton matrix.
    ! Store the initial Hessian, which is  H = (s'y/y'y)*I =
    ! (eta/nu)*I.  Then we need to recalculate the initial nu =
    ! y'*H*y = (eta/nu)*(nu above) = eta, and to find u = H*y = nu*Iy = nu *yy.

    eta  = term(Sh%ixeta)
    H%Hi = (eta/nu) * H%Hi

    ! First calculate u = H0*y and nu = y'*H0*y.  Remember that only
    ! the symmetric upper half of H is stored (in row order).

    call QNewton_Multiply ( H, y1, u, Tr )
    nu = y1 .GIP. u                     ! Calculate  nu = y'*H*y

    ! Now calculate the updated approximate Hessian H^.
    ! Use the BFGS update: nu, eta and H*y are known.

    y1  = -u + (ONE + nu/eta) * s1      ! Overwrite u or y.

    j = 1
    DO k=1,n
        H%Hi(j:j+n-k) &
         = H%Hi(j:j+n-k) + ((s1 .GIP. k)/eta) * y1(k:n) &
                         - ((u  .GIP. k)/eta) * s1(k:n)
        j = j + n - k + 1
    end do

    ! *** Second iteration ***

    term => H%FirstTerm%next%Data

    s1 => term(Sh%ixs+1:Sh%ixs+n)

    call QNewton_Multiply ( H, y, u, Tr )  ! Calculate u = H1*y
    nu = y .GIP. u                         ! Calculate nu = y'*H1*y

    ! Now calculate the updated approximate Hessian H^ using the BFGS update.

    y1  = -u + (ONE + nu/Sh%eta) * s1

    j = 1
    DO k=1,n
        H%Hi(j:j+n-k) &
         = H%Hi(j:j+n-k) + ((s1 .GIP. k)/Sh%eta) * y1(k:n) &
                         - ((u  .GIP. k)/Sh%eta) * s1(k:n)
        j = j + n - k + 1
    end do

! EXIT:

    call Leaving ( id, Tr%flow, Tr%u, Tr%level )
    return

! FORMATS:  None.

end Subroutine Dynamic_UpDate_H

end Module Dynamic
! <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> restart.f90
MODULE Restart   ! 'USE'ed in module MinimizeF

    USE Precision,        only  : stnd, long, short
    USE Min_States,       only  : HTerm
    USE Min_Codes,        only  : BadCheckOpen, SumForm, ProductForm, &
                                  FactoredForm
    USE Min_Defaults,     only  : CheckUnit
    USE General,          only  : Entering, Leaving
    USE SystemState
    USE True_False

                         Implicit NONE
    PRIVATE
    !------              -------------!

    PUBLIC  ::  Restart_Run

CONTAINS

SUBROUTINE Restart_Run   &
                    ( x, fx, g, State, C, File, FinalState,  &

                      InUnit )          ! Optional argument


! ARGUMENTS:

    Real (stnd),          intent(OUT)             :: x(:),        &
                                                     fx,          &
                                                     g(size(x))
    Integer (short),      intent(OUT)             :: State
    Type (MinimizeState), intent(OUT)             :: C
    Character *(*),       intent(IN)              :: File
    Integer (short),      intent(INOUT)           :: FinalState

    Integer (short),      intent(IN), OPTIONAL    :: InUnit

! DESCRIPTION:
!
!     This routine reads checkpointed data from the specified checkpoint
!     file and prepares to continue the computation from that point.
!
!     The arguments and the state vector for routine Minimize_f (except FName)
!     are restored by reading checkpointed data from
!     the named File.  File *must* be provided; the user must specify
!     exactly what file is to be used for resuming the computation.  Note that
!     two files were used for checkpointing: one with an 'a' at the end of
!     its name and one with a 'b' at the end.  The argument File must include
!     the 'a' or the 'b'.  If the specified File cannot be successfully opened,
!     the routine will attempt to open the other checkpoint file.
!     If neither checkpoint file can be opened, or if any error occurs
!     in reading the data from an open file, an error code
!     is set in FinalState and the main routine will immediately
!     terminate without any attempt to continue the computation.
!
!     A unit number for reading the file may be given in the optional
!     argument InUnit.
!     It is assumed that the memory is available as per the initial run.
!
! PARAMETERS:

    Character *(*), PARAMETER   :: id     = 'Restart'

! LOCAL DECLARATIONS:

    Character (Len=len(id)+2)   :: pre

    Integer (long)              :: i, lent, end
    Integer (short)             :: unit
    Logical                     :: used_a, IsThere

    Type (HTerm),      POINTER  :: term, term0

! EXECUTION:

    IF ( PRESENT(InUnit) ) then
        unit = InUnit
    else
        unit = CheckUnit
    end if

    ! Open specified file.

    lent   = len_trim(File)
    used_a = File(lent:lent) == 'a'

    open ( unit, file     =  File(1:lent),      &
                 form     = 'unformatted',      &
                 status   = 'old',              &
                 err      = 10,                 &
                 position = 'rewind'           )

    goto 20

    ! If the specified checkpoint file cannot be opened, try opening the
    ! alternate file.

10  IF ( used_a ) then
        open ( unit, file     =  File(1:lent-1)//'b',   &
                     form     = 'unformatted',          &
                     status   = 'old',                  &
                     err      = 900,                    &
                     position = 'rewind'               )
        used_a = false
    else
        open ( unit, file     =  File(1:lent-1)//'a',   &
                     form     = 'unformatted',          &
                     status   = 'old',                  &
                     err      = 900,                    &
                     position = 'rewind'               )
        used_a = true
    end if

    ! Read saved values.

20  read ( unit, err = 900 ) x, fx
    read ( unit, err = 900 ) g, State
    read ( unit, err = 900 ) C%Trace

    C%Trace%level = 2   ! Indent one level
    pre =  Entering ( id, C%Trace%flow, C%Trace%u, C%Trace%level )

    read ( unit, err = 900 ) C%User
    read ( unit, err = 900 ) C%Shared
    read ( unit, err = 900 ) C%LSSave
    read ( unit, err = 900 ) C%Local
    read ( unit, err = 900 ) C%Eval
    read ( unit, err = 900 ) C%EvalCts
    read ( unit, err = 900 ) C%EvalErs
    read ( unit, err = 900 ) C%Print
    read ( unit, err = 900 ) C%PrVals
    read ( unit, err = 900 ) C%Term
    read ( unit, err = 900 ) C%TermVals

    Allocate( C%d (1:size(x)) )
    Allocate( C%xx(1:size(x)) )
    Allocate( C%gg(1:size(x)) )
    read ( unit, err = 900 ) C%d
    read ( unit, err = 900 ) C%xx
    read ( unit, err = 900 ) C%gg

    read ( unit, err = 900 ) C%H%nTerms
    read ( unit, err = 900 ) C%H%mTerms

    read ( unit, err = 900 ) IsThere
    IF ( IsThere )  then
        Allocate( C%H%H0( 1 : C%Local%n ) )
        read ( unit, err = 900 ) C%H%H0
    else
        Nullify (C%H%H0)
    end if

    read ( unit, err = 900 ) IsThere
    IF ( IsThere )  then
        Allocate( C%H%Hi( 1 : (C%Local%n*(C%Local%n+1))/2 ) )
        read ( unit, err = 900 ) C%H%Hi
    else
        Nullify (C%H%Hi)
    end if

    read ( unit, err = 900 ) IsThere
    IF ( IsThere )  then
        Allocate( C%H%Temp( 1 : C%Local%n ) )
        read ( unit, err = 900 ) C%H%Temp
    else
        Nullify (C%H%Temp)
    end if

    read ( unit, err = 900 ) IsThere
    IF ( IsThere )  then
        Allocate( C%H%u( 1 : C%Local%n ) )
        read ( unit, err = 900 ) C%H%u
    else
        Nullify (C%H%u)
    end if

    IF ( C%H%nTerms /= 0 ) then
        Allocate( C%H%FirstTerm )
        term   => C%H%FirstTerm

        IF ( C%Local%All_Allocated ) then; end = C%H%mTerms
        else;                              end = C%H%nTerms
        end if

        DO i = 1, end

            Allocate( term%Data(C%Shared%ixstart:C%Shared%ixend) )
            read ( unit, err = 900 ) term%Data

            Select CASE( C%User%UpdateForm )
                Case( SumForm, FactoredForm )         ! linear list - always
                    Nullify( term%prev )              ! nullify prev pointer.
                Case( ProductForm )                   ! circular list - set
                    IF ( i >= 2 ) term%prev => term0  ! prev pointer.
            end select

            term0 => term

            IF ( i == C%H%nTerms ) C%H%LastTerm => term   ! Only used in SumForm
                                                          ! and FactoredForm.

            IF ( i /= end ) then
                Allocate( term%next )
                term => term%next
            end if

        end do

        Select CASE( C%User%UpdateForm )
            Case( SumForm, FactoredForm )    ! linear list
                Nullify( term%next )         ! set next pointer for last term

            Case( ProductForm )              ! circular list
                C%H%FirstTerm%prev => term   ! set prev pointer for first term
                term%next => C%H%FirstTerm   ! set next pointer for last term
                IF ( C%H%nTerms == C%H%mTerms ) &  ! set pointer for next term
                    C%H%NextTerm => C%H%FirstTerm%prev
        end select

    else
        Nullify( C%H%FirstTerm )
    end if

    close( unit )

    C%Local%CheckFlag = .not. used_a

    call Leaving( id, C%Trace%flow, C%Trace%u, C%Trace%level )
    C%Trace%level = 0   ! This is correct value for return to Minimize_f

! EXIT
    return

900 FinalState = BadCheckOpen
    return

! FORMATS:  none.

end Subroutine Restart_Run

end Module Restart
! <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> sum.f90
MODULE Sum     ! 'USE'ed in modules MinimizeF and Update

    USE Precision,        only  : stnd, long
    USE Min_States,       only  : HMatrix, HTerm, UserDefined, SharedVars, &
                                  TraceList
    USE Min_Codes,        only  : GammaAll, GammaFirst
    USE Inner_Product,    only  : OPERATOR(.GIP.)
    USE Reals,            only  : one, two
    USE General,          only  : Entering, Leaving, WriteVec
    USE True_False

    USE H0v

                         Implicit NONE
    PRIVATE
    !------              -------------!

    PUBLIC  ::  Sum_Multiply

CONTAINS

SUBROUTINE Sum_Multiply ( H, v, hv, Us, Sh, Tr )


! ARGUMENTS:

    Type (HMatrix),       intent(INOUT), TARGET :: H
    Real (stnd),          intent(IN)            :: v(:)
    Real (stnd),          intent(OUT)           :: hv ( size(v) )
    Type (UserDefined),   intent(IN)            :: Us
    Type (SharedVars),    intent(IN)            :: Sh
    Type (TraceList),     intent(INOUT)         :: Tr


!   DESCRIPTION:
!
!     Given the quasi-Newton update matrix  H (in sum form) and
!     given the vector v, this routine computes
!
!               hv = H * v  .
!
!     Each set of entries is called a "term" of the update,
!     and each update "term" of H requires 2n+2 memory locations
!
!                   nu[i], eta[i],  u[i] and  s[i].
!
!     Here     n    = the dimension of the problem
!              s    = x[i] - x[i-1] = alpha * d
!              y    = g[i] - g[i-1]
!              u    = H * y
!              nu   = y' * H * y
!              eta  = s' * y
!
!     If no storage has been allocated for the terms of H, then H is just H%H0.
!     If this is also unallocated, then H is just taken as the identity I.
!
!     The updates are stored in a linear linked list with at most m entries.
!
!     The following variables are defined in the control record Us for
!     the minimization process, and are described in detail elsewhere:
!
!       beta          It is the parameter defining the Broyden family of
!                     updates. The form used at each point is
!                            H^ = H(DFP) + beta * nu * w'w
!                     so that beta = 1 gives the BFGS update.
!       GammaScaling  controls the Shanno, Oren, Spedicato scaling of each term.
!
!     The tracing vector Tr is accessed as well.

! PARAMETERS:

    Character *(*), PARAMETER           :: id     = 'SUMult'

! LOCAL DECLARATIONS:

    Character (Len=len(id)+2+Tr%level)  :: pre

    Integer (long)              :: n, i
    Logical                     :: first

    Real (stnd)                 :: sv, uv, beta, gamma, sigma, mu

    Real (stnd),        POINTER :: s(:), u(:), Hi(:)
    Real (stnd),        POINTER :: eta, nu

    Type (HTerm),       POINTER :: term

! EXECUTION:

    pre =  Entering ( id, Tr%flow, Tr%u, Tr%level )

    call H0v_Multiply ( H, v, hv, Us, Tr ) ! Set hv = H0 * v.

    beta   = Us%beta

!   Compute the terms of the product.

    n     =  size(v)
    term  => H%FirstTerm
    first =  true

    DO i = 1, H%nTerms                ! linear linked list

        Hi  => term%Data       ! Compute next term and add into hv.

        nu  => Hi(Sh%ixnu)
        eta => Hi(Sh%ixeta)
        u   => Hi(Sh%ixu+1:Sh%ixu+n)
        s   => Hi(Sh%ixs+1:Sh%ixs+n)

        IF (Tr%values) write(Tr%u,801) pre//' nu= ', nu, '  eta=', eta

        uv = u .GIP. v
        sv = s .GIP. v

        IF (Tr%values) write (Tr%u,801) pre//' uv= ', uv, '   sv= ',sv

        ! If gamma scaling is required, set gamma = eta/nu, and use the
        ! modified update formula which can be derived from Shanno's
        ! work. This only applies to the BFGS update.

        IF (      (beta == ONE)                                       &
            .and. (   ( Us%ScaleGamma == GammaAll )                   &
                  .or. (Us%ScaleGamma == GammaFirst .and. first )) )  &
            then

            gamma = eta/nu
            IF (Tr%values) write(Tr%u,802) pre//' gamma= ',gamma

            hv    = gamma * hv
            mu    = - sv/nu
            sigma = (TWO*sv/eta)  - (uv/nu)

        else if ( beta == ONE ) then
            mu    = - sv/eta
            sigma = - ( ONE + nu/eta )*mu - uv/eta
        else
            mu    = ( (beta - ONE)*uv/nu ) - ( beta*sv/eta )
            sigma = sv* (eta + beta*nu)/(eta*eta) - (beta*uv/eta)
        end if

        IF (Tr%values) write (Tr%u,801) pre//' mu= ', mu, '  sigma= ',sigma

        hv = hv + mu*u + sigma*s

        IF ( Tr%vectors .and. Tr%values ) &
            call WriteVec(hv, f='g', unit=Tr%u, name=pre//' h*v->', &
                          indent=-Tr%level)

        term  => term%next
        first =  false
    end do

    call Leaving ( id, Tr%flow, Tr%u, Tr%level )
    return

! FORMATS:

801   format ( 2(a, g15.7) )
802   format ( a, g15.7 )

end Subroutine Sum_Multiply

end Module Sum
! <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> updateh.f90
MODULE Update    ! 'USE'ed in module MinimizeF

    USE Precision,        only  : stnd, long
    USE Min_States,       only  : HMatrix, UserDefined, SharedVars, &
                                  MinLocal, TraceList
    USE Min_Codes,        only  : SumForm, ProductForm, FactoredForm
    USE Inner_Product,    only  : OPERATOR(.GIP.)
    USE General,          only  : Entering, Leaving
    USE Reals,            only  : one
    USE True_False

    USE QNewton
    USE Sum

                         Implicit NONE
    PRIVATE
    !------              -------------!

    PUBLIC  ::  Update_H

CONTAINS

SUBROUTINE Update_H ( s, y, u, H, Us, Sh, Lc, Tr )


! ARGUMENTS:

    Real (stnd),         intent(IN)             :: s(:)

    Real (stnd),         intent(INOUT)          :: u(size(s))

    Real (stnd),         intent(IN)             :: y(size(s))

    Type (HMatrix),      intent(INOUT), TARGET  :: H

    Type (UserDefined),  intent(IN)             :: Us
    Type (SharedVars),   intent(INOUT)          :: Sh
    Type (MinLocal),     intent(INOUT)          :: Lc
    Type (TraceList),    intent(INOUT)          :: Tr

! DESCRIPTION:
!
!     The basic purpose of this routine is to compute the value of
!     the update matrix  H  at the new point.
!
!     In this description, "H" will denote the update matrix defined
!     when the current point is reached; "H^" will denote the update
!     matrix to be computed and used in forming the next search
!     direction.  On exit, the matrix H must have been updated to H^.
!
!     This routine assumes that memory for the update has been allocated
!     as required as it updates the required pointers (i.e. no allocation
!     is done in this routine).
!
!     On entry the following values are required.
!
!       s      The step taken on the iteration just completed.
!       y      The change in gradient from the previous point.
!              This may also be used as a scratch vector, in the QN case only.
!       H      The current matrix H
!       u      = Z^T * g, for the factored updates only.
!
!     On exit, in the sum update case, the value u is also returned, where
!
!       u = H*y
!
!     Depending on the current strategy, some of the following values must
!     be defined in Sh or Us on entry. These are explained more fully elsewhere.
!
!     Sh: RestartCt  The number of restarts done.
!         alpha      Step length; needed for factored updates.
!         SteepDStep True if the last search direction was steepest descent.
!         DoRestart  A flag which is true when this is a restart point.
!         QNpart     True when we are in the quasi-Newton part of the code
!         eta        = s'* y.
!     Us: CountFromRestart How many points until the next restart is forced.
!
!     In the quasi-Newton cases, the update will have been done in
!     place, i.e. the new matrix H^ will just have overwritten the old.
!
!     In the limited memory cases, another term will have been stored,
!     unless the space for updates has been used. In any case, in the
!     event of a restart, H will have redefined by a single update term.
!     There are no restarts in the product form case, and when the memory
!     limit is reached, earlier update terms are simply overwritten in a
!     circular fashion.
!
! SUBROUTINES:  Sum_Multiply
!               QNewton_Multiply
!               .GIP.

    Character *(*), PARAMETER           :: id     = 'Update'

! LOCAL DECLARATIONS:

    Character (Len=len(id)+2+Tr%level)  :: pre

    Integer (long),     POINTER :: m
    Real (stnd),        POINTER :: term(:)

    Integer (long)      :: k, j, n
    Real (stnd)         :: nu

! EXECUTION:

    pre =  Entering ( id, Tr%flow, Tr%u, Tr%level )

    m  => H%mTerms
    n  =  size(s)

    STRATEGY:&
    IF  ( Sh%LimMemory ) then

        IsRestart:&
        IF ( Sh%DoRestart ) then

            IF (Tr%Update) write(Tr%u,800) pre//' restart! H%nTerms->1'
            Sh%RestartCt = Sh%RestartCt + 1    ! Count number of restarts

            ! Set point to force the next restart.
            IF ( Us%CountFromRestart ) then
                Sh%RestartPt = 1 + n
            else
                Sh%RestartPt = m + 1 + n
            end if

            Nullify ( H%H0 ) ! After restart, diagonal scaling always I.

            IF ( m == 0 ) then  ! can't save updates; next step must be
                Sh%ct     = 0   ! steepest descent. Either SD or straight CG.
                H%nTerms  = 0
                Sh%QNpart = false
            else                ! construct update from last two points
                Sh%ct      = 1
                H%nTerms   = 1
                H%LastTerm => H%FirstTerm
                term       => H%FirstTerm%Data
                Sh%QNpart  =  true

                ! Save the current s and u = H*y = I*y = y (Beale restart)
                ! vectors and save  nu = y'*H*y = y'y and eta = s'y in the
                ! first term of H.

                IF ( Us%UpdateForm == SumForm ) then
                    term(Sh%ixnu)   = y .GIP. y
                    term(Sh%ixeta)  = Sh%eta
                    term(Sh%ixu+1:Sh%ixu+n)  = y
                    term(Sh%ixs+1:Sh%ixs+n)  = s

                    IF(Tr%Update) &
                        write(Tr%u,801) pre//' saved: nu= ', term(Sh%ixnu), &
                                                  '  eta= ', term(Sh%ixeta)
                else if ( Us%UpdateForm == FactoredForm ) then
                    term(Sh%ixu+1:Sh%ixu+n)  = -Lc%alpha * u
                    term(Sh%ixs+1:Sh%ixs+n)  = s / sqrt( Sh%eta )
                    term(Sh%ixy+1:Sh%ixy+n)  = y / sqrt( Sh%eta )
                   !IF ( Us%ScaleColumns) &
                       !term(Sh%ixc+1:Sh%ixc+1) = Lc%alpha*Lc%nrmd/sqrt(Sh%eta)
                end if

            end if

        else IsRestart; Select CASE (Us%UpdateForm)   ! not a restart

            Case( SumForm, FactoredForm )

                ! Compute u = H*y, Note that
                ! the computation is the same for the CG or QN parts.

                IF ( Us%UpdateForm == SumForm ) then
                    IF (Tr%Update) write(Tr%u,800) pre//' SUM form update'

                    call Sum_Multiply ( H, y, u, Us, Sh, Tr )

                    nu  = y .GIP. u
                else if ( Us%UpdateForm == FactoredForm ) then
                    IF (Tr%Update) write(Tr%u,800) pre//' FACTORED form update'
                end if

                SAVE:&
                IF ( Sh%QNpart ) then ! Save nu,eta,u and s in array H.

                    H%nTerms = H%nTerms + 1

                    IF ( Lc%All_Allocated ) then
                        H%LastTerm => H%LastTerm%next
                    else
                        IF ( .not. Associated(H%FirstTerm) ) then
                            H%FirstTerm => H%NextTerm
                        else
                            H%LastTerm%next => H%NextTerm
                        end if
                        H%LastTerm => H%NextTerm
                        Nullify  (H%NextTerm%next)
                        Nullify  (H%NextTerm%prev)
                    end if
                    term => H%LastTerm%Data

                    IF ( Us%UpdateForm == SumForm ) then
                        term(Sh%ixnu)  = nu
                        term(Sh%ixeta) = Sh%eta
                        term(Sh%ixu+1:Sh%ixu+n)  = u
                        term(Sh%ixs+1:Sh%ixs+n)  = s
                    else if ( Us%UpdateForm == FactoredForm ) then
                        term(Sh%ixu+1:Sh%ixu+n)  = -Lc%alpha * u
                        term(Sh%ixs+1:Sh%ixs+n)  = s / sqrt( Sh%eta )
                        term(Sh%ixy+1:Sh%ixy+n)  = y / sqrt( Sh%eta )
                       !IF ( Us%ScaleColumns) &
                       !term(Sh%ixc+1:Sh%ixc+1) = Lc%alpha*Lc%nrmd/sqrt(Sh%eta)
                    end if

                    Lc%All_Allocated = .not. Lc%UnknownM  .and.  H%nTerms >= m

                    IF ( Us%UpdateForm == SumForm  .and.  Tr%Update ) then
                        write(Tr%u,802) pre//' no restart; H%nTerms =',H%nTerms
                        write(Tr%u,801) pre//' saved: nu= ', term(Sh%ixnu), &
                                                   '  eta= ',term(Sh%ixeta)
                    else if (Us%UpdateForm == FactoredForm .and. Tr%Update) then
                        write(Tr%u,800) pre//' saved Powell update term'
                    end if
                else  SAVE
                    IF ( Tr%Update ) write(Tr%u,802) &
                        pre//' no restart; H%nTerms stays at',H%nTerms
                end if  SAVE

            Case( ProductForm )     ! circular linked list; no restarts

                IF ( Tr%Update ) write(Tr%u,800) pre // ' PRODUCT form update'

                IF ( H%nTerms == m ) then
                    H%FirstTerm => H%FirstTerm%next
                    H%NextTerm  => H%NextTerm%next
                else if ( .not. Associated(H%FirstTerm) ) then
                    H%FirstTerm      => H%NextTerm
                    H%FirstTerm%prev => H%FirstTerm
                    H%FirstTerm%next => H%FirstTerm
                    H%nTerms         = 1
                else
                    H%FirstTerm%prev%next => H%NextTerm
                    H%NextTerm%next       => H%FirstTerm
                    H%NextTerm%prev       => H%FirstTerm%prev
                    H%FirstTerm%prev      => H%NextTerm
                    H%nTerms = H%nTerms + 1
                end if
                term => H%NextTerm%Data
                term(Sh%ixeta) = Sh%eta
                term(Sh%ixs+1:Sh%ixs+n)  = s
                term(Sh%ixy+1:Sh%ixy+n)  = y

                Lc%All_Allocated = .not. Lc%UnknownM  .and.  H%nTerms >= m

                IF (Tr%Update) write(Tr%u,800) pre//' saved Nocedal update term'

            end select
        end if  IsRestart

    else STRATEGY   !   QN   case: symmetric half update stored.

        IF (Tr%flow) write(Tr%u,803) pre//' SteepDStep= ',Sh%SteepDStep

        IF ( Sh%SteepDStep ) then !  scale initial quasi-Newton matrix

            ! Store the initial Hessian, which is  H = (s'y/y'y)*I =
            ! (eta/nu)*I.  Then we need to recalculate the initial nu :=
            ! y'*H*y = (eta/nu)*(nu) = eta, and to find u = H*y =
            ! nu*Iy = nu *y.

            nu = y .GIP. y              ! Calculate  nu = y'*H*y = y'*I*y = y'*y
            H%Hi = (Sh%eta/nu) * H%Hi   !help - remove to compare QN to Factored
        end if

        ! First calculate u = Hi*y and nu = y'*Hi*y.  Remember that only
        ! the symmetric upper half of H is stored (in row order).

        call QNewton_Multiply ( H, y, u, Tr )
        nu = y .GIP. u                  ! Calculate  nu = y'*H*y = y'*u

        ! Now calculate the updated approximate Hessian H^.
        ! Use the BFGS update: nu, eta and H*y are known.

        H%Temp  = -u + (ONE + nu/Sh%eta) * s

        j = 1
        DO k=1,n
            H%Hi(j:j+n-k) &
             = H%Hi(j:j+n-k) + ((s .GIP. k)/Sh%eta) * H%Temp(k:n) &
                             - ((u .GIP. k)/Sh%eta) * s(k:n)
            j = j + n - k + 1
        end do

    end if  STRATEGY
    call Leaving ( id, Tr%flow, Tr%u, Tr%level )
    return

! FORMATS:

800   format ( a )
801   format ( 2(a, g15.7) )
802   format ( a, i8, a )
803   format ( a, g15.7 )

end Subroutine Update_H

end Module Update
! <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> minimizef.f90
MODULE MinimizeF     ! 'USE'ed in module Minimize

    USE Precision,        only  : stnd, long, short

    USE Min_States
    USE Min_Codes
    USE Min_Defaults,     only  : DefaultUserDefined, DefaultTraces, MaxUpdates

    USE Supp_States,      only  : EvalState, PrintState, TermState, TermValues
    USE Supp_Codes
    USE Supp_Defs
    USE Support,          only  : Evaluate_f, Print_Iterate, Test_Done

    USE Reals,            only  : c0_9, zero, one, two, five, c180
    USE Num_Constants,    only  : MachTol
    USE Inner_Product,    only  : OPERATOR(.IP.),  OPERATOR(.NORM.), &
                                  OPERATOR(.GIP.), OPERATOR(.GNORM.)
    USE General,          only  : Entering, Leaving, WriteVec, CpuSecs
    USE True_False
    USE SystemState

    USE CheckPoint
    USE Control
    USE Dynamic
    USE ErrorCodes
    USE Factored
    USE H0v
    USE Initialize
    USE LineSearch
    USE MyAllocate
    USE Product
    USE QNewton
    USE Restart
    USE Sum
    USE Update

                         Implicit NONE
    PRIVATE
    !------              -------------!

    PUBLIC  ::  Minimize_f

CONTAINS

RECURSIVE &
SUBROUTINE Minimize_f ( F, x, fx, g, Accuracy, State, Memory, C, &

                                                        ! Optional Arguments
                        EvalLimit,              &       ! Commonly changed
                        Frequency,              &
                        CheckPoint,             &
                        CheckFile,              &
                        CheckUnit,              &
                        Method,                 &
                        Terms,                  &
                        Derivatives,            &
                        DecreaseInF,            &
                        SystemMemory,           &
                        ExactLS,                &
                        ScaleF,                 &       ! For Evaluate_f
                        Expense,                &
                        TraceF,                 &
                        TraceG,                 &
                        TraceDervTest,          &
                        EvalTraceUnit,          &
                        PrintUnit,              &       ! For Print_Iterate
                        PrintGrad,              &
                        PrintX,                 &
                        UseGrad,                &       ! For Test_Done
                        UseStep,                &
                        UseShanno,              &
                        UseFunc,                &
                        TheNorm,                &
                        TraceTerm,              &
                        TermTraceUnit,          &
                        RelativeToF0,           &
                        RelativeToG0,           &
                        DoInterpolation,        &       ! For Minimization
                        QuadInterpolation,      StartAlpha,             &
                        ScaleGamma,             HTest,                  &
                        UpdateForm,             StartStep,              &
                        IgnoreInterval,         CountFromRestart,       &
                        rho,                    beta,                   &
                        SetH0,                  ParH0,                  &
                        ScaleColumns,           Traces                  &
                                                )


! ARGUMENTS:

    INTERFACE
            Subroutine F ( x, fx, g, job )
                Real(stnd),     intent(IN)          :: x(:)
                Real(stnd),     intent(OUT)         :: fx, g(size(x))
                Integer(short), intent(INOUT)       :: job
            end Subroutine
    end Interface

    Real (stnd),           intent(INOUT)         :: fx,            &
                                                    x (:),         &
                                                    g (size(x))

    Real (stnd),           intent(IN)            :: Accuracy

    Integer (short),       intent(INOUT)         :: State
    Integer (long),        intent(IN)            :: Memory
    Type  (MinimizeState), intent(INOUT), TARGET :: C

    Character*(*),     intent(IN), OPTIONAL ::      CheckFile

    Integer (long),    intent(IN), OPTIONAL ::  &
                        EvalLimit,              &
                        Frequency,              &
                        CheckPoint,             &
                        Terms,                  &
                        SystemMemory

    Integer (short),   intent(IN), OPTIONAL ::  &
                        CheckUnit,              &
                        Method,                 &
                        Derivatives,            &
                        Expense,                &
                        TheNorm,                &
                        ScaleF,                 &
                        EvalTraceUnit,          &
                        PrintUnit,              &
                        TermTraceUnit,          &
                        DoInterpolation,        &
                        StartAlpha,             &
                        ScaleGamma,             &
                        HTest,                  &
                        UpdateForm,             &
                        StartStep,              &
                        SetH0

    Type (TraceList), intent(IN), OPTIONAL ::   &
                        Traces

    Logical,          intent(IN), OPTIONAL ::   &
                        ExactLS,                &
                        TraceF,                 &
                        TraceG,                 &
                        TraceDervTest,          &
                        PrintGrad,              &
                        PrintX,                 &
                        UseGrad,                &
                        UseStep,                &
                        UseShanno,              &
                        UseFunc,                &
                        TraceTerm,              &
                        QuadInterpolation,      &
                        IgnoreInterval,         &
                        CountFromRestart,       &
                        RelativeToF0,           &
                        RelativeToG0,           &
                        ScaleColumns

    Real (stnd), intent(IN), OPTIONAL    ::     &
                        DecreaseInF,            &
                        rho,                    &
                        beta,                   &
                        ParH0


! DESCRIPTION:
!                 See      "min.doc"
!
! SUBROUTINES:
!
!     F                    external procedure passed as argument.
!
!     Initialize_H         initial diagonal matrix
!     Cubic_Interpolation  cubic interpolation
!     Line_Search          line search loop
!     Sum_Multiply         matrix vector multiplication with sums
!     Product_Multiply     matrix vector multiplication with products
!     Factored_Multiply    matrix vector multiplication with factors
!     Update_H             update H
!
!     Evaluate_f           See Support
!     Print_Iterate        See Support
!     Test_Done            See Support
!
! LOCAL DECLARATIONS:

!-----General Declarations.

    Integer (short)     :: EntryState, FinalState, enough, which

    Integer (long)      :: i, QNstorage

    Logical             :: less, toosmall, QNstep, Force1, ForceRestart,&
                           DoRestartTest,  Lots

    Real (stnd)         :: dgal, tp0, tp1, tp2, width, stg, utg, nu,    &
                           sigma, gamma, mu

    Type (UserDefined), POINTER :: Us
    Type (SharedVars),  POINTER :: Sh
    Type (SearchVals),  POINTER :: LS
    Type (MinLocal),    POINTER :: Lc
    Type (EvalState),   POINTER :: Ev
    Type (PrintState),  POINTER :: Pr
    Type (TermState),   POINTER :: Tm
    Type (TermValues),  POINTER :: Tv
    Type (TraceList),   POINTER :: Tr
    Type (HMatrix),     POINTER :: H
    Integer (long),     POINTER :: m

! PARAMETERS:

    Real (stnd), PARAMETER      :: nearly_1 = c0_9

    Character *(*), PARAMETER   :: id = 'Min'

! LOCAL DECLARATIONS:

    Character (Len=len(id)+2)   :: pre

! EXECUTION:

!>>>>>>>>>> PHASE  0:  Describe Phases.<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

!  The code is in "phases".  The flow is forward to the end in each
!  phase. All phases are exited only at the end of the phase and
!  flow proceeds to the start of another phase, or it exits  the
!  algorithm to statement  900.
!
!  An exception is a jump to 920 and a return in phase VII
!  if reverse communication is being used, along with a reentry
!  from the top of phase I back to continue from the point of exit
!  at 215.

!  A second exception is in the resumption of a run from a checkpointed
!  file.  A jump to the start of phase III occurs in this case.

!>>>>>>>>>> PHASE  I:  Initial Set Up.<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

    Us  => C%User
    Sh  => C%Shared
    LS  => C%LSSave
    Lc  => C%Local
    Ev  => C%Eval
    Pr  => C%Print
    Tm  => C%Term
    Tv  => C%TermVals
    Tr  => C%Trace
    H   => C%H
    m   => C%H%mTerms

    IF ( PRESENT(Traces) ) then
        C%Trace = Traces
    else
        C%Trace = DefaultTraces
    end if

    EntryState = State
    FinalState = OK

    IF ( State == Resume ) then  ! Resume run from a checkpointed file
        call Restart_Run( x, fx, g, State, C, CheckFile, FinalState, &
                          InUnit=CheckUnit )

        IF ( PRESENT(Traces) ) C%Trace = Traces    ! allows tracing to be done

        EntryState = State
        IF ( FinalState == OK ) then
            pre =  Entering ( id, Tr%flow, Tr%u, Tr%level )
            goto 160      ! go to point just after routine Check_Point called
        else
            goto 900      ! exit with error
        end if
    end if

    pre =  Entering ( id, Tr%flow, Tr%u, Tr%level )

    IF ( AnyTr() ) write ( Tr%u, 800 ) Tr

    Lc%NoPrint = false

    IF ( EntryState == RevCommReStart  .or. &
         EntryState == RevCommNoF      .or. &
         EntryState == RevCommNoG      .or. &
         EntryState == RevCommNoForG )         then

        ! Supplementary call with reverse communication.

        Sh%ValidF   = EntryState == RevCommRestart
        goto 215
    end if

    Lc%eps = FIVE * MachTol

    Lc%CheckFlag = true

    Lc%n = size(x)
    call CheckData ()   ! Check all parameter settings valid.

    IF ( Sh%error(0) /= 0 ) then
        FinalState = BadInput
        Lc%NoPrint = true
    end if

    IF ( FinalState == OK ) then
        call Initialize_Min ()

        Lc%FirstEval  = true

        Sh%RestartCt  = 0        ! Initialize counts
        Sh%ForceCt    = 0

        Lc%All_Allocated = false
        Lc%UnknownM      = false

        Sh%MemoryUsed = 0
        H%nTerms      = 0

        enough = 0

        Select CASE (Us%UpdateForm)
            Case (SumForm      ); Sh%ixleng  = 2*Lc%n + 2
                                  Sh%ixstart = -1
                                  Sh%ixnu    = -1
                                  Sh%ixeta   =  0
                                  Sh%ixu     =  Sh%ixeta
                                  Sh%ixs     =  Sh%ixu + Lc%n
            Case (ProductForm  ); Sh%ixleng  = 2*Lc%n + 1
                                  Sh%ixstart =  0
                                  Sh%ixeta   =  0
                                  Sh%ixs     =  Sh%ixeta
                                  Sh%ixy     =  Sh%ixs + Lc%n
            Case (FactoredForm ); Sh%ixleng  = 3*Lc%n
                                  Sh%ixstart =  1
                                  Sh%ixs     =  Sh%ixstart - 1
                                  Sh%ixu     =  Sh%ixs + Lc%n
                                  Sh%ixy     =  Sh%ixu + Lc%n
                                  !IF ( Us%ScaleColumns ) then
                                  !    Sh%ixleng = Sh%ixleng + Lc%n
                                  !    Sh%ixc    = Sh%ixy    + Lc%n
                                  !end if
        end select

        Sh%ixend = Sh%ixstart + Sh%ixleng - 1

        Sh%MethodInUse = Us%Method

        Select CASE (Sh%MethodInUse)
        !      ----     Allocate Memory

            Case (SD,CG)
                Sh%LimMemory     = true
                m                = 0
                Lc%All_Allocated = true
            Case (ConMin)
                Sh%LimMemory         = true
                C%H%mTerms           = 1
                Us%DoInterpolation   = Every
                Us%StartAlpha        = Before2QN
                Us%QuadInterpolation = false
                Us%IgnoreInterval    = false
            Case (FixTerms)      ! m is set in routine Initialize_Min.
                Sh%LimMemory = true
            Case (Variable)
                Sh%LimMemory = true
                Lc%UnknownM  = true
            Case (Available)
                QNstorage = ( Lc%n * (Lc%n + 1) ) / 2   +  Lc%n
                IF ( Sh%Memory > 0 ) then
                    Lots = Sh%Memory >= QNstorage
                else
                    Lots = true
                end if
                IF ( Lots ) then
                    call My_Allocate( QNstorage-Lc%n, AllocHi, enough, &
                                      Us, Sh, Tr, H )
                end if
                IF ( Lots .and. enough == 0 ) then
                    Sh%LimMemory         = false
                    Us%DoInterpolation   = Never
                    Us%StartAlpha        = AlwaysQN
                    Us%QuadInterpolation = false
                    Us%IgnoreInterval    = false
                else
                    Sh%LimMemory         = true
                    Lc%UnknownM          = true
                    Us%DoInterpolation   = On1
                    Us%StartAlpha        = Before2QN
                    Us%QuadInterpolation = true
                    Us%IgnoreInterval    = false
                end if
            Case (Dynamic)
                Sh%LimMemory         = true
                m                    = 5
                Us%DoInterpolation   = On1
                Us%StartAlpha        = Before2QN
                Us%QuadInterpolation = true
                Us%IgnoreInterval    = false
                Sh%IterationTime     = ZERO
            Case (QN)
                Sh%LimMemory =  false
                QNstorage    = ( Lc%n * (Lc%n + 1) ) / 2   +  Lc%n
                call My_Allocate( QNstorage-Lc%n, AllocHi, enough, Us, Sh, Tr, &
                                  H )
                IF ( enough /= 0 .or.  &
                     Sh%Memory >  0 .and. Sh%Memory < QNstorage ) then
                    Lc%NoPrint = true
                    FinalState = StorageError
                end if

        end select

        IF ( PRESENT(ExactLS) ) then
            IF ( ExactLS ) then      ! Set arguments to do an exact line search
                Us%DoInterpolation   = Every
                Us%StartAlpha        = AlwaysQN
                Us%QuadInterpolation = true
                Us%IgnoreInterval    = true
                Tm%UseGrad           = true
                Tm%UseStep           = false
                Tm%UseShanno         = false
                Tm%UseFunc           = false
            end if
        end if

        ! Check that there is sufficient memory for limited memory cases.
        ! The value of MemoryNeeded only includes memory that is explicitly
        ! allocated.  m is 0 unless it is set otherwise.

        IF ( Sh%LimMemory  .and.  Sh%Memory > 0 ) then
            Select CASE ( Us%UpdateForm )
                Case (SumForm)
                    Lc%MemoryNeeded = m * Sh%ixleng  +  3*Lc%n
                Case (ProductForm)
                    Lc%MemoryNeeded = m * Sh%ixleng  +  4*Lc%n
                Case (FactoredForm)
                    Lc%MemoryNeeded = m * Sh%ixleng  +  4*Lc%n
                    !IF ( Us%ScaleColumns ) &
                    !    Lc%MemoryNeeded = Lc%MemoryNeeded + Lc%n
            end select
            IF ( Us%SetH0 == Diagonal ) Lc%MemoryNeeded = Lc%MemoryNeeded + Lc%n

            IF ( Sh%Memory < Lc%MemoryNeeded ) then
                Lc%NoPrint = true
                FinalState = StorageError
            end if
        end if

        !  Allocate Temp in the QN or Limited Memory/ProductForm cases.
        !  Allocate u in the Limited Memory/FactoredForm case.
        !  Temp and u are never both allocated.

        IF ( .not. Sh%LimMemory  .or.  Us%UpdateForm == ProductForm ) then
            call My_Allocate( Lc%n, AllocTemp, enough, Us, Sh, Tr, H )
        else if ( Us%UpdateForm == FactoredForm ) then
            call My_Allocate( Lc%n, AllocU, enough, Us, Sh, Tr, H )
        end if
        IF ( enough /= 0 ) then
            Lc%NoPrint = true
            FinalState = StorageError
        end if

    end if

    IF ( FinalState == OK .and. EntryState == normal ) then

        call DoEvalF () ! Get initial function value
        Select CASE (which)
            Case (Nof,Nog,NoForG); FinalState = InitialUndefd
            Case Default;
        end select
        Lc%FirstEval = false
    end if

    IF ( FinalState == OK ) then

        Lc%nrmg = .GNORM. g

        IF (Tr%values .and. .not. Tr%input) then
            write (Tr%u,802) pre//' fx        = ',  fx
            write (Tr%u,802) pre//' norm of g = ',  Lc%nrmg
        end if

        IF ( Us%RelativeToF0 ) then ! Initialize the termination tests.
            Tm%FatX0 = fx
        else
            Tm%FatX0 = ONE
        end if

        IF ( Us%RelativeToG0) then
            Tm%NormGatX0 = Lc%nrmg
        else
            Tm%NormGatX0 = ONE
        end if

        IF ( Tr%input ) then
            write (Tr%u,999) Lc%n, Sh%Memory, Sh%Accuracy
            IF     ( Us%DecreaseInF == ZERO)then
                                    write(Tr%u,997) fx
            else if( Us%DecreaseInF <  ZERO)then
                                    write(Tr%u,996) Us%DecreaseInF
            else;                   write(Tr%u,995) Us%DecreaseInF
            end if

            call Control_Codes( EntryState, Us, Tr )
            write (Tr%u,994)  &
              Us%rho,                Us%beta,                                  &
              Us%QuadInterpolation,  Us%CountFromRestart, Us%IgnoreInterval,   &
              Us%RelativeToF0,       Us%RelativeToG0,     Sh%LimMemory,        &
              Lc%eps,                Tm%FatX0,            Tm%NormGatX0
            IF ( Sh%LimMemory ) then; write (Tr%u,992) m
            else;                     write (Tr%u,993) QNstorage
            end if
        end if

        ! Test if the initial point is the minimizer.

        IF ( Test_Done (Sh%Accuracy, Tm, fx, G, x, V=Tv, level=Tr%level )) &
                FinalState = InitialMin
    end if

    IF ( FinalState /= OK ) then
        goto 900
    end if

!>>>>>>>>>>PHASE  II:  "Cold Start" With Steepest Descent.<<<<<<<<<

!     Calculate the initial search direction: dg0 is the current
!     directional derivative of f along d, while nrmg is the norm of g.
!
!     Initialize ct, which is used to determine whether a Beale
!     restart should be done. i.e. a restart must be forced after
!     n steps without one. Initialize SteepDStep, which indicates
!     that the current search direction is a negative gradient direction.
!     The current point is x[0].

    Sh%it         = -1      ! Initialize iteration counter
20  Sh%SteepDStep = true
    Lc%cold       = true
    Sh%ct         = 0

    IF ( Sh%LimMemory ) then
        Sh%RestartPt      = Lc%n
        H%nTerms          = 0
        Sh%QNpart         = Sh%MethodInUse /= SD  .and.  Sh%MethodInUse /= CG
        Sh%DoForceRestart = .not. Sh%QNpart
    end if

    Sh%it = Sh%it + 1
    call Print_Iterate ( Lc%n, Sh%it, fx, Lc%nrmg, C%EvalCts, C%Print,&
                         C%PrVals, x,  g, first=true, level=Tr%level)

    call Initialize_H  ( x, g, H, FinalState, Sh, Us, Tr )
    IF ( FinalState /= OK ) then
        Lc%NoPrint = true
        goto 900
    end if

    if ( Sh%LimMemory  .and.  Us%UpdateForm == FactoredForm ) then
        call H0v_Multiply ( H, g, C%d, Us, Tr, u=H%u, ka=-1 )
    else
        call H0v_Multiply ( H, g, C%d, Us, Tr )
    end if

    C%d = -C%d

    Lc%nrmd = .GNORM. C%d
    Lc%dg0  = C%d .GIP. g

!>>>>>>>>>> PHASE  III: Start Iteration along d[ct].<<<<<<<<<<<<<<<<

!     Begin the major iteration loop. Ncalls is used to guarantee that
!     at least two points have been tried when Method=LimMemory (see
!     DoInterpolation).  Fmin is the current function value. Force a
!     restart after n steps. Output (if desired) at end of each iteration.

160 Lc%fmin   = fx
    Sh%ncalls = 0
    Lc%nrmx   = max ( ONE, .GNORM. x )
    Sh%DoneInterpolation = false

    Sh%IterationTime = Sh%IterationTime - CpuSecs ()

    IF ( Tr%values ) write (Tr%u,802) pre//' norm of x = ', Lc%nrmx
    IF ( Tr%XandD )  call WriteVec(x,   f='g', unit=Tr%u, name=pre//' x->', &
                                   indent=-Tr%level)
    IF ( Tr%values ) write (Tr%u,802) pre//' norm of d = ', Lc%nrmd
    IF ( Tr%XandD )  call WriteVec(C%d, f='g', unit=Tr%u, name=pre//' d->', &
                                   indent=-Tr%level)

    Sh%ct = Sh%ct + 1 ! So ct = index of point to which the search will lead.
                      !       = the index of the current search direction.

!>>>>>>>>>> PHASE  IV: Initialize Alpha for Line Search.<<<<<<<<<<<<

    Sh%LSFinished = false

    IF ( Tr%lsflow ) write(Tr%u,804) pre//' start ls :>'
    IF ( Tr%lsflow ) write(Tr%u,805)                           &
        pre//' ct    QNpart  SteepDStep  cold  IgnoreInterval',&
            Sh%ct,Sh%QNpart,Sh%SteepDStep,Lc%cold,Us%IgnoreInterval

    IF ( Tr%lsreal ) then
        IF ( abs(Lc%dg0) <= Lc%nrmg*Lc%nrmd ) then
            write(Tr%u,806) pre//' angle(d,-g)=',  &
                            angle(-Lc%dg0/(Lc%nrmg*Lc%nrmd)),' deg.'
        else
            write(Tr%u,807) pre// ' warning: NO ANGLE(d,-g): dg0>nrmg*nrmd', &
                                                         Lc%dg0,Lc%nrmg*Lc%nrmd
        end if
    end if

    IF  ( Lc%cold  ) then
        IF ( Tr%lsflow ) write(Tr%u,804) pre//' first case alpha.'

        ! First iteration. Scale step to one. Use estimate DecreaseInF.

        IF      ( Us%DecreaseInF == ZERO ) then
                            tp1 = TWO*abs(fx) / Lc%nrmg
        else if ( Us%DecreaseInF >  ZERO ) then
                            tp1 = TWO*Us%DecreaseInF / Lc%nrmg
        else;               tp1 = ONE
        end if

        IF ( Sh%LimMemory .and. Us%SetH0 == Diagonal ) then
            Lc%alpha = tp1
        else
            Lc%alpha = tp1 / Lc%nrmg
        end if

    else

        QNstep =  m /= 0                                                       &
                  .and. ( Us%StartAlpha /= NeverQN                     )       &
                  .and. ( Us%StartAlpha == Before1QN .and. Sh%ct < m + 1   .or.&
                          Us%StartAlpha == Before2QN .and. Sh%ct < m + 2   .or.&
                          Us%StartAlpha == Before3QN .and. Sh%ct < m + 3 )

        Force1 = QNstep .or. ( Us%StartAlpha == AlwaysQN )

        IF ( Force1 ) then

            Lc%alpha = ONE; IF ( Tr%lsflow ) write(Tr%u,804) &
                                                   pre//' force alpha to 1.'

        else
            IF      ( Us%StartStep == Fletcher ) then
                IF ( Tr%lsflow ) write(Tr%u,804) pre//' Fletcher scale alpha.'
                Lc%alpha = Lc%alpha * TWO * (fx - Lc%flast) / (Lc%dg0)
            else if ( Us%StartStep == Powell ) then
                IF ( Tr%lsflow ) write(Tr%u,804) pre//' Sh/Powell scale alpha'
                Lc%alpha = Lc%alpha * (Lc%dglast / Lc%dg0)
            end if
        end if

    end if
    IF ( Tr%lsflow )write(Tr%u,802) pre//' end of phase IV, alpha = ',Lc%alpha

!>>>>>>>>>> PHASE  V: Initialize Line Search.<<<<<<<<<<<<<<<<<<<<<<<

!   The line search fits a cubic to fx and dgal, the function and its
!   derivative at alpha, and to fp and dgp, the function and its deri-
!   vative at the previous trial point ap, where the derivatives are
!   along d.  Initialize ap, fp and dgp.

    Lc%ap  = ZERO
    Lc%fp  = Lc%fmin
    Lc%dgp = Lc%dg0

!   Save the current derivative along d and the function value to
!   scale the initial step along the next search vector.

    Lc%dglast = Lc%dg0
    Lc%flast  = Lc%fmin

    C%xx = x            !   Store the current x and g.
    C%gg = g

!   This next little loop avoids the possibility of a
!   ridiculously small value for alpha.

    DO while  ( fx+ Lc%alpha*Lc%dg0 >= fx + nearly_1*Lc%alpha*Lc%dg0 )
        Lc%alpha = TWO * Lc%alpha
    end do
    width = Lc%alpha

!>>>>>>>>>> PHASE  VI: Test for Line Search Failure.<<<<<<<<<<<<<<<<

2000 continue

    IF ( Tr%lsalpha ) write(Tr%u,802) pre//' ls alpha->',Lc%alpha

    IF ( Tr%lsreal ) then
       write(Tr%u,809)pre//' values:   ap= ', Lc%ap,  '  fp    = ', Lc%fp
       write(Tr%u,809)pre//'          dgp= ', Lc%dgp, '  dglast= ', Lc%dglast
       write(Tr%u,809)pre//'          dg0= ', Lc%dg0, '  flast = ', Lc%flast
       write(Tr%u,809)pre//'         fmin= ', Lc%fmin,'  nrmd  = ', Lc%nrmd
    end if

    toosmall = width * Lc%nrmd <= Lc%eps * Lc%nrmx

    IF ( toosmall ) then

!       This is an abnormally small step. Test if the direction
!       is a gradient direction. If not, try one before aborting
!       the run; i.e. do a total restart from scratch unless this
!       step is already a steepest descent step from a cold start.

        IF ( Tr%lsflow ) write(Tr%u,804) pre//' alpha too small.'
        IF ( Tr%values ) write(Tr%u,809) pre//' eps= ',Lc%eps,' width= ',width

        IF ( Lc%cold ) then
            FinalState = LSFail
            goto 900
        else
            goto 20
        end if

    end if

!>>>>>>>>>> PHASE  VII: Line Search Loop.<<<<<<<<<<<<<<<<<<<<<<<<<<<

!   LSFinished is set to true when the line search is deemed complete.
!   Each loop determines a new value for alpha and returns to 2000
!   unless the search has been deemed complete.

    x = C%xx + Lc%alpha*C%d      !   Compute the new trial point.

    !   Evaluate the function at the trial point.

    IF ( EntryState == RevCommStart   .or. &
         EntryState == RevCommReStart .or. &
         EntryState == RevCommNoForG ) then

        Lc%NoPrint = true           ! Exit for reverse communication.
        FinalState = RevCommFandG   !  (re-entry will be to 215)
        goto 900
    else
        Sh%IterationTime = Sh%IterationTime + CpuSecs ()
        call DoEvalF ()
        Sh%IterationTime = Sh%IterationTime - CpuSecs ()

        ! If NormalWithFG, increase counts by 1 since F and G have been
        ! evaluated once prior to entry to Minimize_f.

        IF ( EntryState == NormalWithFG  .and.  Lc%FirstEval ) then
            C%EvalCts%FEvals = C%EvalCts%FEvals + 1
            C%EvalCts%GEvals = C%EvalCts%GEvals + 1
            Lc%FirstEval     = false
        end if

    end if

215  IF ( FinalState == OK ) then

        Sh%ncalls = Sh%ncalls + 1

        dgal    = C%d .GIP. g !Compute dir'l derivative of f along d at alpha.
        Lc%nrmg = .GNORM. g

        IF ( Tr%lsreal ) then
            write (Tr%u,802) pre//' norm of g->', Lc%nrmg

            IF ( abs(dgal) <= Lc%nrmg*Lc%nrmd  .and.  Lc%nrmg /= ZERO ) then
                write(Tr%u,806) pre//' angle of d to -g->', &
                    angle(-dgal/(Lc%nrmg*Lc%nrmd)) ,' degrees'
            else
                write(Tr%u,809) pre//' warning on angle of d to -g'// &
                    ' dgal= ',dgal,' > nrmg*nrmd= ', Lc%nrmg*Lc%nrmd
            end if

            write(Tr%u,808) pre//' search: alpha       nrmd         ' &
                               //'eps          fx',                   &
                                        Lc%alpha,Lc%nrmd,Lc%eps,fx
            IF ( Tr%vectors ) call WriteVec(x, f='g', unit=Tr%u,      &
                                            name=pre//' x-> ', indent=-Tr%level)
        end if

        call Line_Search(Lc%alpha, fx, dgal, Lc%fmin, Lc%dglast, Lc%ap, Lc%fp, &
                         Lc%dgp, width, LS, Us, Sh, H, Tr)

        IF ( .not. Sh%LSFinished ) then
            DO i = 1,Lc%n  ! Check points not actually identical from roundoff.
                tp0 = C%xx(i) + Lc%alpha*C%d(i)
                IF ( tp0 /= C%xx(i) .and. tp0 /= x(i) ) goto 2600
            end do
            width = ZERO        ! If identical, force termination with error.
 2600       goto 2000
        end if
    else
        goto 900
    end if

!   Flow continues to PHASE VIII if the line search is done
!   or returns to 2000 if not.

!>>>>>>>>>> PHASE  VIII: Termination Test.<<<<<<<<<<<<<<<<<<<<<<<<<<

    less = Test_Done ( Sh%Accuracy, Tm, fx, G, x, C%xx, Tv, Tr%level )

    IF ( Tr%update ) write(Tr%u,810) pre//' term? less->', less

    IF ( .not. less ) then
        Sh%it = Sh%it + 1
        Sh%IterationTime = Sh%IterationTime + CpuSecs ()
        call Print_Iterate ( Lc%n, Sh%it, fx, Lc%nrmg, C%EvalCts, C%Print, &
                             C%PrVals, x,  g, first=false,level=tr%level )
        Sh%IterationTime = Sh%IterationTime - CpuSecs ()
    else
        goto 900
    end if

!>>>>>>>>>> PHASE  IX: Test if Restart Needed.<<<<<<<<<<<<<<<<<<<<<<

    ! Search continues.

    C%d   = Lc%alpha *C%d  ! d[ct]=alpha*d[ct], so full step vector s is in  d.

    ! Allocate space, if necessary and if possible.  Lc%All_Allocated is
    ! also reset in routine UpDate_H.

    IF ( Sh%LimMemory  .and.  .not. Lc%All_Allocated ) then

        IF ( Sh%MethodInUse == Variable  .or.  &
             Sh%MethodInUse == Available ) then

            ! Cease allocation if there is insufficient memory for another
            ! term or if the maximum number of updates is reached.

            Lc%MemoryNeeded = Lc%MemoryNeeded  +  Sh%ixleng

            IF ( (Sh%Memory > 0 .and. Lc%MemoryNeeded > Sh%Memory)  .or.  &
                 H%nTerms == MaxUpdates ) then
                enough = 1_short
                goto 300
            end if
        end if

        call My_Allocate( Sh%ixleng, AllocNext, enough, Us, Sh, Tr, H )
        IF ( enough == 0  .and.  Lc%UnknownM ) m = m + 1  ! Increase m

300     IF ( enough /= 0 ) then
            Lc%All_Allocated = true
            m                = H%nTerms
            Lc%UnknownM      = false
        end if
    end if

    IF ( Sh%LimMemory .and. Us%UpdateForm == ProductForm .and. m == 0 ) then
        FinalState = InvalidM   ! m = 0 invalid using ProductForm
        goto 900
    end if

    ForceRestart =                         & !Check if a restart is to be forced
                  Sh%LimMemory             &
                        .and. Sh%DoForceRestart                 &
                        .and. (Us%UpdateForm == SumForm  .or.   &
                               Us%UpdateForm == FactoredForm)   &
                        .and. ( Sh%ct > Sh%RestartPt  .or.  Sh%MethodInUse==SD )

    IF (Tr%update ) write(Tr%u,811) pre//                       &
            ' ForceRestart    ct    RestartPt    SteepDStep',   &
              ForceRestart,Sh%ct,Sh%RestartPt,Sh%SteepDStep

    IF (Sh%LimMemory) then; Select CASE (Us%UpdateForm)

        Case (Sumform, FactoredForm) ! Determine part of algorithm we are in
                                     ! for next step.

            Sh%QNpart =  ( ForceRestart .and. m /= 0   )        &
                    .or. ( Sh%QNpart    .and. (Lc%UnknownM .or. Sh%ct <= m) )

            DoRestartTest  = .not. Sh%QNpart  .and. Sh%ct > m+1

        Case (Productform);   Sh%QNpart = true

        end select
    end if

    IF ( ForceRestart ) then

        Sh%DoRestart  = true

    else if ( Sh%LimMemory .and. ( Us%UpdateForm == Sumform .or.   &
                                   Us%UpdateForm == FactoredForm ) &
                           .and. DoRestartTest               &
                           .and. Us%HTest /= NoRestart       ) then

        IF ( Tr%update ) write(Tr%u,804) pre//' LimMemory part: restart?'

        ! Must be in   LimMemory sequence, so must check if
        ! restart is needed according to Powell criterion.  Can apply
        ! in metric defined by  H  or by  I; i.e.  using  g'*H*g, or
        ! g'*g.  Compute values for restart test.

        IF ( Us%HTest == UseH ) then

            ! Powell's test with H as currently defined.
            ! Use xx as temporary storage for H*g.

            call Sum_Multiply (H, g, C%xx, Us, Sh, Tr )

            tp1 = C%xx .GIP. C%gg
            tp2 = C%xx .GIP. g
        else
            tp1 = g .GIP.  C%gg ! Ordinary test: Powell's test with H = I .
            tp2 = Lc%nrmg**2
        end if

        IF ( Tr%update ) write(Tr%u,812) pre//' restart if tp1(',tp1, &
            ') > rho*tp2 (',Us%rho*tp2,')'

        ! Set restart flag if tau[ct] > rho; note that tau = tp1/tp2
        ! but the test is done without the divide.

        Sh%DoRestart =   abs(tp1) > abs(Us%rho*tp2)

        IF ( Sh%DoRestart ) Sh%ForceCt = Sh%ForceCt + 1

    else

        IF ( Tr%update ) write (Tr%u,804) pre//' no restart test.'
        Sh%DoRestart = false

    end if

!>>>>>>>>>> PHASE  X: Update for Next Step.<<<<<<<<<<<<<<<<<<<<<<<<<

!   We now call a routine to update H from its value at the last point to
!   its value at the point which we have just reached at the end of this
!   line search. The details of the updating are in Update_H.

    C%gg   = g - C%gg
    Sh%eta =  C%d .GIP. C%gg

    if ( Sh%LimMemory  .and.  Us%UpdateForm == FactoredForm ) C%xx = H%u
    call Update_H ( C%d, C%gg, C%xx, H, Us, Sh, Lc, Tr )

!>>>>>>>>>> PHASE   XI:  Compute New Direction.<<<<<<<<<<<<<<<<<<<<<

    COMPUTE_d: &
    IF  ( Sh%LimMemory ) then

        ! First get the negative of the new search direction into d.

        Select CASE (Us%UpdateForm)

            Case(Sumform)

                IF ( Sh%QNpart .or. Sh%DoRestart ) then
                    call Sum_Multiply ( H, g, C%d, Us, Sh, Tr )
                else
                    ! Note that u = H*y is in xx from update.
                    ! Compute H^*g by putting  H*g into gg and then working in
                    ! the new update term. This must be done separately since
                    ! the new update may not have been saved. Note that this is
                    ! not an initial step, so we only do the gamma scaling if
                    ! ScaleGamma=GammaAll.

                    stg =  C%d .IP. g
                    utg = C%xx .IP. g
                    nu  = C%gg .IP. C%xx

                    call Sum_Multiply ( H, g, C%gg, Us, Sh, Tr )

                    IF ( Us%ScaleGamma == GammaAll ) then
                        sigma = ( TWO*stg/Sh%eta) - (utg/nu)
                        mu    = -stg/nu
                        gamma =  Sh%eta/nu
                    else
                        sigma = ( (ONE + nu/Sh%eta)*stg - utg ) / Sh%eta
                        mu    = -stg/Sh%eta
                        gamma = ONE
                    end if
                                                        ! Compute  H^*g into d.
                    C%d = mu * C%xx + sigma*C%d + gamma*C%gg
                end if

            Case(Productform)
                call Product_Multiply ( H, g, C%d, Us, Sh, Tr )
            Case(Factoredform)
                call Factored_Multiply ( H, g, C%d, H%u, Us, Sh, Tr )
        end select

        IF ( Tr%update ) write(Tr%u,804) pre//' new d using LimMemory.'

    else COMPUTE_d ! QN case:  Calculate search direction d(ct+1) = -H^*g
                   !           H^ is in H.

        call QNewton_Multiply ( H, g, C%d, Tr )

    end if  COMPUTE_d

    C%d     =  -C%d
    Lc%nrmd = .GNORM.  C%d
    Lc%dg0  =  C%d .GIP. g

!   Test for a downhill direction.

    IF ( Lc%dg0 >= ZERO ) then
        IF ( AnyTr() ) then
            write (Tr%u,804) pre//' ***failing*** on nondownhill direction'
            write (Tr%u,806) pre//' ***dg0->',Lc%dg0,'***'
        end if
        FinalState = NoDescent
    else
        Sh%SteepDStep =  m == 0  .and.  Sh%DoRestart
    end if

    Sh%IterationTime = Sh%IterationTime + CpuSecs ()

    ! If Dynamic method is used, check if switch to QN method should be done.
    ! C%EvalCts%time is the function evaluation time.  Sh%IterationTime is the
    ! time for the iteration (it does not include the print or function times).

    IF ( Sh%MethodInUse == Dynamic  .and.  m >= 2  .and.  Sh%it == 2  .and.  &
         C%EvalCts%time*TWO/(Lc%n-1) > Sh%IterationTime ) then

        IF (Tr%flow) write(Tr%u,804) pre//' Attempting to change method to QN'

        QNstorage = ( Lc%n * (Lc%n + 1) ) / 2   +  Lc%n
        IF ( Sh%Memory > 0 ) then; Lots = Sh%Memory >= QNstorage
        else;                      Lots = true
        end if
        IF ( Lots ) then
            call My_Allocate( QNstorage-Lc%n, AllocHi, enough, Us, Sh, Tr, H )

            ! Temp has already been allocated if doing ProductForm updates.
            IF ( Us%UpdateForm /= ProductForm ) &
                call My_Allocate( Lc%n, AllocTemp, enough, Us, Sh, Tr, H )
        end if
        IF ( Lots .and. enough == 0 ) then
            Sh%MethodInUse       = QN
            Sh%LimMemory         = false
            Us%DoInterpolation   = Never
            Us%StartAlpha        = AlwaysQN
            Us%QuadInterpolation = false
            Us%IgnoreInterval    = false
            m                    = 0

            call Dynamic_Update_H ( C%d, C%gg, C%xx, H, Us, Sh, Tr )

            Deallocate( H%FirstTerm%Next%Data )   ! Deallocate the 2 Limited-
            Deallocate( H%FirstTerm%Next )        ! Memory terms.
            Deallocate( H%FirstTerm%Data )
            Deallocate( H%FirstTerm )
            IF ( Us%UpdateForm == FactoredForm ) Deallocate( H%u )
            IF ( Us%SetH0 == Diagonal )          Deallocate( H%H0 )

            IF (Tr%flow) write(Tr%u,804) pre//' Method changed to QN'
        else
            IF (Tr%flow) write(Tr%u,804) pre//' Method not changed to QN'
        end if

    end if

    IF ( FinalState /= ok ) then
        goto 900
    else
        Lc%cold = false
        IF ( Us%CheckPoint /= 0 )                                          &
            call Check_Point( x, fx, g, State, C, Sh%it, File=CheckFile,   &
                              OutUnit=CheckUnit )
        GOTO 160
    end if

! EXIT

900 IF ( .not. Lc%NoPrint ) then
        Sh%it = Sh%it + 1
        call Print_Iterate ( Lc%n, Sh%it, fx, Lc%nrmg, C%EvalCts, C%Print, &
                             C%Prvals, x, g, force=true, level=Tr%level )
    end if

    IF ( AnyTr() ) call Error_Codes( FinalState, Sh, Tr )

    State  = FinalState
    IF ( State /= RevCommF      .and.    &    ! Deallocate memory if
         State /= RevCommG      .and.    &    ! not doing reverse
         State /= RevCommFandG  .and.    &    ! communication.
         State /= BadInput )             &    ! No memory allocated if input bad
         call My_Deallocate( Sh, Tr, H )

    call Leaving ( id, Tr%flow, Tr%u, Tr%level )

    return

! FORMATS:

   800 format &
       ( ' Trace flags: unit  level  input   flow   step  lsalpha lsreal', &
                      / 13x, i3, 4x, i3, 5l7/ &
         '             lsflow update values vectors XandD cubic',/ 9x,6l7 )
   802 format ( a, g15.7 )
   804 format ( a )
   805 format ( a, / i8, 4l9 )
   806 format ( a, g15.7, a )
   807 format ( a,2g15.7, a )
   808 format ( a, /, 11x, 4(g12.6,1x) )
   809 format ( a, g15.7, a, g15.7 )
   810 format ( a, l1 )
   811 format ( a, / , 4x, l9, 2i11, 2l12 )
   812 format ( a, g15.7, a, g15.7, a )

   999 format ( ' **** Minimize_f entered and initialization complete ****'/ &
        / &
        ' dimension  = ', i5, t40,            &
        ' memory available is ', i7/          &
        ' accuracy requested = ', g15.7 )
   997 format ( ' Expected reduction in f equals initial function', &
        ' value of ',g15.7 )
   996 format ( ' Expected reduction in f is unknown(DecreaseInF=',g8.1,')')
   995 format ( ' Expected reduction in f is ',g15.7 )
   994 format (                                                              &
        ' Real control values  rho = ', g15.7, ' beta = ',g15.7/             &
        ' Logical control values   QuadInterpolation  CountFromRestart ',    &
        ' IgnoreInterval'  / , 17x, 3l18 /                                   &
        '                             RelativeToF0      RelativeToG0   ',    &
                           / , 17x, 2l18 / /                                 &
        ' The following has been set during initialization: ',               &
        ' LimMemory (', l1,')'/                                              &
        ' machine relative accuracy eps = ', e8.2/                           &
        ' termination relative to ', g14.7,'(f); ',g14.7,'(g)' )
   993 format ( ' storage of ', i6, ' sufficient; using qn algorithm.' /)
   992 format ( ' storage limited; using ', i3, ' updates.' /)

!----------!
CONTAINS   !
!----------!

    Real(stnd) FUNCTION Angle (x)

    ! Return angle, in degrees, whose cos is x.

                             Implicit NONE
                            !-------------!

    ! ARGUMENTS:

               Real(stnd), intent(IN)   :: x

    ! EXECUTION:

               Angle = c180/acos(-ONE) * acos(x)

    end Function Angle


    Logical FUNCTION AnyTr ()

            ! returns true if any trace flag is set

        AnyTr = Tr%input   .or. Tr%flow   .or. Tr%steptypes .or. &
                Tr%lsalpha .or. Tr%lsreal .or. Tr%lsflow    .or. &
                Tr%update  .or. Tr%values .or. Tr%vectors   .or. &
                Tr%XandD   .or. Tr%cubic

    end Function AnyTr


SUBROUTINE CheckData ()

! Check that all input values are correct. Set a sequence of
! up to NumErrs error flags, one for each error found.  These
! are set in the array Sh%errors, with Sh%errors(0) containing
! the number of errors found.

    i = 0

    IF ( Lc%n <= 1 ) then
        i = min( i+1, NumErrs )
        Sh%error(i) = BadN
    end if

    IF ( accuracy <= ZERO ) then
        i = min( i+1, NumErrs )
        Sh%error(i) = BadAcc
    end if

    IF ( EntryState /= Normal       .and. &
         EntryState /= NormalWithFG .and. &
         EntryState /= RevCommStart   ) then
        i = min( i+1, NumErrs )
        Sh%error(i) = BadState
    end if

    IF ( memory < 0 ) then
        i = min( i+1, NumErrs )
        Sh%error(i) = BadMemory
    end if

    IF ( PRESENT(EvalLimit) ) then
        IF ( EvalLimit < 0 ) then
            i = min( i+1, NumErrs )
            Sh%error(i) = BadEvalLim
        end if
    end if

    IF ( PRESENT(frequency) ) then
        IF ( Frequency < 0 ) then
            i = min( i+1, NumErrs )
            Sh%error(i) = BadFreq
        end if
    end if

    IF ( PRESENT(CheckPoint) ) then
        IF ( CheckPoint < 0 ) then
            i = min( i+1, NumErrs )
            Sh%error(i) = BadCheckPoint
        end if
    end if

    IF ( PRESENT(CheckUnit) ) then
        IF ( CheckUnit < 0 ) then
            i = min( i+1, NumErrs )
            Sh%error(i) = BadCheckUnit
        end if
    end if

    IF ( PRESENT(Method) ) then
        Select CASE (Method)
            Case(SD, CG, ConMin, FixTerms, Variable, Available, Dynamic, QN)
                IF ( (Method == SD .or. Method == CG)  .and.  &
                     PRESENT(UpdateForm) ) then
                    IF ( UpdateForm == ProductForm ) then
                        i = min( i+1, NumErrs )
                        Sh%error(i) = BadCombination
                    end if
                end if
            Case Default
                i = min( i+1, NumErrs )
                Sh%error(i) = BadMethod
        end select
    end if

    IF ( PRESENT(terms) ) then
        IF ( terms < 0 ) then
            i = min( i+1, NumErrs )
            Sh%error(i) = BadTerms
        end if
    end if

    IF ( PRESENT(derivatives) ) then
        Select CASE (derivatives)
            Case(Analytic, CompareTest, FirstTest, Differences)
                ! OK
            Case Default
                i = min( i+1, NumErrs )
                Sh%error(i) = BadDeriv
        end select
    end if

    IF ( PRESENT(SystemMemory) ) then
        IF ( SystemMemory < 0 ) then
            i = min( i+1, NumErrs )
            Sh%error(i) = BadSysMemory
        end if
    end if

    IF ( PRESENT(ScaleF) ) then
        IF ( ScaleF <= 0 ) then
            i = min( i+1, NumErrs )
            Sh%error(i) = BadScaleF
        end if
    end if

    IF ( PRESENT(expense) ) then
        IF ( expense < 1 ) then
            i = min( i+1, NumErrs )
            Sh%error(i) = BadExpense
        end if
    end if

    IF ( PRESENT(EvalTraceUnit) ) then
        IF ( EvalTraceUnit < 0 ) then
            i = min( i+1, NumErrs )
            Sh%error(i) = BadEvalUnit
        end if
    end if

    IF ( PRESENT(PrintUnit) ) then
        IF ( PrintUnit < 0 ) then
            i = min( i+1, NumErrs )
            Sh%error(i) = BadPrintUnit
        end if
    end if

    IF ( PRESENT(TheNorm) ) then
        Select CASE (TheNorm)
            Case(L1, L2, Linf, G2)
                ! OK
            Case Default
                i = min( i+1, NumErrs )
                Sh%error(i) = BadNorm
        end select
    end if

    IF ( PRESENT(TermTraceUnit) ) then
        IF ( TermTraceUnit < 0 ) then
            i = min( i+1, NumErrs )
            Sh%error(i) = BadTermUnit
        end if
    end if

    IF ( PRESENT(DoInterpolation) ) then
        Select CASE (DoInterpolation)
            Case(Every, On1, On2, On3, Never)
                ! OK
            Case Default
                i = min( i+1, NumErrs )
                Sh%error(i) = BadInterp
        end select
    end if

    IF ( PRESENT(StartAlpha) ) then
        Select CASE (StartAlpha)
            Case(NeverQN, Before1QN, Before2QN, Before3QN, AlwaysQN)
                ! OK
            Case Default
                i = min( i+1, NumErrs )
                Sh%error(i) = BadAlpha
        end select
    end if

    IF ( PRESENT(ScaleGamma) ) then
        Select CASE (ScaleGamma)
            Case(NoGammaScale, GammaFirst, GammaAll)
                ! OK
            Case Default
                i = min( i+1, NumErrs )
                Sh%error(i) = BadGamma
        end select
    end if

    IF ( PRESENT(HTest) ) then
        Select CASE (HTest)
            Case(NoRestart, UseI, UseH)
                ! OK
            Case Default
                i = min( i+1, NumErrs )
                Sh%error(i) = BadHTest
        end select
    end if

    IF ( PRESENT(UpdateForm) ) then
        Select CASE (UpdateForm)
            !Case(SumForm, ProductForm, FactoredForm)
            Case(SumForm, ProductForm)
                ! OK
            Case(FactoredForm)  ! FactoredForm is not yet implemented
                i = min( i+1, NumErrs )
                Sh%error(i) = BadUpdate
            Case Default
                i = min( i+1, NumErrs )
                Sh%error(i) = BadUpdate
        end select
    end if

    IF ( PRESENT(StartStep) ) then
        Select CASE (StartStep)
            Case(Fletcher, Powell)
                ! OK
            Case Default
                i = min( i+1, NumErrs )
                Sh%error(i) = BadStep
        end select
    end if

    IF ( PRESENT(rho) ) then
        IF ( rho <= ZERO ) then
            i = min( i+1, NumErrs )
            Sh%error(i) = BadRho
        end if
    end if

    IF ( PRESENT(beta) ) then
        IF ( beta < ZERO  .or.  beta > ONE ) then
            i = min( i+1, NumErrs )
            Sh%error(i) = BadBeta
        end if
    end if

    IF ( PRESENT(SetH0) ) then
        Select CASE (SetH0)
            Case(Ident, Diagonal, Computed1, Computed2, Computed3)
                ! OK
            Case Default
                i = min( i+1, NumErrs )
                Sh%error(i) = BadSetH0
        end select
    end if

    Sh%error(0) = i

    return

end Subroutine CheckData


SUBROUTINE Initialize_Min ()

!  This routine is separated out from the main body of the code just
!  as a convenience. Its purpose is to initialize many of the quantities
!  used by the code.  In particular, it sets initial values first to
!  default values, and then resets any which for which optional
!  arguments are present.

                         Implicit NONE
                        !-------------!

    Us           = DefaultUserDefined

    Ev           = DefaultEvalState

    Pr           = DefaultPrintState
    C%PrVals     = InitPrVals

    Tm           = DefaultTermState

    Allocate ( C%d (1:Lc%n),    &
               C%xx(1:Lc%n),    &
               C%gg(1:Lc%n)     )

    Nullify ( C%H%FirstTerm )
    Nullify ( C%H%LastTerm  )
    Nullify ( C%H%NextTerm  )
    Nullify ( C%H%Hi )
    Nullify ( C%H%H0 )
    Nullify ( C%H%Temp )   ! used in routines Update_H and Product_Multiply
    Nullify ( C%H%u )      ! used in routines Minimize_f and Factored_Multiply

    Sh%Accuracy = Accuracy
    Sh%Memory   = Memory

    IF ( PRESENT(EvalLimit) )        Ev%EvalLimit         = EvalLimit
    IF ( PRESENT(Frequency) )        Pr%Frequency         = Frequency
    IF ( PRESENT(CheckPoint) )       Us%CheckPoint        = CheckPoint
    IF ( PRESENT(Method) )           Us%Method            = Method
    IF ( PRESENT(Terms) ) then;      H%mTerms             = Terms
        else;                        H%mTerms             = 0
        end if
    IF ( PRESENT(Derivatives) )      Ev%Derivatives       = Derivatives
    IF ( PRESENT(DecreaseInF) )      Us%DecreaseInF       = DecreaseInF
    IF ( PRESENT(SystemMemory) )     Us%SystemMemory      = SystemMemory
    IF ( PRESENT(ScaleF) )           Ev%ScaleF            = ScaleF
    IF ( PRESENT(Expense) )          Ev%Expense           = Expense
    IF ( PRESENT(TraceF) )           Ev%TraceF            = TraceF
    IF ( PRESENT(TraceG) )           Ev%TraceG            = TraceG
    IF ( PRESENT(TraceDervTest) )    Ev%TraceDervTest     = TraceDervTest
    IF ( PRESENT(EvalTraceUnit) )    Ev%EvalTraceUnit     = EvalTraceUnit
    IF ( PRESENT(PrintUnit) )        Pr%PrintUnit         = PrintUnit
    IF ( PRESENT(PrintGrad) )        Pr%PrintGrad         = PrintGrad
    IF ( PRESENT(PrintX) )           Pr%PrintX            = PrintX
    IF ( PRESENT(UseGrad) )          Tm%UseGrad           = UseGrad
    IF ( PRESENT(UseStep) )          Tm%UseStep           = UseStep
    IF ( PRESENT(UseShanno) )        Tm%UseShanno         = UseShanno
    IF ( PRESENT(UseFunc) )          Tm%UseFunc           = UseFunc
    IF ( PRESENT(TheNorm) )          Tm%TheNorm           = TheNorm
    IF ( PRESENT(TraceTerm) )        Tm%TraceTerm         = TraceTerm
    IF ( PRESENT(TermTraceUnit) )    Tm%TermTraceUnit     = TermTraceUnit
    IF ( PRESENT(RelativeToF0) )     Us%RelativeToF0      = RelativeToF0
    IF ( PRESENT(RelativeToG0) )     Us%RelativeToG0      = RelativeToG0
    IF ( PRESENT(DoInterpolation) )  Us%DoInterpolation   = DoInterpolation
    IF ( PRESENT(QuadInterpolation)) Us%QuadInterpolation = QuadInterpolation
    IF ( PRESENT(StartAlpha) )       Us%StartAlpha        = StartAlpha
    IF ( PRESENT(ScaleGamma) )       Us%ScaleGamma        = ScaleGamma
    IF ( PRESENT(HTest) )            Us%HTest             = HTest
    IF ( PRESENT(UpdateForm) )       Us%UpdateForm        = UpdateForm
    IF ( PRESENT(StartStep) )        Us%StartStep         = StartStep
    IF ( PRESENT(IgnoreInterval) )   Us%IgnoreInterval    = IgnoreInterval
    IF ( PRESENT(CountFromRestart) ) Us%CountFromRestart  = CountFromRestart
    IF ( PRESENT(rho) )              Us%rho               = rho
    IF ( PRESENT(beta) )             Us%beta              = beta
    IF ( PRESENT(SetH0) )            Us%SetH0             = SetH0
    IF ( PRESENT(ParH0) )            Us%ParH0             = ParH0
    IF ( PRESENT(ScaleColumns) )     Us%ScaleColumns      = ScaleColumns

    Lc%CheckNext = Us%CheckPoint

end Subroutine Initialize_Min


     Subroutine DoEvalF ()
        which = Both
        call Evaluate_f (F, x, fx, g, which, Ev, C%EvalCts, &
                        first=Lc%FirstEval, Test=C%EvalErs, level=Tr%level)
        Lc%NoPrint = true
        FinalState = OK
        Sh%ValidF  = false
        Select CASE (which)
            Case (Limit);          FinalState = ExcessFEvals
                                   Lc%NoPrint = false
            Case (Abort);          FinalState = AbortMin
            Case Default;          Lc%NoPrint = false
                                   Sh%ValidF  = true
        end select
    end Subroutine DoEvalF

end Subroutine Minimize_f

end Module MinimizeF
! <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> minimize.f90
MODULE Minimize         ! The Variable Storage Minimization Package

    ! For detailed documentation, see the file min.doc and
    ! the references contained therein.

    USE Precision,        only  : stnd, long, short, extd

    USE Min_Codes,        only  : normal, done

    USE SystemState,      only  : MinimizeState

    USE MinimizeF,        only  : Minimize_f

                         Implicit NONE
    PRIVATE
    !------              -------------!

    PUBLIC      MinimizeState,          &
                Minimize_f,             &
                normal, done,           &
                stnd, long, short, extd

end Module Minimize
! <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> test.nam
! <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> test_functions.f90
MODULE  Test_Functions

    USE Precision, only             : stnd, short

                         Implicit NONE
    PUBLIC
    !------              -------------!

    Integer, PARAMETER             :: nargs = 10

    Real(stnd)                     ::   &

        Arguments(nargs)

    Integer                        ::   &

        Funcno

!--------- DATA FOR TESTPACK FUNCTION     ARGAUS

    Real(stnd), DIMENSION(15), PARAMETER   ::  ARGASY = (/  &
             9.000D-4,  4.400D-3,  1.750D-2,  5.400D-2,  1.295D-1, &
             2.420D-1,  3.521D-1,  3.989D-1,  3.521D-1,  2.420D-1, &
             1.295D-1,  5.400D-2,  1.750D-2,  4.400D-3,  9.000D-4 /)

!--------- DATA FOR TESTPACK FUNCTION     BARD70

    Real(stnd), DIMENSION(15), PARAMETER   ::  BARD7Y = (/  &
               .14D0  ,   .18D0  ,   .22D0  ,   .25D0  ,   .29D0,  &
               .32D0  ,   .35D0  ,   .39D0  ,   .37D0  ,   .58D0,  &
               .73D0  ,   .96D0  ,  1.34D0  ,  2.10D0  ,  4.39D0  /)

!--------- DATA FOR TESTPACK FUNCTION     CHNRSN

    Real(stnd), DIMENSION(50), PARAMETER   ::  CHNRSN = (/  &
             1.25D0,1.40D0,2.40D0,1.40D0,1.75D0,1.20D0,2.25D0,1.20D0, &
             1.00D0,1.10D0,1.50D0,1.60D0,1.25D0,1.25D0,1.20D0,1.20D0, &
             1.40D0,0.50D0,0.50D0,1.25D0,1.80D0,0.75D0,1.25D0,1.40D0, &
             1.60D0,2.00D0,1.00D0,1.60D0,1.25D0,2.75D0,               &
             1.25D0,1.25D0,1.25D0,3.00D0,1.50D0,2.00D0,1.25D0,1.40D0, &
             1.80D0,1.50D0,2.20D0,1.40D0,1.50D0,1.25D0,2.00D0,1.50D0, &
             1.25D0,1.40D0,0.60D0,1.50D0/)

!--------- DATA FOR TESTPACK FUNCTION     HIMM32

    Real(stnd), DIMENSION( 7), PARAMETER   ::  HIM32A = (/  &
               0.0D0,      4.28D-4,    1.0D-3,     1.61D-3, &
               2.09D-3,    3.48D-3,    5.25D-3                /)

    Real(stnd), DIMENSION( 7), PARAMETER   ::  HIM32B = (/  &
               7.391D0,    1.118D1,    1.644D1,    1.62D1,  &
               2.22D1,     2.402D1,    3.132D1                /)

!--------- DATA FOR TESTPACK FUNCTION     KOWOSB

    Real(stnd), DIMENSION(11), PARAMETER   ::  KOWOSU = (/  &
               4.0D0,      2.0D0,      1.0D0,      0.5D0,   &
               0.25D0,     0.167D0,    0.125D0,    0.1D0,   &
               0.0833D0,   0.0714D0,    0.0625D0              /)

    Real(stnd), DIMENSION(11), PARAMETER   ::  KOWOSY = (/  &
               0.1957D0,   0.1947D0,   0.1735D0,   0.1600D0,&
               0.0844D0,   0.0627D0,   0.0456D0,   0.0342D0,&
               0.0323D0,   0.0235D0,    0.0246D0             /)

!--------- DATA FOR TESTPACK FUNCTION        MEYER

    Real(stnd), DIMENSION(16), PARAMETER   ::  MEY    = (/  &
             3.478D4,  2.861D4,  2.365D4,  1.963D4, 1.637D4, 1.372D4, &
             1.154D4,  9.744D3,  8.261D3,  7.030D3, 6.005D3, 5.147D3, &
             4.427D3,  3.820D3,  3.307D3,  2.872D3/)

!--------- DATA FOR TESTPACK FUNCTION         ORTOIT

    Real(stnd), DIMENSION(33), PARAMETER   ::  ORBETA = (/  &
           1.0D0, 1.5D0, 1.0D0, 0.1D0, 1.5D0,               &
           2.0D0, 1.0D0, 1.5D0, 3.0D0, 2.0D0,               &
           1.0D0, 3.0D0, 0.1D0, 1.5D0, 0.15D0,              &
           2.0D0, 1.0D0, 0.1D0, 3.0D0, 0.1D0,               &
           1.2D0, 1.0D0, 0.1D0, 2.0D0, 1.2D0,               &
           3.0D0, 1.5D0, 3.0D0, 2.0D0, 1.0D0,               &
           1.2D0, 2.0D0, 1.0D0/)

    Real(stnd), DIMENSION(33), PARAMETER   ::  OD     = (/  &
             5.0D0,5.0D0,5.0D0,2.5D0,6.0D0,6.0D0,           &
             5.0D0,6.0D0,10.0D0,6.0D0,5.0D0,9.0D0,          &
             2.0D0,7.0D0,2.5D0,6.0D0,5.0D0,2.0D0,           &
             9.0D0,2.0D0,5.0D0,5.0D0,2.5D0,5.0D0,           &
             6.0D0,10.0D0,7.0D0,10.0D0,6.0D0,5.0D0,          &
             4.0D0,4.0D0,4.0D0 /)

    Integer, DIMENSION(50), PARAMETER      ::  A      = (/  &
             -31,-1,-2,-4,-6,-8,-10,-12,+11,                &
             +13,-14,-16,+9,-18,+5,+20,-21,-19,             &
             -23,+7,-25,-28,-29,-32,+3,-33,-35,             &
             -36,+30,-37,+38,-39,-40,-41,-44,-46,           &
             +42,+45,+48,-50,+26,+34,-43,+15,+17,           &
             +24,-47,-49,-22,-27 /)

    Integer, DIMENSION(56), PARAMETER      ::  B      = (/  &
             -1,+2,-3,+4,-5,+6,-7,+8,-9,                    &
             +10,-11,+12,-13,+14,-15,+16,-17,+18,           &
             -19,-20,0,+22,+23,-24,+25,-26,+27,             &
             -28,+29,-30,+31,-32,+33,-34,-35,+21,           &
             -36,+37,-38,-39,-40,+41,-42,+43,+44,-50,       &
             +45,+46,-47,-48,-49,0,0,0,0,0 /)

!--------- DATA FOR TESTPACK FUNCTION        OSBRN1

    Real(stnd), DIMENSION(33), PARAMETER   ::  OSB1Y  = (/  &
        .844D0,  .908D0,  .932D0,  .936D0,  .925D0,         &
        .908D0,  .881D0,  .850D0,  .818D0,  .784D0,         &
        .751D0,  .718D0,  .685D0,  .658D0,  .628D0,         &
        .603D0,  .580D0,  .558D0,  .538D0,  .522D0,         &
        .506D0,  .490D0,  .478D0,  .467D0,  .457D0,         &
        .448D0,  .438D0,  .431D0,  .424D0,  .420D0,         &
        .414D0, .411D0, .406D0/)

!--------- DATA FOR TESTPACK FUNCTION        OSBRN2

    Real(stnd), DIMENSION(65), PARAMETER   ::  OSB2Y  = (/  &
        1.366D0,  1.191D0,  1.112D0,  1.013D0,  .991D0,     &
        .885D0,  .831D0,  .847D0, .786D0,  .725D0,          &
        .746D0,  .679D0,  .608D0,  .655D0,  .616D0,         &
        .606D0,  .602D0,  .626D0,  .651D0,  .724D0,         &
        .649D0,  .649D0,  .694D0,  .644D0,  .624D0,         &
        .661D0,  .612D0,  .558D0,  .533D0,  .495D0,         &
        .50D0,  .423D0,  .395D0,  .375D0,  .372D0,          &
        .391D0,  .396D0,  .405D0,  .428D0,  .429D0,         &
        .523D0,  .562D0,  .607D0,  .653D0,  .672D0,         &
        .708D0,  .633D0,  .668D0,  .645D0, .632D0,          &
        .591D0,  .559D0,  .597D0,  .625D0,  .739D0,         &
        .710D0,  .729D0,  .720D0,  .636D0,  .581D0,         &
        .428D0,  .292D0,  .162D0,  .098D0,  .054D0/)

CONTAINS

SUBROUTINE Functions ( X, F, G, IFG )

    USE Supp_Codes,    only : OK, JustF, JustG, NoForG
    USE Num_Constants, only : MachHuge
    USE Reals

                         Implicit NONE
                        !-------------!

! ARGUMENTS:

      Integer(short)        ::  IFG

      Real (stnd)           ::  F, X(:), G(size(X)), &
                                         Work(2*size(x))

! STATUS:
!
!    SYSTEM  DEPENDENCE:               NONE
!
!
! DESCRIPTION:
!
!          THIS TEST FUNCTION  EVALUATES ONE OF THE STANDARD TEST
!     FUNCTIONS PROVIDED WITH TESTPACK.  THE ARGUMENTS IN THE CALLING
!     SEQUENCE HAVE PRECISELY THE SAME MEANING AS IN THE ROUTINE EVALUATE_F.
!
!         THE TEST FUNCTION TO USE IS SELECTED THRU THE MODULE TEST_FUNCTIONS.
!     THE VALUE OF THE INTEGER, FUNCNO, SPECIFIES WHICH OF THE TEST FUNCTIONS
!     IS TO BE  USED; THE FUNCTION IS CHOSEN USING A CASE CONSTRUCT.
!
!         SOME OF THE FUNCTIONS NEED SPECIAL ARGUMENTS (OTHER THAN THE
!     VALUE OF X); THESE ARE PROVIDED THROUGH THE MODULE TEST_FUNCTIONS. A
!     MAXIMUM OF TEN ARGUMENTS ARE PROVIDED. IF THE MAXIMUM NUMBER OF
!     ARGUMENTS IS TO BE INCREASED, THE PARAMETER NARGS SHOULD BE INCREASED.
!
!         ALL FUNCTION ARGUMENTS ARE REAL. INTEGER VALUES MAY BE PASSED
!     BY ASSIGNING THE INTEGER VALUE TO A REAL ARGUMENT AND THEN USING
!     NINT TO RECOVER THE INTEGER VALUE.
!
!         THE AMOUNT OF SPACE AVAILABLE IN THE ARRAY WORK IS ALLOCATED
!     DYNAMICALLY. THIS MEANS THAT IT DOES NOT HAVE TO
!     BE PROVIDED IN THE CALL TO FUNCTIONS OR IN THE CALL TO EVALUATE_F.
!
! SUBROUTINES
!
!     PREDEFINED FUNCTIONS : SIN, COS, TAN, ACOS, ATAN, ABS, MAX, NINT
!                            EXP, LOG, MIN, MOD, SIGN, SQRT, REAL(DBLE)
!
! PARAMETERS

      Integer, PARAMETER    ::  ALPHA = 5,      BETA = 14,     GAMMA = 3

! LOCAL DECLARATIONS

      Integer               ::  I,   J,   K,   N,   I1,   I2

      Integer(short)        ::  Ret

      Logical               ::  FONLY, GONLY

      Real (stnd)           ::  PI,   BIGGST


!--------- VARIABLES FOR THE TEST FUNCTIONS.


      Real (stnd)  ::   X1,     X2,     X3,    X4,    X5,    X6,  &
                        G1,     G2,     G3,    G4,    G5,    G6,  &
                        W1,     W2,     W3,    W4,    W5,    W6,  &
                        W7,     W8,     W9,    W10,   W11,   W12, &
                         T,     RI,     TI,    YI,    RF1,   RF2

! EQUIVALENCES:         None.
!
! COMMON:               None.
!
! EXECUTION

      PI     = ACOS(-ONE)
      BIGGST = log(MACHHUGE)

!--------- SET LOGICAL FLAGS AND SELECT FUNCTION.

      FONLY = IFG == JustF
      GONLY = IFG == JustG
      N     = size(X)
      RET   = OK

!     THE TEST FUNCTIONS APPEAR HERE IN ALPHABETICAL ORDER.
!        Case( 26 );    3600    BARD70
!        Case( 11 );    2100    BIGGS6
!        Case( 16 );    2600    BOX663
!        Case( 27 );    3700    CRGLVY
!        Case( 25 );    3500    ENGVL2
!        Case( 40 );    5000    PENAL1
!        Case( 41 );    5100    PENAL2
!        Case(  3 );    1300    PWSING
!        Case(  1 );    1100    ROSENB
!        Case( 24 );    3400    SCHMVT
!        Case( 81 );    9100    SARSEB ! new quadratic - not yet in Mintest
                                       ! package

!>>>>>    NOTE : IF WE SUPPOSE THAT EACH OF THESE TEST FUNCTIONS HAD
!>>>>>           BEEN CODED AS A SEPARATE ROUTINE, THEN, UNLESS
!>>>>>           OTHERWISE SPECIFIED, ALL TEST FUNCTIONS WOULD HAVE
!>>>>>           HAD AN ARGUMENT LIST AS FOLLOWS:
!>>>>>
!>>>>>                  ( X, F, G, CASE )
!>>>>>
!>>>>>           THOSE WHICH WOULD REQUIRE ADDITIONAL ARGUMENTS ARE
!>>>>>           NOTED BY GIVING A SUITABLE CALLING SEQUENCE. THIS
!>>>>>           SERVES TO DEFINE THE SPECIAL ARGUMENTS FOR THOSE TEST
!>>>>>           FUNCTIONS. SEE FOR EXAMPLE PENAL2 AT 5100.

    Select CASE ( FUNCNO )

!--------- TESTPACK FUNCTION     ROSENB

    Case(  1 )

 1100 X1 = X(1)
      W1 = ONE - X1
      W2 = X(2) - X1*X1

      IF ( .NOT. GONLY ) F = c100*W2*W2 + W1*W1

      IF ( .NOT. FONLY ) then
         G(1) = -c400*W2*X1 - TWO*W1
         G(2) =  c200*W2
      end if



!--------- TESTPACK FUNCTION     PWSING

    Case(  3 )

 1300 IF ( .NOT. GONLY )  F = ZERO

      IF ( 4 * (N/4) /= N ) then

         IF ( .NOT. FONLY ) G = ZERO

      else

         DO I=1,N/4

            J  = 4*I

            W1 = X(J-3)
            W2 = X(J-2)
            W3 = X(J-1)
            W4 = X(J  )

            W5 = W1 + TEN * W2
            W6 = W3 - W4
            W2 = W2 - TWO * W3
            W3 = W2 * W2 *W2
            W1 = W1 - W4
            W4 = W1 * W1 * W1

            IF ( .NOT. GONLY ) &
               F = F + W5*W5 + FIVE*W6*W6 + W2*W3 + TEN*W1*W4

            IF ( .NOT. FONLY ) then
               G(J-3) =   TWO  * W5  + c40   * W4
               G(J-2) =   c20  * W5  + FOUR  * W3
               G(J-1) =   TEN  * W6  - EIGHT * W3
               G(J  ) =  -TEN  * W6  - c40   * W4
            end if

         end do

      end if



!--------- TESTPACK FUNCTION   BIGGS6 ( X, F, G, IFG, NINT(ARGUMENTS(1)))
!--------- NINT(ARGUMENTS(1)) IS M

    Case( 11 )

 2100 X1 = X(1)
      X2 = X(2)
      X3 = X(3)
      X4 = X(4)
      X5 = X(5)
      X6 = X(6)

      IF ( .NOT. GONLY ) F = ZERO

      IF ( .NOT. FONLY ) then
         G1 = ZERO
         G2 = ZERO
         G3 = ZERO
         G4 = ZERO
         G5 = ZERO
         G6 = ZERO
      end if

      DO I = 1, NINT(ARGUMENTS(1))
         T  = Real(I)
         TI = T/TEN
         IF ( MAX(-T,-TI*FOUR,-TI*X1,-TI*X2,-TI*X5) <= BIGGST ) then
            YI = EXP(-TI) - FIVE * EXP(-T) + THREE*EXP(-FOUR*TI)
            W3 = EXP(-TI*X1)
            W4 = EXP(-TI*X2)
            W5 = EXP(-TI*X5)
         else
            RET = NoForG
            GOTO 90000
         end if
         RI = X3*W3 - X4*W4 + X6*W5 - YI

         IF ( .NOT. GONLY ) F = F + RI*RI

         IF ( .NOT. FONLY ) then
            W1 = TI*RI
            G1 = G1 - W3*W1
            G2 = G2 + W4*W1
            G3 = G3 + W3*RI
            G4 = G4 - W4*RI
            G5 = G5 - W5*W1
            G6 = G6 + W5*RI
         end if

      end do

      IF ( .NOT. FONLY ) then
         G(1) = TWO*X3*G1
         G(2) = TWO*X4*G2
         G(3) = TWO  * G3
         G(4) = TWO  * G4
         G(5) = TWO*X6*G5
         G(6) = TWO  * G6
      end if



!--------- TESTPACK FUNCTION   BOX663 ( X, F, G, IFG, NINT(ARGUMENTS(1)))
!--------- NINT(ARGUMENTS(1)) IS M

    Case( 16 )

 2600 IF ( .NOT. GONLY ) F = ZERO

      IF ( .NOT. FONLY ) then
         G1 = ZERO
         G2 = ZERO
         G3 = ZERO
      end if

      DO I = 1,NINT(ARGUMENTS(1))
         W2 = Real(I)
         TI = W2/TEN
         IF ( MAX(-W2,-TI,-TI*X(1),-TI*X(2)) <= BIGGST ) then
            W3 = EXP(-TI * X(1))
            W4 = EXP(-TI * X(2))
            W5 = EXP(-TI) - EXP(-W2)
         else
            RET = NoForG
            GOTO 90000
         end if
         RI = W3 - W4 - W5*X(3)

         IF ( .NOT. GONLY ) then
            IF ( ABS(RI) <= SQRT(MACHHUGE-MAX(F,ZERO)) ) then
               F = F + RI*RI
            else
               RET = NoForG
               GOTO 90000
            end if
         end if

         IF ( .NOT. FONLY ) then
            W2 = TI*RI
            G1 = G1 - W3*W2
            G2 = G2 + W4*W2
            G3 = G3 - W5*RI
         end if

      end do

      IF ( .NOT. FONLY ) then
         G(1) = TWO * G1
         G(2) = TWO * G2
         G(3) = TWO * G3
      end if



!--------- TESTPACK FUNCTION     SCHMVT

    Case( 24 )

 3400 X1 = X(1)
      X2 = X(2)
      X3 = X(3)

      W1 = X1 - X2
      W2 = X1 + X3

      W3 = ONE + W1*W1
      W4 = (PI*X2 + X3) / TWO
      W5 = (W2/X2) - TWO
      IF ( -W5**2 <= BIGGST ) then
         W6 =  EXP(-W5*W5)
      else
         RET = NoForG
         GOTO 90000
      end if

      IF ( .NOT. GONLY ) F = - ((ONE/W3) + SIN(W4) + W6 )

      IF ( .NOT. FONLY ) then

         W3 = TWO*W1/(W3*W3)
         W4 = COS(W4)/TWO
         W6 = TWO*W5*W6/X2

         G(1) =  W3 +    W6
         G(2) = -W3 - PI*W4 - W6*W2/X2
         G(3) = -W4 +    W6

      end if


!--------- TESTPACK FUNCTION     ENGVL2

    Case( 25 )

 3500 X1 = X(1)
      X2 = X(2)
      X3 = X(3)

      W1 = X1*X1
      W2 = X1*W1
      W3 = X2*X2
      W4 = X3*X3

      W5 = X3 - TWO
      W6 = FIVE*X3 - X1 + ONE
      W7 = W1 + W3 - ONE

      W8  = W7 + W4
      W9  = W7 + W5*W5
      W10 = X1 + X2 + X3 - ONE
      W11 = X1 + X2 - X3 + ONE
      W12 = W2 + THREE*W3 + W6*W6 - C36

      IF ( .NOT. GONLY ) F = W8*W8 + W9*W9 + W10*W10 + W11*W11 + W12*W12

      IF ( .NOT. FONLY ) then
         W10  = W8 + W9
         G(1) = TWO*(TWO*X1*W10 + TWO*(X1+X2) + W12*(THREE*W1-TWO*W6))
         G(2) = TWO*(TWO*X2*W10 + TWO*(X1+X2) + SIX*W12*X2)
         G(3) = TWO*(TWO*(W8*X3+W5*W9) + TWO*X3 - TWO + TEN*W12*W6)
      end if



!--------- TESTPACK FUNCTION     BARD70

    Case( 26 )

 3600 X1 = X(1)
      X2 = X(2)
      X3 = X(3)

      IF ( .NOT. GONLY ) F = ZERO

      IF ( .NOT. FONLY ) then
         G1 = ZERO
         G2 = ZERO
         G3 = ZERO
      end if

      DO I=1,15

         W1 = Real(I)
         W2 = Real(16-I)
         W3 = MIN(W1,W2)

         W4 = X2*W2 + X3*W3
         RI = BARD7Y(I) - (X1 + W1/W4)
         W4 = W4*W4

         IF ( .NOT. GONLY ) F = F + RI*RI

         IF ( .NOT. FONLY ) then
            W4 = RI*W1/W4
            G1 = G1 - RI
            G2 = G2 + W2*W4
            G3 = G3 + W3*W4
         end if
      end do

      IF ( .NOT. FONLY ) then
         G(1) = G1*TWO
         G(2) = G2*TWO
         G(3) = G3*TWO
      end if


!--------- TESTPACK FUNCTION     CRGLVY

    Case( 27 )

 3700 X1 = X(1)
      X2 = X(2)
      X3 = X(3)
      X4 = X(4)

      W1 = X2 - X3
      W2 = X3 - X4
      W3 = X4 - ONE

      IF ( X1 <= BIGGST ) then
         W4 =  EXP(X1)
      else
         RET = NoForG
         GOTO 90000
      end if
      W5 =  W4 - X2
      W6 =  TAN(W2)

      IF ( .NOT. GONLY ) F = W5**4 + c100*W1**6 + W6**4 + X1**8 + W3*W3

      IF ( .NOT. FONLY ) then

         W2 = COS(W2)
         W5 = FOUR * W5**3
         W1 = C600 * W1**5
         W6 = FOUR * W6**3 / (W2*W2)

         G(1) =  W4*W5 + EIGHT*X1**7
         G(2) = -W5 + W1
         G(3) = -W1 + W6
         G(4) = -W6 + TWO*W3
      end if



!--------- TESTPACK FUNCTION     PENAL1 ( X, F, G, IFG,
!                                         ARGUMENTS(1), ARGUMENTS(2)      )
!--------- ARGUMENTS(1) IS A
!--------- ARGUMENTS(2) IS B

    Case( 40 )

 5000 RF1 = ARGUMENTS ( 1 )
      RF2 = ARGUMENTS ( 2 )

      W1 = - ONE / FOUR
      W2 =  ZERO

      DO J = 1, N
         W3 = X(J)
         W1 = W1 + W3*W3
         W3 = W3 - ONE
         W2 = W2 + W3*W3
      end do

      IF ( .NOT. GONLY ) F = RF1*W2 + RF2 *W1*W1

      IF ( .NOT. FONLY ) then
         W1 = FOUR*RF2*W1
         W2 =  TWO*RF1
         DO J = 1, N
            W3   = X(J)
            G(J) = W2 * (W3 - ONE) + W3*W1
         end do
      end if



!--------- TESTPACK FUNCTION     PENAL2 ( X, F, G, IFG )
!--------- ARGUMENTS(1) IS A
!--------- ARGUMENTS(2) IS B

    Case( 41 )

 5100 RF1 = ARGUMENTS ( 1 )
      RF2 = ARGUMENTS ( 2 )

      IF ( SIZE(WORK) < 2 * N ) then
         F = ZERO
         G = ZERO
         GOTO 90000
      end if

      W1 = EXP(TENTH)
      W2 = EXP(-TENTH)
      W3 = ZERO

      I1 = 0
      I2 = N

      DO K = 1, N
         W4 = X(K)
         W3  = W3 + Real( N - K + 1 ) * W4 * W4
         IF ( TENTH*W4 <= BIGGST ) then
            W5 = EXP (TENTH * W4)
         else
            RET = NoForG
            GOTO 90000
         end if

         IF ( K == 1 ) then
            W6 = ZERO
            W7 = ONE

         else
            W7  = W9 * W1
            W10 = W5 + W8 - (W7 + W9)
            W11 = W5 - W2

            IF ( .NOT. FONLY ) then
               WORK(I1+K) = W10
               WORK(I2+K) = W11
            end if

            IF ( .NOT. GONLY ) W6 = W6 + W10*W10 + W11*W11

         end if

         W8 = W5
         W9 = W7

      end do

      W1 = X(1) - FIFTH
      W2 = W3   - ONE

      IF ( .NOT. GONLY ) &
         F = RF1 * W6  +  RF2* ( W1*W1 + W2*W2 )

      IF ( .NOT. FONLY ) then
         W3 = FIFTH * RF1
         W2 = FOUR  * RF2 * W2

         DO K = 1, N

!          --NOTE THAT W8 DOES NOT NEED TO BE PRE-DEFINED WHEN K = 1.

            W4 = X(K)
            IF ( TENTH*W4 <= BIGGST ) then
               W5 = EXP(TENTH * W4)
            else
               RET = NoForG
               GOTO 90000
            end if
            W6 = W8
            W7 = WORK(I2+K)

            IF ( K < N ) then
               W8 = WORK(I1+K+1)
               IF ( K == 1 ) then
                  G(1) = W3 * W5 * (           W8 )           &
                       + W2 * W4 * Real(N)  +  W1 * TWO * RF2

               else
                  G(K) = W3 * W5 * ( W6 + W7 + W8 )           &
                       + W2 * W4 * Real( N - K + 1 )

               end if

            else
                  G(N) = W3 * W5 * ( W6 + W7      )           &
                       + W2 * W4

            end if

         end do

      end if


!----    SARSEB (Test problem 1 from Lootsma p 67.)

    Case( 81 )

      x1 = x(1)
      x2 = x(2)
      x3 = x(3)
      x4 = x(4)

      w1 = two*x1 - x3 - one
      w2 = x2 - three
      w3 = two*x3 + x4 + one
      w4 = x4 - one

      IF ( .NOT. GONLY ) f = x1*w1 + x2*w2 + x3*w3 + x4*w4

      IF ( .NOT. FONLY ) then
         g(1) = w1  +  two * x1
         g(2) = w2  +  x2
         g(3) = w3  +  two * x3   -  x1
         g(4) = w4  +  x4  +  x3
      end if

      Case Default;  GOTO 90000
      end select


! EXIT:

90000 IFG    =  RET

      return

! FORMATS: None.

end Subroutine FUNCTIONS

end Module  Test_Functions
! <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> toms.f90
      PROGRAM Test_Minimize_f

! DESCRIPTION:
!
!     This is a routine provided to test  the minimization routine minimize_f
!     after installation on a particular system.  It calls  minimize_f
!     to minimize a collection of 10 test functions which are provided
!     in the module Test_Functions.
!
!     It also serves as a model to illustrate the use of some of the
!     features of the minimization algorithm implementation.
!
!     For an example of the coding of a test function, see the routine
!     Functions in the file test_functions.f90.
!
!     Each function is minimized several times.  Tests involve analytic
!     and differenced derivatives and use both forward and reverse
!     communication. Both the conjugate gradient and quasi-Newton codes
!     are tried as well as the Nocedal updates.  These are the standard
!     tests performed with the namelist file provided.  A total of 73
!     test runs will be executed.
!
!     Note that test #8 runs a function with n = 500 using the quasi-Newton
!     method, if enough memory is available.  On a Sun Sparc10 (which runs at
!     about 5 megaflops), this function takes about 130 seconds to minimize at
!     double precision.  On a Sparc1 (about 0.7 megaflops), it takes over
!     660 secs.

!     If it is preferred that this long test not be run, simply set the
!     single occurrence of the argument  run8  in the file namelist.inp
!     to false.  In this case, only 72 test runs will be made instead of 73.
!     The time required on a SPARCstation 1 is then reduced to about 110 secs.
!
!----- Summary of Tests.
!
!   Standard tests:
!     1. Forward call, analytic derivatives, method = Available.
!     2. Reverse call, analytic derivatives, method = Available.
!     3. Forward call, finite differences,   method = Available.
!     4. Forward call, derivative testing,   method = Available.
!     5. Forward call, analytic derivatives, method = FixTerms.
!     6. Reverse call, analytic derivatives, method = QN.
!     7. Forward call, analytic derivatives, method = Available,Nocedal updates.
!     8. Forward call, analytic derivatives, method = Available, function #11
!        only (dimension large).
!     9. Forward call, analytic derivatives, method = Dynamic, expense = 1,
!        function #11 only (dimension large).
!    10. Forward call, analytic derivatives, method = Dynamic, expense = 300,
!        function #11 only (dimension large).
!
!     The auxiliary tests listed below provide extra testing, but require a more
!     extensive namelist file.  They also use a quadratic function that is not
!     used in the standard set of tests.  The auxiliary tests are *not* used
!     in testing the minimization routine after installation on a new system.
!
!   Auxiliary tests:
!    11. Forward call, analytic derivatives, method = ConMin.
!    12. Forward call, analytic derivatives, method = Variable, Nocedal updates.
!    13. Forward call, analytic derivatives, method = SD,
!        exact line search with quadratic function sarseb only.
!    14. Forward call, analytic derivatives, method = CG,
!        exact line search with quadratic function sarseb only.
!
! SUBROUTINES:
!
!     minimize_f
!     evaluate_f
!
!     My_Date_Time
!     CpuSecs
!
!     functions
!        bard70, biggs6, box663, crglvy, engvl2  |a subset of a full coll-
!        penal1, penal2, pwsing, rosenb, schmvt  |ection of test functions
!        sarseb
!
! PARAMETERS:

    USE Minimize
    USE Support,        only : Evaluate_f
    USE Supp_Codes,     only : Both, Analytic
    USE Supp_Defs,      only : DefaultEvalState, InitEvalCts
    USE Min_Codes,      only : RevCommStart, RevCommRestart, RevCommFandG, &
                               Normal, Available, SumForm, Ident
    USE Min_States,     only : TraceList
    USE General,        only : CpuSecs, My_Date_Time
    USE Reals
    USE True_False
    USE Test_Functions

                         Implicit NONE
                        !-------------!

    Integer,        PARAMETER :: mxn    = 500,       & ! maximal dimension
                                 tests  = 14,        & ! number of tests
                                 nprobs = 12,        & ! number of problems
                                 ttests = tests*nprobs

    Integer(short), PARAMETER :: trminp = 5,      & ! interactive input
                                 trmout = 6,      & ! interactive output
                                 inpt   = 7,      & ! input from data file
                                 outpt  = 8         ! output from tests

    Integer(long),  PARAMETER :: freq   =  1000,  & ! print first/last points
                                 memory = 130000    ! available memory

! LOCAL DECLARATIONS:

    !---- Places to hold some statistics and stuff from the tests.

    Integer      ::  icnts(ttests), fcnts(ttests), fnct, grct, &
                     indx(nprobs), compnt(nprobs)

    Real (stnd)  ::  fvals(ttests), acctim, acc

    !---- Various declarations needed to run the tests.

    Type(TraceList) :: DoTraces

    Integer  ::  n, error, i, m, contrl, from, to, pdone, tfncs, titers, mprobs

    Integer, PARAMETER :: &

          dim   (nprobs) = (/  3,  6,  3,  4,  3, 10, 10, 40, 2,  3, 500, 4 /),&
          ifnc  (nprobs) = (/ 26, 11, 16, 27, 25, 40, 41,  3, 1, 24,   3,81 /)

    Real (stnd), PARAMETER  :: &
          rpar1(nprobs) = (/ ZERO,  c13,    TEN, ZERO, ZERO,          &
                             c1_m5, c1_m5, ZERO, ZERO, ZERO, ZERO, ZERO /), &
          rpar2(nprobs) = (/ ZERO,  ZERO,  ZERO, ZERO, ZERO,          &
                              ONE,   ONE,  ZERO, ZERO, ZERO, ZERO, ZERO /)

    Real (stnd)     :: x(mxn), g(mxn), dererr(nprobs),                &
                       fx,     time,   averrs(nprobs)

    !---- Declarations for remaining Minimize_f arguments.

    Integer (short) :: status, state, case, derv, meth, update, set_h0, expens
    Integer (long)  :: mterms, chkpoint
    Logical         :: dotrace, exact
    Character*30    :: chkfile

    Type (MinimizeState)  :: C

    Logical         :: firsttime, run8

    Character*41 :: date
    Character*60 :: title(tests) = & !     Output identification.

        (/ ' analytic mode, forward calls; meth= Available.             ' ,   &
           ' analytic mode, reverse calls; meth= Available.             ' ,   &
           ' differencing,  forward calls; meth= Available.             ' ,   &
           ' testing mode,  forward calls; meth= Available.             ' ,   &
           ' analytic mode, forward calls; meth= FixTerms.              ' ,   &
           ' analytic mode, reverse calls; meth= QN.                    ' ,   &
           ' analytic mode, forward calls, meth= Available, Nocedal ups.' ,   &
           ' analytic mode, forward calls; meth= Available, big n.      ' ,   &
           ' analytic mode, forward calls; meth= Dynamic,   big n.      ' ,   &
           ' analytic mode, forward calls; meth= Dynamic, big expense,n.' ,   &
           ' analytic mode, forward calls, meth= ConMin.                ' ,   &
           ' analytic mode, forward calls, meth= Variable, Nocedal ups. ' ,   &
           ' analytic mode, forward calls, meth= SD, exact line search. ' ,   &
           ' analytic mode, forward calls, meth= CG, exact line search. '   /)

    Namelist / Args / state,   dotrace,  chkpoint,  chkfile,  exact,  expens, &
                      derv,    meth,     mterms,    update,   set_h0, run8

! EXECUTION:

    acctim = ZERO        !---- Initialize timing.

    open ( inpt,  file = 'namelist.inp', action = 'READ' )
    open ( outpt, file = 'results' )
    call My_Date_Time  (date)
    write ( outpt, 99993 ) ' starting test at ', date

    error  = 0      ! Initialize counts.
    pdone  = 0
    tfncs  = 0
    titers = 0

    dererr = ZERO
    compnt = 0
    indx   = 0
    averrs = ZERO

    fvals = ZERO
    fcnts = 0
    icnts = 0

    mprobs = 10     ! Do minimizations. Run each of the test types.
    to     = mprobs
    contrl = 0

!   Initialize accuracy.

    IF ( stnd == Selected_Real_Kind(12) ) then
        acc  = 5.0d-04   ! accuracy for normal precision
    else if ( stnd == Selected_Real_Kind(6) ) then
        acc  = 4.0d-03   ! accuracy for low precision
    end if

    TESTSET: &
    DO m = 1,tests

!       Default settings for some of the arguments of Minimize_f.
!       These arguments can be overridden by namelist input:

        state    = Normal
        dotrace  = false
        chkpoint = 0
        chkfile  = 'ChkPt'
        exact    = false
        expens   = 1
        derv     = Analytic
        meth     = Available
        mterms   = 0
        update   = SumForm
        set_h0   = Ident

        run8     = true

        read(inpt,nml=Args,end=90)  ! read namelist data

        ! Write title, unless no output requested.

        write ( trmout, "('  Ready for run #',i2,':', a)" ) m, title(m)
        IF ( freq /= 0 ) write ( outpt, 99999 ) m, title(m)

        ! Here we have a chance to choose a subset of the problems to test.

        IF ( .not. run8 ) CYCLE  ! If run8 = false, do not run test #8.

     50 IF ( contrl /= -3 ) then
            contrl = -3
            write(trmout,*) ' control: 0 quit'
            write(trmout,*) '         -1 skip to next set,'
            write(trmout,*) '         -2 finish this set'
            write(trmout,*) '         -3 (or eof) finish full run'
            write(trmout,*) '        n > 0 do problem #n'
            read(trminp,'(bn,i2)', end=59 ) contrl
        end if

     59 Select CASE (contrl)
            Case (1:);  from = contrl
                        to   = contrl
            Case (0);   goto 90
            Case (-1);  CYCLE
            Case (-2);  from = mod(to,mprobs)+1
                        to   = mprobs
            Case (-3);  from = mod(to,mprobs)+1
                        to   = mprobs
        end select

        ! For tests 8 through 10 just use function 11 (pwsing with n=500).
        ! For tests 13 and 14 just use function 12 (sarseb).

        Select CASE( m )
            Case(8,9,10)
                from     = 11
                to       = 11
                mprobs   = 11
            Case(11,12)
                IF ( contrl < 1 ) then
                    from = 1
                    to   = 10
                end if
                mprobs   = 10
            Case(13,14)
                from     = nprobs
                to       = nprobs
                mprobs   = nprobs
        end select

        time   = CpuSecs()     ! Start timing
        acctim = acctim - time

        EachFUNCTION: &
        DO i = from,to     !Repeat for each test function selected.

            pdone = pdone + 1
            IF (pdone > ttests) then
               write ( outpt, * ) ' too many tests: stopping.'
               goto 99
            end if

            IF ( freq /= 0 ) write ( outpt, 99994 ) i

            n            = dim(i)       ! Set dimension, etc.
            funcno       = ifnc(i)
            arguments(1) = rpar1(i)
            arguments(2) = rpar2(i)

            Select CASE ( i )   ! Set starting point.
                Case(1);  x(1:n) = (/ ONE, ONE, ONE /)
                Case(2);  x(1:n) = (/ ONE, TWO, ONE, ONE, ONE, ONE /)
                Case(3);  x(1:n) = (/ ZERO,TEN, c20 /)
                Case(4);  x(1:n) = (/ ONE, TWO, TWO, TWO /)
                Case(5);  x(1:n) = (/ ONE, TWO, ZERO /)
                Case(6);  x(1:n) = (/ (i, i=1,n) /)
                Case(7);  x(1:n) =   HALF
                Case(8);  x(1:n) = (/ (THREE, -ONE, ZERO, ONE, i=1,n/4) /)
                Case(9);  x(1:n) = (/ -c1_2, ONE /)
                Case(10); x(1:n) =   HALF
                Case(11); x(1:n) = (/ (THREE, -ONE, ZERO, ONE, i=1,n/4) /)
                Case(12); x(1:n) = (/ c20, c20, c20, c20 /)
            end select

            ! ---Set up calls to minimize.

            if ( dotrace ) then
                DoTraces = TraceList(6,0,true,true,true,true,true,&
                                         true,true,true,true,true,true)
            else
                DoTraces = TraceList(6,0,false,false,false,false,false,&
                                         false,false,false,false,false,false)
            end if

            Select CASE (m)

                Case(1,3,4,5,7:)  ! Forward calls

                    status    = state
                    call Minimize_f &
                         (Functions, x(1:n),fx,g,acc,status,Memory,C,      &
                          Traces            = DoTraces,                    &
                          CheckPoint        = chkpoint,                    &
                          CheckFile         = chkfile,                     &
                          ExactLS           = exact,                       &
                          Expense           = expens,                      &
                          RelativeToF0      = true,                        &
                          RelativeToG0      = true,                        &
                          UseGrad           = false,                       &
                          UseStep           = true,                        &
                          PrintUnit         = 8_short,                     &
                          Frequency         = freq,                        &
                          Derivatives       = derv,                        &
                          Method            = meth,                        &
                          Terms             = mterms,                      &
                          UpdateForm        = update,                      &
                          SetH0             = set_h0                       )

                    if ( m == 4 ) then
                        dererr(i) = C%EvalErs%Worst
                        averrs(i) = C%EvalErs%Average
                        compnt(i) = C%EvalErs%Index
                        indx  (i) = C%EvalErs%Gradcnt
                    end if

                Case(2,6)  ! Reverse communication

                    status    = state
                    C%Eval    = DefaultEvalState
                    firsttime = true

                    DO
                        case         = Both
                        call Evaluate_f &
                             (Functions, x(1:n), fx, g(1:n), case, &
                              C%Eval, C%EvalCts, first=firsttime )
                        call Minimize_f &
                             (Functions, x(1:n),fx,g,acc,status,Memory,C,      &
                              Traces            = DoTraces,                    &
                              CheckPoint        = chkpoint,                    &
                              CheckFile         = chkfile,                     &
                              ExactLS           = exact,                       &
                              Expense           = expens,                      &
                              RelativeToF0      = true,                        &
                              RelativeToG0      = true,                        &
                              UseGrad           = false,                       &
                              UseStep           = true,                        &
                              PrintUnit         = 8_short,                     &
                              Frequency         = freq,                        &
                              Derivatives       = derv,                        &
                              Method            = meth,                        &
                              Terms             = mterms,                      &
                              UpdateForm        = update,                      &
                              SetH0             = set_h0                       )

                        IF (status /= RevCommFandG) EXIT
                        status       = RevCommRestart
                        firsttime    = false
                    end do

            end select

            IF ( status /= done ) then    !  Add number of errors.
                error = error + 1
            end if

            fnct   = C%EvalCts%FEvals
            grct   = C%EvalCts%GEvals

            fvals(pdone) = fx
            fcnts(pdone) = C%EvalCts%FEvals
            icnts(pdone) = C%Shared%it

            tfncs  = tfncs  + C%EvalCts%FEvals
            titers = titers + C%Shared%it

            IF ( freq /= 0 ) write ( outpt, 99997 ) status

        end do EachFUNCTION

        time   = CpuSecs()
        acctim = acctim + time

        IF ( m == 4 ) then
            IF ( freq /= 0 ) write ( outpt, 99998 )   &
                 (dererr(i),compnt(i),indx(i),averrs(i),i = 1,mprobs)
        end if

        IF ( to /= mprobs ) goto 50

    end do TESTSET

 90 write ( outpt, 99991 )
    write ( outpt, 99992 ) (i,icnts(i),fvals(i),fcnts(i),i=1,pdone)

    write ( outpt,   99996 ) pdone, error, tfncs, titers
    write ( outpt,   99995 ) acctim
    write ( trmout,   *   ) ' '
    write ( trmout,   *   ) ' '
    write ( trmout,   *   ) ' '
    write ( trmout, 99995 ) acctim

    call My_Date_Time (date)
    write ( outpt, 99993 ) ' test ended at ', date
    write (trmout, 99993 ) ' test ended at ', date

! EXIT:

99 stop

! FORMATS:

99991 format (// ' rn its funct. value fns |',   &
                 ' rn its funct. value fns |',   &
                 ' rn its funct. value fns'/ ,   &
                 ' ------------------------|',   &
                 '-------------------------|',   &
                 '------------------------')

99992 format ( (2(i3,i4,1x,e12.6,i4,' |'), (i3,i4,1x,e12.6,i4)  ))

99993 format ( 4a // )

99994 format ( /' function #', i2 / )

99995 format ( ' time taken was ', f12.3, ' seconds.' )

99996 format ( // ' *****Test Finished****   problems done ',i3,       &
                   '; number of errors is ',i2,'.' /                   &
                   '                total function calls = ',i4,       &
                                 ' total iterations = ', i4 // )

99997 format ( /' ************* Run Complete, status = ', i3, '.'/ )

99998 format ( //' Testing mode derivative estimation errors' //       &
                 ' max error  component  iterate  av. decimals '  //   &
                 10 ( e10.2,    i7,    7x,  i5,     f9.2  /)    )

99999 format ( '1 beginning run #', i2, ':', a )

!END:

      end
! <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> rosenbrockfunc.f90
MODULE RosenbrockFunc

    USE Precision,  only    : stnd, short
    USE Supp_Codes, only    : justf, justg, both, OK
    USE Reals,      only    : one, two, c100, c200, c400

CONTAINS

    SUBROUTINE Rosenbrock ( x, f, g, job )

        Real(stnd),     intent(IN)     :: x(:)
        Real(stnd),     intent(OUT)    :: f, g(size(x))

        Integer(short), intent(INOUT)  :: job

        Real(stnd)  :: w1, w2       ! temporaries

        Logical     :: dof, dog

        dof =    job == justf  .or. job == both
        dog =    job == justg  .or. job == both

        w1 = x(2) - x(1)**2;    w2 =  one - x(1)

        IF ( dof ) then
             f = c100*w1**2 + w2**2
        end if

        IF ( dog ) then
             g(1) = -c400 * w1 * x(1) - two*w2
             g(2) =  c200 * w1
        end if

        job =  OK
    return
    end Subroutine Rosenbrock

end Module RosenbrockFunc
! <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> <<=>> example.f90
Program Min_Rosenbrock

    USE Minimize
    USE RosenbrockFunc
    USE Reals,          only :  c1_2, one

    Implicit None

    Integer(long), PARAMETER :: n = 2
    Integer(short)           :: state

    Real(stnd),   PARAMETER  :: acc = 0.001
    Real(stnd)               :: f, x(n), g(n)

    Type(MinimizeState)      :: C

    x = (/ -c1_2, one /)  ! set the initial guess.

    state = Normal

    Call Minimize_f (Rosenbrock, x, f, g, acc, state, 0, C, &
                     Frequency = 10, EvalLimit = 200 )

    IF ( state == Done ) then
       print*,'Least function value:      ',f, '.'
       print*,'Function evaluation count: ',C%EvalCts%FEvals,'.'
       print*,'Iteration count:           ',C%Shared%it,'.'
    else
       print*, 'Failure: state = ', state
    end if
    stop
end
